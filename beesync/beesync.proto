syntax = "proto3";
package beesync;
option go_package = "github.com/thinkparq/protobuf/beesync/go;beesync";

import "beegfs/beegfs.proto";

service BeeSync {
    rpc UpdateConfig(ConfigUpdateRequest) returns (ConfigUpdateResponse);    
    rpc WorkRequest(SyncRequest) returns (beegfs.WorkResponse);
    // UpdateWorkRequest is used to change the state of existing work requests,
    // including cancelling them at a users request, or cancelling after an unclean
    // start where there are entries in the request journal we need to ensure don't
    // have outstanding work requests that we don't know about anymore.     
    rpc UpdateWorkRequest(beegfs.UpdateWorkRequest) returns (beegfs.WorkResponse);
    // BeeRemote keeps track of the state of each worker node by establishing a
    // bidirectional RPC stream with each node. When first connecting BeeRemote
    // sends an UpdateWorkRequests message letting the worker node know what to
    // do with any outstanding work requests it has. This allows all or a subset
    // of requests to be invalidated if they were cancelled while the node was
    // disconnected. After the state of existing requests has been negotiated,
    // BeeSync will start streaming back work responses for outstanding and new
    // work requests. By using a bidirectional stream BeeSync is able to
    // asynchronously return Work Responses without needing needing to be
    // configured to talk to BeeRemote (such as the IP address).
    rpc NodeStream(beegfs.UpdateWorkRequests) returns (stream beegfs.WorkResponse);
}

// All RemoteStorageTarget(s) that should be configured need to be included in
// each message. Any that are not included will be deleted.
message ConfigUpdateRequest {
    repeated RemoteStorageTarget rsts = 1;
}

message ConfigUpdateResponse {
    Result result = 1;
    // Message should be used to return any additional details, particuarly to aid in troubleshooting.
    string message = 2;

    enum Result {
        UNKNOWN = 0; // Should not be used. Exists only as the default if there is a programming error.
        SUCCESS = 1; // The configuration was succesfully updated.
        PARTIAL = 2; // The configuration was partially updated (see the message for details).
        FAILURE = 3; // The configuration was not updated.
    }
}

// A SyncJob is WHAT work needs to be done. It is populated based on the
// file system modification event or by a user describing some work that needs
// to be done. It does not carry any details about HOW the request will be
// fufilled (that is part of the generated SyncRequest).
message SyncJob {
    Operation operation = 1;
    enum Operation {
        UNKNOWN = 0;
        UPLOAD = 1;
        DOWNLOAD = 2;
    }
    // This is the string based ID, NOT an actual reference to an RST. 
    // This ensures we don't have to include the full RST configuration,
    // every time we send a Entry (commonly as part of a Job).
    string remote_storage_target = 2;    
}

// A SyncRequest describes HOW a SyncJob should be carried out. It encapsulates
// the details of the part of a SyncJob assigned to a particular BeeSync node
// along with its state including the auto generated ID, segment, and status
// fields. It is expected the fields in a SyncRequest will be populated over
// time as the job progresses. For example when BeeRemote initially starts a job
// Segment will not be set so BeeSync can determine if it should determine this
// (based on file size and autostart_max_size), or if it needs to send the job
// back to BeeRemote so it can determine if the job should be distributed across
// multiple nodes. Therefore it is critical to understand the concept of field
// presence in proto3: https://protobuf.dev/programming-guides/field_presence/
// TL;DR - Generally expect fields to default to the language specific default
// values for each type for any fields that were not set by the server.
message SyncRequest {
    string request_id = 1;
    beegfs.JobMetadata metadata = 2;
    string path = 3;
    SyncJob job = 4;
    Segment segment = 5;
}

// A segment indicates what portion of a file transfer a particular BeeSync node should work on.
message Segment {
    int64 offset_start = 1;
    int64 offset_stop = 2;

    // Method defines fields required to figure out "what" and "how" to transfer content.
    oneof method {
        bool default = 3;
        S3 s3 = 4;
    }

    // BeeSync calculates the amount of data to write in each part based on offset_start and offset_stop.
    message S3 {
        string multipart_id = 1;
        int32 parts_start = 2;
        int32 parts_stop = 3;
        repeated CompletedParts completed_parts = 4;

        message CompletedParts {
            int32 part_number = 1;
            string entity_tag = 2;
            string checksum = 3;
        }
    }
}

// Note while there is a lot of data contained in RemoteStorageTarget,
// gRPC will not serialize fields to the wire unless they are set.
// https://protobuf.dev/programming-guides/proto3/#specifying-field-rules
// This allows us to define all possible fields that may need to be sent 
// to BeeSync to configure different target types, without extra overhead.
message RemoteStorageTarget {
    string id = 1;
    string name = 2;
    Policies policies = 3; 

    // TODO: consider if defining policies would be more flexible as a map.
    // These could change a lot early on, and defining them here creates a contract 
    // we won't ever remove/change them.
    message Policies {
        bool local_flock = 1;   
        bool remote_flock = 2;
        bool keep_dir_structure = 3;
        bool keep_beegfs_metadata = 4; // If BeeGFS metadata should be stored as extended attributes/metadata (if supported).
        uint32 autostart_max_size = 5; // If the file is smaller than this, we will start the job automatically.
        // int32 cooldown = 4; // Not really relevant for BeeSync.
        // Future fields could include ReplicationPolicy. 
    }

    // Type defines fields required to figure out "where" to transfer content.
    // IMPORTANT: When adding a new RST type before it can be configured by
    // BeeRemote it must also be added to the supportedRSTTypes map in
    // config.SetRSTTypeHook() to allow its configuration to be unmarshalled
    // into the Go structs generated by protoc.
    oneof type { // Ref: https://groups.google.com/g/protobuf/c/ojpYHqx2l04
        S3 s3 = 4;
        POSIX posix = 5;
        Azure azure = 6;
    }

    message S3 {
        string bucket = 1;
        string region = 2;
        string endpoint = 3;
        string access_key = 4;
        string secret_key = 5;
    }

    message Azure {
        S3 s3 = 1;
        string account = 2;
    }
    
    message POSIX {
        string path = 1;
    }
}