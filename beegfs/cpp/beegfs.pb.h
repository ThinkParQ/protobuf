// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: beegfs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_beegfs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_beegfs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_beegfs_2eproto;
namespace beegfs {
class JobMetadata;
struct JobMetadataDefaultTypeInternal;
extern JobMetadataDefaultTypeInternal _JobMetadata_default_instance_;
class RequestStatus;
struct RequestStatusDefaultTypeInternal;
extern RequestStatusDefaultTypeInternal _RequestStatus_default_instance_;
class UpdateWorkRequest;
struct UpdateWorkRequestDefaultTypeInternal;
extern UpdateWorkRequestDefaultTypeInternal _UpdateWorkRequest_default_instance_;
class UpdateWorkRequests;
struct UpdateWorkRequestsDefaultTypeInternal;
extern UpdateWorkRequestsDefaultTypeInternal _UpdateWorkRequests_default_instance_;
class UpdateWorkRequests_job;
struct UpdateWorkRequests_jobDefaultTypeInternal;
extern UpdateWorkRequests_jobDefaultTypeInternal _UpdateWorkRequests_job_default_instance_;
class WorkResponse;
struct WorkResponseDefaultTypeInternal;
extern WorkResponseDefaultTypeInternal _WorkResponse_default_instance_;
}  // namespace beegfs
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace beegfs {
enum UpdateWorkRequests_State : int {
  UpdateWorkRequests_State_UNCHANGED = 0,
  UpdateWorkRequests_State_CANCEL = 1,
  UpdateWorkRequests_State_RESUME = 2,
  UpdateWorkRequests_State_UpdateWorkRequests_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateWorkRequests_State_UpdateWorkRequests_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UpdateWorkRequests_State_IsValid(int value);
constexpr UpdateWorkRequests_State UpdateWorkRequests_State_State_MIN = static_cast<UpdateWorkRequests_State>(0);
constexpr UpdateWorkRequests_State UpdateWorkRequests_State_State_MAX = static_cast<UpdateWorkRequests_State>(2);
constexpr int UpdateWorkRequests_State_State_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UpdateWorkRequests_State_descriptor();
template <typename T>
const std::string& UpdateWorkRequests_State_Name(T value) {
  static_assert(std::is_same<T, UpdateWorkRequests_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return UpdateWorkRequests_State_Name(static_cast<UpdateWorkRequests_State>(value));
}
template <>
inline const std::string& UpdateWorkRequests_State_Name(UpdateWorkRequests_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateWorkRequests_State_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UpdateWorkRequests_State_Parse(absl::string_view name, UpdateWorkRequests_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateWorkRequests_State>(
      UpdateWorkRequests_State_descriptor(), name, value);
}
enum RequestStatus_Status : int {
  RequestStatus_Status_UNKNOWN = 0,
  RequestStatus_Status_UNASSIGNED = 1,
  RequestStatus_Status_SCHEDULED = 5,
  RequestStatus_Status_RUNNING = 6,
  RequestStatus_Status_STALLED = 7,
  RequestStatus_Status_PAUSED = 8,
  RequestStatus_Status_FAILED = 9,
  RequestStatus_Status_COMPLETED = 10,
  RequestStatus_Status_CANCELLED = 11,
  RequestStatus_Status_RequestStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RequestStatus_Status_RequestStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RequestStatus_Status_IsValid(int value);
constexpr RequestStatus_Status RequestStatus_Status_Status_MIN = static_cast<RequestStatus_Status>(0);
constexpr RequestStatus_Status RequestStatus_Status_Status_MAX = static_cast<RequestStatus_Status>(11);
constexpr int RequestStatus_Status_Status_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
RequestStatus_Status_descriptor();
template <typename T>
const std::string& RequestStatus_Status_Name(T value) {
  static_assert(std::is_same<T, RequestStatus_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return RequestStatus_Status_Name(static_cast<RequestStatus_Status>(value));
}
template <>
inline const std::string& RequestStatus_Status_Name(RequestStatus_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RequestStatus_Status_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool RequestStatus_Status_Parse(absl::string_view name, RequestStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestStatus_Status>(
      RequestStatus_Status_descriptor(), name, value);
}
enum NewState : int {
  UNCHANGED = 0,
  CANCEL = 1,
  NewState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NewState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NewState_IsValid(int value);
constexpr NewState NewState_MIN = static_cast<NewState>(0);
constexpr NewState NewState_MAX = static_cast<NewState>(1);
constexpr int NewState_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
NewState_descriptor();
template <typename T>
const std::string& NewState_Name(T value) {
  static_assert(std::is_same<T, NewState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NewState_Name().");
  return NewState_Name(static_cast<NewState>(value));
}
template <>
inline const std::string& NewState_Name(NewState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NewState_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NewState_Parse(absl::string_view name, NewState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NewState>(
      NewState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateWorkRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:beegfs.UpdateWorkRequest) */ {
 public:
  inline UpdateWorkRequest() : UpdateWorkRequest(nullptr) {}
  ~UpdateWorkRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateWorkRequest(const UpdateWorkRequest& from);
  UpdateWorkRequest(UpdateWorkRequest&& from) noexcept
    : UpdateWorkRequest() {
    *this = ::std::move(from);
  }

  inline UpdateWorkRequest& operator=(const UpdateWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkRequest& operator=(UpdateWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkRequest*>(
               &_UpdateWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UpdateWorkRequest& a, UpdateWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateWorkRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateWorkRequest& from) {
    UpdateWorkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "beegfs.UpdateWorkRequest";
  }
  protected:
  explicit UpdateWorkRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIDFieldNumber = 1,
    kRequestIDFieldNumber = 2,
    kNewStateFieldNumber = 3,
  };
  // string jobID = 1;
  void clear_jobid() ;
  const std::string& jobid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jobid(Arg_&& arg, Args_... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* ptr);

  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(
      const std::string& value);
  std::string* _internal_mutable_jobid();

  public:
  // string requestID = 2;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* ptr);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // .beegfs.NewState newState = 3;
  void clear_newstate() ;
  ::beegfs::NewState newstate() const;
  void set_newstate(::beegfs::NewState value);

  private:
  ::beegfs::NewState _internal_newstate() const;
  void _internal_set_newstate(::beegfs::NewState value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.UpdateWorkRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr jobid_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    int newstate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};// -------------------------------------------------------------------

class UpdateWorkRequests_job final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:beegfs.UpdateWorkRequests.job) */ {
 public:
  inline UpdateWorkRequests_job() : UpdateWorkRequests_job(nullptr) {}
  ~UpdateWorkRequests_job() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkRequests_job(::google::protobuf::internal::ConstantInitialized);

  UpdateWorkRequests_job(const UpdateWorkRequests_job& from);
  UpdateWorkRequests_job(UpdateWorkRequests_job&& from) noexcept
    : UpdateWorkRequests_job() {
    *this = ::std::move(from);
  }

  inline UpdateWorkRequests_job& operator=(const UpdateWorkRequests_job& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkRequests_job& operator=(UpdateWorkRequests_job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkRequests_job& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkRequests_job* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkRequests_job*>(
               &_UpdateWorkRequests_job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UpdateWorkRequests_job& a, UpdateWorkRequests_job& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkRequests_job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkRequests_job* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkRequests_job* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateWorkRequests_job>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkRequests_job& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateWorkRequests_job& from) {
    UpdateWorkRequests_job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkRequests_job* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "beegfs.UpdateWorkRequests.job";
  }
  protected:
  explicit UpdateWorkRequests_job(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kIdFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* ptr);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // string id = 2;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .beegfs.UpdateWorkRequests.State state = 3;
  void clear_state() ;
  ::beegfs::UpdateWorkRequests_State state() const;
  void set_state(::beegfs::UpdateWorkRequests_State value);

  private:
  ::beegfs::UpdateWorkRequests_State _internal_state() const;
  void _internal_set_state(::beegfs::UpdateWorkRequests_State value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.UpdateWorkRequests.job)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    int state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};// -------------------------------------------------------------------

class UpdateWorkRequests final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:beegfs.UpdateWorkRequests) */ {
 public:
  inline UpdateWorkRequests() : UpdateWorkRequests(nullptr) {}
  ~UpdateWorkRequests() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkRequests(::google::protobuf::internal::ConstantInitialized);

  UpdateWorkRequests(const UpdateWorkRequests& from);
  UpdateWorkRequests(UpdateWorkRequests&& from) noexcept
    : UpdateWorkRequests() {
    *this = ::std::move(from);
  }

  inline UpdateWorkRequests& operator=(const UpdateWorkRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkRequests& operator=(UpdateWorkRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkRequests* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkRequests*>(
               &_UpdateWorkRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UpdateWorkRequests& a, UpdateWorkRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkRequests* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkRequests* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateWorkRequests>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkRequests& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateWorkRequests& from) {
    UpdateWorkRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkRequests* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "beegfs.UpdateWorkRequests";
  }
  protected:
  explicit UpdateWorkRequests(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateWorkRequests_job job;

  using State = UpdateWorkRequests_State;
  static constexpr State UNCHANGED = UpdateWorkRequests_State_UNCHANGED;
  static constexpr State CANCEL = UpdateWorkRequests_State_CANCEL;
  static constexpr State RESUME = UpdateWorkRequests_State_RESUME;
  static inline bool State_IsValid(int value) {
    return UpdateWorkRequests_State_IsValid(value);
  }
  static constexpr State State_MIN = UpdateWorkRequests_State_State_MIN;
  static constexpr State State_MAX = UpdateWorkRequests_State_State_MAX;
  static constexpr int State_ARRAYSIZE = UpdateWorkRequests_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return UpdateWorkRequests_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return UpdateWorkRequests_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return UpdateWorkRequests_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
    kDefaultStateFieldNumber = 2,
  };
  // repeated .beegfs.UpdateWorkRequests.job jobs = 1;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;

  public:
  void clear_jobs() ;
  ::beegfs::UpdateWorkRequests_job* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::beegfs::UpdateWorkRequests_job >*
      mutable_jobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::UpdateWorkRequests_job>& _internal_jobs() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::UpdateWorkRequests_job>* _internal_mutable_jobs();
  public:
  const ::beegfs::UpdateWorkRequests_job& jobs(int index) const;
  ::beegfs::UpdateWorkRequests_job* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::beegfs::UpdateWorkRequests_job >&
      jobs() const;
  // .beegfs.UpdateWorkRequests.State defaultState = 2;
  void clear_defaultstate() ;
  ::beegfs::UpdateWorkRequests_State defaultstate() const;
  void set_defaultstate(::beegfs::UpdateWorkRequests_State value);

  private:
  ::beegfs::UpdateWorkRequests_State _internal_defaultstate() const;
  void _internal_set_defaultstate(::beegfs::UpdateWorkRequests_State value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.UpdateWorkRequests)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::beegfs::UpdateWorkRequests_job > jobs_;
    int defaultstate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};// -------------------------------------------------------------------

class RequestStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:beegfs.RequestStatus) */ {
 public:
  inline RequestStatus() : RequestStatus(nullptr) {}
  ~RequestStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestStatus(::google::protobuf::internal::ConstantInitialized);

  RequestStatus(const RequestStatus& from);
  RequestStatus(RequestStatus&& from) noexcept
    : RequestStatus() {
    *this = ::std::move(from);
  }

  inline RequestStatus& operator=(const RequestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestStatus& operator=(RequestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestStatus* internal_default_instance() {
    return reinterpret_cast<const RequestStatus*>(
               &_RequestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestStatus& a, RequestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestStatus& from) {
    RequestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "beegfs.RequestStatus";
  }
  protected:
  explicit RequestStatus(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Status = RequestStatus_Status;
  static constexpr Status UNKNOWN = RequestStatus_Status_UNKNOWN;
  static constexpr Status UNASSIGNED = RequestStatus_Status_UNASSIGNED;
  static constexpr Status SCHEDULED = RequestStatus_Status_SCHEDULED;
  static constexpr Status RUNNING = RequestStatus_Status_RUNNING;
  static constexpr Status STALLED = RequestStatus_Status_STALLED;
  static constexpr Status PAUSED = RequestStatus_Status_PAUSED;
  static constexpr Status FAILED = RequestStatus_Status_FAILED;
  static constexpr Status COMPLETED = RequestStatus_Status_COMPLETED;
  static constexpr Status CANCELLED = RequestStatus_Status_CANCELLED;
  static inline bool Status_IsValid(int value) {
    return RequestStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = RequestStatus_Status_Status_MIN;
  static constexpr Status Status_MAX = RequestStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = RequestStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return RequestStatus_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return RequestStatus_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return RequestStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .beegfs.RequestStatus.Status status = 1;
  void clear_status() ;
  ::beegfs::RequestStatus_Status status() const;
  void set_status(::beegfs::RequestStatus_Status value);

  private:
  ::beegfs::RequestStatus_Status _internal_status() const;
  void _internal_set_status(::beegfs::RequestStatus_Status value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.RequestStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr message_;
    int status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};// -------------------------------------------------------------------

class JobMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:beegfs.JobMetadata) */ {
 public:
  inline JobMetadata() : JobMetadata(nullptr) {}
  ~JobMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JobMetadata(::google::protobuf::internal::ConstantInitialized);

  JobMetadata(const JobMetadata& from);
  JobMetadata(JobMetadata&& from) noexcept
    : JobMetadata() {
    *this = ::std::move(from);
  }

  inline JobMetadata& operator=(const JobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobMetadata& operator=(JobMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobMetadata* internal_default_instance() {
    return reinterpret_cast<const JobMetadata*>(
               &_JobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JobMetadata& a, JobMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(JobMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JobMetadata& from) {
    JobMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "beegfs.JobMetadata";
  }
  protected:
  explicit JobMetadata(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .beegfs.RequestStatus status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::beegfs::RequestStatus& status() const;
  PROTOBUF_NODISCARD ::beegfs::RequestStatus* release_status();
  ::beegfs::RequestStatus* mutable_status();
  void set_allocated_status(::beegfs::RequestStatus* value);
  void unsafe_arena_set_allocated_status(::beegfs::RequestStatus* value);
  ::beegfs::RequestStatus* unsafe_arena_release_status();

  private:
  const ::beegfs::RequestStatus& _internal_status() const;
  ::beegfs::RequestStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:beegfs.JobMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 29, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::beegfs::RequestStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};// -------------------------------------------------------------------

class WorkResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:beegfs.WorkResponse) */ {
 public:
  inline WorkResponse() : WorkResponse(nullptr) {}
  ~WorkResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkResponse(::google::protobuf::internal::ConstantInitialized);

  WorkResponse(const WorkResponse& from);
  WorkResponse(WorkResponse&& from) noexcept
    : WorkResponse() {
    *this = ::std::move(from);
  }

  inline WorkResponse& operator=(const WorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkResponse& operator=(WorkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkResponse* internal_default_instance() {
    return reinterpret_cast<const WorkResponse*>(
               &_WorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WorkResponse& a, WorkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkResponse& from) {
    WorkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "beegfs.WorkResponse";
  }
  protected:
  explicit WorkResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string job_id = 1;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* ptr);

  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(
      const std::string& value);
  std::string* _internal_mutable_job_id();

  public:
  // string request_id = 2;
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* ptr);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // .beegfs.RequestStatus status = 3;
  bool has_status() const;
  void clear_status() ;
  const ::beegfs::RequestStatus& status() const;
  PROTOBUF_NODISCARD ::beegfs::RequestStatus* release_status();
  ::beegfs::RequestStatus* mutable_status();
  void set_allocated_status(::beegfs::RequestStatus* value);
  void unsafe_arena_set_allocated_status(::beegfs::RequestStatus* value);
  ::beegfs::RequestStatus* unsafe_arena_release_status();

  private:
  const ::beegfs::RequestStatus& _internal_status() const;
  ::beegfs::RequestStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:beegfs.WorkResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::beegfs::RequestStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UpdateWorkRequest

// string jobID = 1;
inline void UpdateWorkRequest::clear_jobid() {
  _impl_.jobid_.ClearToEmpty();
}
inline const std::string& UpdateWorkRequest::jobid() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequest.jobID)
  return _internal_jobid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateWorkRequest::set_jobid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.jobid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequest.jobID)
}
inline std::string* UpdateWorkRequest::mutable_jobid() {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:beegfs.UpdateWorkRequest.jobID)
  return _s;
}
inline const std::string& UpdateWorkRequest::_internal_jobid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Get();
}
inline void UpdateWorkRequest::_internal_set_jobid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.jobid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateWorkRequest::_internal_mutable_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.jobid_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateWorkRequest::release_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.UpdateWorkRequest.jobID)
  return _impl_.jobid_.Release();
}
inline void UpdateWorkRequest::set_allocated_jobid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jobid_.IsDefault()) {
          _impl_.jobid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.UpdateWorkRequest.jobID)
}

// string requestID = 2;
inline void UpdateWorkRequest::clear_requestid() {
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& UpdateWorkRequest::requestid() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequest.requestID)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateWorkRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequest.requestID)
}
inline std::string* UpdateWorkRequest::mutable_requestid() {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:beegfs.UpdateWorkRequest.requestID)
  return _s;
}
inline const std::string& UpdateWorkRequest::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void UpdateWorkRequest::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateWorkRequest::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateWorkRequest::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.UpdateWorkRequest.requestID)
  return _impl_.requestid_.Release();
}
inline void UpdateWorkRequest::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.UpdateWorkRequest.requestID)
}

// .beegfs.NewState newState = 3;
inline void UpdateWorkRequest::clear_newstate() {
  _impl_.newstate_ = 0;
}
inline ::beegfs::NewState UpdateWorkRequest::newstate() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequest.newState)
  return _internal_newstate();
}
inline void UpdateWorkRequest::set_newstate(::beegfs::NewState value) {
  _internal_set_newstate(value);
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequest.newState)
}
inline ::beegfs::NewState UpdateWorkRequest::_internal_newstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::NewState>(_impl_.newstate_);
}
inline void UpdateWorkRequest::_internal_set_newstate(::beegfs::NewState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.newstate_ = value;
}

// -------------------------------------------------------------------

// UpdateWorkRequests_job

// string path = 1;
inline void UpdateWorkRequests_job::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& UpdateWorkRequests_job::path() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequests.job.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateWorkRequests_job::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequests.job.path)
}
inline std::string* UpdateWorkRequests_job::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:beegfs.UpdateWorkRequests.job.path)
  return _s;
}
inline const std::string& UpdateWorkRequests_job::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void UpdateWorkRequests_job::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateWorkRequests_job::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateWorkRequests_job::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.UpdateWorkRequests.job.path)
  return _impl_.path_.Release();
}
inline void UpdateWorkRequests_job::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.UpdateWorkRequests.job.path)
}

// string id = 2;
inline void UpdateWorkRequests_job::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateWorkRequests_job::id() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequests.job.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateWorkRequests_job::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequests.job.id)
}
inline std::string* UpdateWorkRequests_job::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:beegfs.UpdateWorkRequests.job.id)
  return _s;
}
inline const std::string& UpdateWorkRequests_job::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void UpdateWorkRequests_job::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateWorkRequests_job::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateWorkRequests_job::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.UpdateWorkRequests.job.id)
  return _impl_.id_.Release();
}
inline void UpdateWorkRequests_job::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.UpdateWorkRequests.job.id)
}

// .beegfs.UpdateWorkRequests.State state = 3;
inline void UpdateWorkRequests_job::clear_state() {
  _impl_.state_ = 0;
}
inline ::beegfs::UpdateWorkRequests_State UpdateWorkRequests_job::state() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequests.job.state)
  return _internal_state();
}
inline void UpdateWorkRequests_job::set_state(::beegfs::UpdateWorkRequests_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequests.job.state)
}
inline ::beegfs::UpdateWorkRequests_State UpdateWorkRequests_job::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::UpdateWorkRequests_State>(_impl_.state_);
}
inline void UpdateWorkRequests_job::_internal_set_state(::beegfs::UpdateWorkRequests_State value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// UpdateWorkRequests

// repeated .beegfs.UpdateWorkRequests.job jobs = 1;
inline int UpdateWorkRequests::_internal_jobs_size() const {
  return _internal_jobs().size();
}
inline int UpdateWorkRequests::jobs_size() const {
  return _internal_jobs_size();
}
inline void UpdateWorkRequests::clear_jobs() {
  _internal_mutable_jobs()->Clear();
}
inline ::beegfs::UpdateWorkRequests_job* UpdateWorkRequests::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:beegfs.UpdateWorkRequests.jobs)
  return _internal_mutable_jobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::beegfs::UpdateWorkRequests_job >*
UpdateWorkRequests::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:beegfs.UpdateWorkRequests.jobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jobs();
}
inline const ::beegfs::UpdateWorkRequests_job& UpdateWorkRequests::jobs(int index) const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequests.jobs)
    return _internal_jobs().Get(index);
}
inline ::beegfs::UpdateWorkRequests_job* UpdateWorkRequests::add_jobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::UpdateWorkRequests_job* _add = _internal_mutable_jobs()->Add();
  // @@protoc_insertion_point(field_add:beegfs.UpdateWorkRequests.jobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::beegfs::UpdateWorkRequests_job >&
UpdateWorkRequests::jobs() const {
  // @@protoc_insertion_point(field_list:beegfs.UpdateWorkRequests.jobs)
  return _internal_jobs();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::UpdateWorkRequests_job>&
UpdateWorkRequests::_internal_jobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobs_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::UpdateWorkRequests_job>*
UpdateWorkRequests::_internal_mutable_jobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jobs_;
}

// .beegfs.UpdateWorkRequests.State defaultState = 2;
inline void UpdateWorkRequests::clear_defaultstate() {
  _impl_.defaultstate_ = 0;
}
inline ::beegfs::UpdateWorkRequests_State UpdateWorkRequests::defaultstate() const {
  // @@protoc_insertion_point(field_get:beegfs.UpdateWorkRequests.defaultState)
  return _internal_defaultstate();
}
inline void UpdateWorkRequests::set_defaultstate(::beegfs::UpdateWorkRequests_State value) {
  _internal_set_defaultstate(value);
  // @@protoc_insertion_point(field_set:beegfs.UpdateWorkRequests.defaultState)
}
inline ::beegfs::UpdateWorkRequests_State UpdateWorkRequests::_internal_defaultstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::UpdateWorkRequests_State>(_impl_.defaultstate_);
}
inline void UpdateWorkRequests::_internal_set_defaultstate(::beegfs::UpdateWorkRequests_State value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.defaultstate_ = value;
}

// -------------------------------------------------------------------

// RequestStatus

// .beegfs.RequestStatus.Status status = 1;
inline void RequestStatus::clear_status() {
  _impl_.status_ = 0;
}
inline ::beegfs::RequestStatus_Status RequestStatus::status() const {
  // @@protoc_insertion_point(field_get:beegfs.RequestStatus.status)
  return _internal_status();
}
inline void RequestStatus::set_status(::beegfs::RequestStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:beegfs.RequestStatus.status)
}
inline ::beegfs::RequestStatus_Status RequestStatus::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::RequestStatus_Status>(_impl_.status_);
}
inline void RequestStatus::_internal_set_status(::beegfs::RequestStatus_Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// string message = 2;
inline void RequestStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RequestStatus::message() const {
  // @@protoc_insertion_point(field_get:beegfs.RequestStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestStatus::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.RequestStatus.message)
}
inline std::string* RequestStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:beegfs.RequestStatus.message)
  return _s;
}
inline const std::string& RequestStatus::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void RequestStatus::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestStatus::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestStatus::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.RequestStatus.message)
  return _impl_.message_.Release();
}
inline void RequestStatus::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.RequestStatus.message)
}

// -------------------------------------------------------------------

// JobMetadata

// string id = 1;
inline void JobMetadata::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& JobMetadata::id() const {
  // @@protoc_insertion_point(field_get:beegfs.JobMetadata.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JobMetadata::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.JobMetadata.id)
}
inline std::string* JobMetadata::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:beegfs.JobMetadata.id)
  return _s;
}
inline const std::string& JobMetadata::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void JobMetadata::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobMetadata::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* JobMetadata::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.JobMetadata.id)
  return _impl_.id_.Release();
}
inline void JobMetadata::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.JobMetadata.id)
}

// .beegfs.RequestStatus status = 2;
inline bool JobMetadata::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void JobMetadata::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::RequestStatus& JobMetadata::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::RequestStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::RequestStatus&>(::beegfs::_RequestStatus_default_instance_);
}
inline const ::beegfs::RequestStatus& JobMetadata::status() const {
  // @@protoc_insertion_point(field_get:beegfs.JobMetadata.status)
  return _internal_status();
}
inline void JobMetadata::unsafe_arena_set_allocated_status(::beegfs::RequestStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::beegfs::RequestStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.JobMetadata.status)
}
inline ::beegfs::RequestStatus* JobMetadata::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::RequestStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::RequestStatus* JobMetadata::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.JobMetadata.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::RequestStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::beegfs::RequestStatus* JobMetadata::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::beegfs::RequestStatus>(GetArenaForAllocation());
    _impl_.status_ = reinterpret_cast<::beegfs::RequestStatus*>(p);
  }
  return _impl_.status_;
}
inline ::beegfs::RequestStatus* JobMetadata::mutable_status() {
  ::beegfs::RequestStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:beegfs.JobMetadata.status)
  return _msg;
}
inline void JobMetadata::set_allocated_status(::beegfs::RequestStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::beegfs::RequestStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::beegfs::RequestStatus*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::beegfs::RequestStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.JobMetadata.status)
}

// -------------------------------------------------------------------

// WorkResponse

// string job_id = 1;
inline void WorkResponse::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& WorkResponse::job_id() const {
  // @@protoc_insertion_point(field_get:beegfs.WorkResponse.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkResponse::set_job_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.WorkResponse.job_id)
}
inline std::string* WorkResponse::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:beegfs.WorkResponse.job_id)
  return _s;
}
inline const std::string& WorkResponse::_internal_job_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.job_id_.Get();
}
inline void WorkResponse::_internal_set_job_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkResponse::_internal_mutable_job_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.job_id_.Mutable( GetArenaForAllocation());
}
inline std::string* WorkResponse::release_job_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.WorkResponse.job_id)
  return _impl_.job_id_.Release();
}
inline void WorkResponse::set_allocated_job_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.job_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.job_id_.IsDefault()) {
          _impl_.job_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.WorkResponse.job_id)
}

// string request_id = 2;
inline void WorkResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& WorkResponse::request_id() const {
  // @@protoc_insertion_point(field_get:beegfs.WorkResponse.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkResponse::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beegfs.WorkResponse.request_id)
}
inline std::string* WorkResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:beegfs.WorkResponse.request_id)
  return _s;
}
inline const std::string& WorkResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_.Get();
}
inline void WorkResponse::_internal_set_request_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkResponse::_internal_mutable_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.request_id_.Mutable( GetArenaForAllocation());
}
inline std::string* WorkResponse::release_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.WorkResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void WorkResponse::set_allocated_request_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_id_.IsDefault()) {
          _impl_.request_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.WorkResponse.request_id)
}

// .beegfs.RequestStatus status = 3;
inline bool WorkResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void WorkResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::RequestStatus& WorkResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::RequestStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::RequestStatus&>(::beegfs::_RequestStatus_default_instance_);
}
inline const ::beegfs::RequestStatus& WorkResponse::status() const {
  // @@protoc_insertion_point(field_get:beegfs.WorkResponse.status)
  return _internal_status();
}
inline void WorkResponse::unsafe_arena_set_allocated_status(::beegfs::RequestStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::beegfs::RequestStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.WorkResponse.status)
}
inline ::beegfs::RequestStatus* WorkResponse::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::RequestStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::RequestStatus* WorkResponse::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.WorkResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::RequestStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::beegfs::RequestStatus* WorkResponse::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::beegfs::RequestStatus>(GetArenaForAllocation());
    _impl_.status_ = reinterpret_cast<::beegfs::RequestStatus*>(p);
  }
  return _impl_.status_;
}
inline ::beegfs::RequestStatus* WorkResponse::mutable_status() {
  ::beegfs::RequestStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:beegfs.WorkResponse.status)
  return _msg;
}
inline void WorkResponse::set_allocated_status(::beegfs::RequestStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::beegfs::RequestStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::beegfs::RequestStatus*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::beegfs::RequestStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.WorkResponse.status)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace beegfs


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::beegfs::UpdateWorkRequests_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::UpdateWorkRequests_State>() {
  return ::beegfs::UpdateWorkRequests_State_descriptor();
}
template <>
struct is_proto_enum<::beegfs::RequestStatus_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::RequestStatus_Status>() {
  return ::beegfs::RequestStatus_Status_descriptor();
}
template <>
struct is_proto_enum<::beegfs::NewState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::NewState>() {
  return ::beegfs::NewState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto_2epb_2eh
