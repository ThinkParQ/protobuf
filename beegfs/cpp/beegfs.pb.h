// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: beegfs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_beegfs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_beegfs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_beegfs_2eproto;
namespace beegfs {
class Entry;
class EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class JobMetadata;
class JobMetadataDefaultTypeInternal;
extern JobMetadataDefaultTypeInternal _JobMetadata_default_instance_;
class RemoteStorageTarget;
class RemoteStorageTargetDefaultTypeInternal;
extern RemoteStorageTargetDefaultTypeInternal _RemoteStorageTarget_default_instance_;
class RemoteStorageTarget_Azure;
class RemoteStorageTarget_AzureDefaultTypeInternal;
extern RemoteStorageTarget_AzureDefaultTypeInternal _RemoteStorageTarget_Azure_default_instance_;
class RemoteStorageTarget_POSIX;
class RemoteStorageTarget_POSIXDefaultTypeInternal;
extern RemoteStorageTarget_POSIXDefaultTypeInternal _RemoteStorageTarget_POSIX_default_instance_;
class RemoteStorageTarget_Policies;
class RemoteStorageTarget_PoliciesDefaultTypeInternal;
extern RemoteStorageTarget_PoliciesDefaultTypeInternal _RemoteStorageTarget_Policies_default_instance_;
class RemoteStorageTarget_S3;
class RemoteStorageTarget_S3DefaultTypeInternal;
extern RemoteStorageTarget_S3DefaultTypeInternal _RemoteStorageTarget_S3_default_instance_;
class RequestStatus;
class RequestStatusDefaultTypeInternal;
extern RequestStatusDefaultTypeInternal _RequestStatus_default_instance_;
class WorkResponse;
class WorkResponseDefaultTypeInternal;
extern WorkResponseDefaultTypeInternal _WorkResponse_default_instance_;
}  // namespace beegfs
PROTOBUF_NAMESPACE_OPEN
template<> ::beegfs::Entry* Arena::CreateMaybeMessage<::beegfs::Entry>(Arena*);
template<> ::beegfs::JobMetadata* Arena::CreateMaybeMessage<::beegfs::JobMetadata>(Arena*);
template<> ::beegfs::RemoteStorageTarget* Arena::CreateMaybeMessage<::beegfs::RemoteStorageTarget>(Arena*);
template<> ::beegfs::RemoteStorageTarget_Azure* Arena::CreateMaybeMessage<::beegfs::RemoteStorageTarget_Azure>(Arena*);
template<> ::beegfs::RemoteStorageTarget_POSIX* Arena::CreateMaybeMessage<::beegfs::RemoteStorageTarget_POSIX>(Arena*);
template<> ::beegfs::RemoteStorageTarget_Policies* Arena::CreateMaybeMessage<::beegfs::RemoteStorageTarget_Policies>(Arena*);
template<> ::beegfs::RemoteStorageTarget_S3* Arena::CreateMaybeMessage<::beegfs::RemoteStorageTarget_S3>(Arena*);
template<> ::beegfs::RequestStatus* Arena::CreateMaybeMessage<::beegfs::RequestStatus>(Arena*);
template<> ::beegfs::WorkResponse* Arena::CreateMaybeMessage<::beegfs::WorkResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace beegfs {

enum RequestStatus_Status : int {
  RequestStatus_Status_UNKNOWN = 0,
  RequestStatus_Status_UNASSIGNED = 1,
  RequestStatus_Status_ASSIGNED = 2,
  RequestStatus_Status_CREATED = 3,
  RequestStatus_Status_RESCHEDULED = 4,
  RequestStatus_Status_SCHEDULED = 5,
  RequestStatus_Status_RUNNING = 6,
  RequestStatus_Status_STALLED = 7,
  RequestStatus_Status_PAUSED = 8,
  RequestStatus_Status_FAILED = 9,
  RequestStatus_Status_COMPLETED = 10,
  RequestStatus_Status_CANCELLED = 11,
  RequestStatus_Status_RequestStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestStatus_Status_RequestStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestStatus_Status_IsValid(int value);
constexpr RequestStatus_Status RequestStatus_Status_Status_MIN = RequestStatus_Status_UNKNOWN;
constexpr RequestStatus_Status RequestStatus_Status_Status_MAX = RequestStatus_Status_CANCELLED;
constexpr int RequestStatus_Status_Status_ARRAYSIZE = RequestStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestStatus_Status_descriptor();
template<typename T>
inline const std::string& RequestStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestStatus_Status_descriptor(), enum_t_value);
}
inline bool RequestStatus_Status_Parse(
    const std::string& name, RequestStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestStatus_Status>(
    RequestStatus_Status_descriptor(), name, value);
}
// ===================================================================

class Entry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.Entry) */ {
 public:
  inline Entry() : Entry(nullptr) {};
  virtual ~Entry();

  Entry(const Entry& from);
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entry& operator=(Entry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Entry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Entry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Entry* New() const final {
    return CreateMaybeMessage<Entry>(nullptr);
  }

  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.Entry";
  }
  protected:
  explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kRemoteStorageTargetFieldNumber = 3,
    kFileSizeFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string remote_storage_target = 3;
  void clear_remote_storage_target();
  const std::string& remote_storage_target() const;
  void set_remote_storage_target(const std::string& value);
  void set_remote_storage_target(std::string&& value);
  void set_remote_storage_target(const char* value);
  void set_remote_storage_target(const char* value, size_t size);
  std::string* mutable_remote_storage_target();
  std::string* release_remote_storage_target();
  void set_allocated_remote_storage_target(std::string* remote_storage_target);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_remote_storage_target();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_remote_storage_target(
      std::string* remote_storage_target);
  private:
  const std::string& _internal_remote_storage_target() const;
  void _internal_set_remote_storage_target(const std::string& value);
  std::string* _internal_mutable_remote_storage_target();
  public:

  // uint64 file_size = 4;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:beegfs.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_storage_target_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class RequestStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.RequestStatus) */ {
 public:
  inline RequestStatus() : RequestStatus(nullptr) {};
  virtual ~RequestStatus();

  RequestStatus(const RequestStatus& from);
  RequestStatus(RequestStatus&& from) noexcept
    : RequestStatus() {
    *this = ::std::move(from);
  }

  inline RequestStatus& operator=(const RequestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestStatus& operator=(RequestStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStatus* internal_default_instance() {
    return reinterpret_cast<const RequestStatus*>(
               &_RequestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestStatus& a, RequestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestStatus* New() const final {
    return CreateMaybeMessage<RequestStatus>(nullptr);
  }

  RequestStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestStatus& from);
  void MergeFrom(const RequestStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.RequestStatus";
  }
  protected:
  explicit RequestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RequestStatus_Status Status;
  static constexpr Status UNKNOWN =
    RequestStatus_Status_UNKNOWN;
  static constexpr Status UNASSIGNED =
    RequestStatus_Status_UNASSIGNED;
  static constexpr Status ASSIGNED =
    RequestStatus_Status_ASSIGNED;
  static constexpr Status CREATED =
    RequestStatus_Status_CREATED;
  static constexpr Status RESCHEDULED =
    RequestStatus_Status_RESCHEDULED;
  static constexpr Status SCHEDULED =
    RequestStatus_Status_SCHEDULED;
  static constexpr Status RUNNING =
    RequestStatus_Status_RUNNING;
  static constexpr Status STALLED =
    RequestStatus_Status_STALLED;
  static constexpr Status PAUSED =
    RequestStatus_Status_PAUSED;
  static constexpr Status FAILED =
    RequestStatus_Status_FAILED;
  static constexpr Status COMPLETED =
    RequestStatus_Status_COMPLETED;
  static constexpr Status CANCELLED =
    RequestStatus_Status_CANCELLED;
  static inline bool Status_IsValid(int value) {
    return RequestStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RequestStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RequestStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RequestStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RequestStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RequestStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return RequestStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .beegfs.RequestStatus.Status status = 1;
  void clear_status();
  ::beegfs::RequestStatus_Status status() const;
  void set_status(::beegfs::RequestStatus_Status value);
  private:
  ::beegfs::RequestStatus_Status _internal_status() const;
  void _internal_set_status(::beegfs::RequestStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:beegfs.RequestStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class JobMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.JobMetadata) */ {
 public:
  inline JobMetadata() : JobMetadata(nullptr) {};
  virtual ~JobMetadata();

  JobMetadata(const JobMetadata& from);
  JobMetadata(JobMetadata&& from) noexcept
    : JobMetadata() {
    *this = ::std::move(from);
  }

  inline JobMetadata& operator=(const JobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobMetadata& operator=(JobMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JobMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobMetadata* internal_default_instance() {
    return reinterpret_cast<const JobMetadata*>(
               &_JobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(JobMetadata& a, JobMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(JobMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JobMetadata* New() const final {
    return CreateMaybeMessage<JobMetadata>(nullptr);
  }

  JobMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JobMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JobMetadata& from);
  void MergeFrom(const JobMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.JobMetadata";
  }
  protected:
  explicit JobMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .beegfs.RequestStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::beegfs::RequestStatus& status() const;
  ::beegfs::RequestStatus* release_status();
  ::beegfs::RequestStatus* mutable_status();
  void set_allocated_status(::beegfs::RequestStatus* status);
  private:
  const ::beegfs::RequestStatus& _internal_status() const;
  ::beegfs::RequestStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::beegfs::RequestStatus* status);
  ::beegfs::RequestStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:beegfs.JobMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::beegfs::RequestStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class WorkResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.WorkResponse) */ {
 public:
  inline WorkResponse() : WorkResponse(nullptr) {};
  virtual ~WorkResponse();

  WorkResponse(const WorkResponse& from);
  WorkResponse(WorkResponse&& from) noexcept
    : WorkResponse() {
    *this = ::std::move(from);
  }

  inline WorkResponse& operator=(const WorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkResponse& operator=(WorkResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkResponse* internal_default_instance() {
    return reinterpret_cast<const WorkResponse*>(
               &_WorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WorkResponse& a, WorkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkResponse* New() const final {
    return CreateMaybeMessage<WorkResponse>(nullptr);
  }

  WorkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkResponse& from);
  void MergeFrom(const WorkResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.WorkResponse";
  }
  protected:
  explicit WorkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .beegfs.RequestStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::beegfs::RequestStatus& status() const;
  ::beegfs::RequestStatus* release_status();
  ::beegfs::RequestStatus* mutable_status();
  void set_allocated_status(::beegfs::RequestStatus* status);
  private:
  const ::beegfs::RequestStatus& _internal_status() const;
  ::beegfs::RequestStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::beegfs::RequestStatus* status);
  ::beegfs::RequestStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:beegfs.WorkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::beegfs::RequestStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_Policies PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.RemoteStorageTarget.Policies) */ {
 public:
  inline RemoteStorageTarget_Policies() : RemoteStorageTarget_Policies(nullptr) {};
  virtual ~RemoteStorageTarget_Policies();

  RemoteStorageTarget_Policies(const RemoteStorageTarget_Policies& from);
  RemoteStorageTarget_Policies(RemoteStorageTarget_Policies&& from) noexcept
    : RemoteStorageTarget_Policies() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_Policies& operator=(const RemoteStorageTarget_Policies& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_Policies& operator=(RemoteStorageTarget_Policies&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_Policies& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_Policies* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_Policies*>(
               &_RemoteStorageTarget_Policies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RemoteStorageTarget_Policies& a, RemoteStorageTarget_Policies& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_Policies* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_Policies* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_Policies* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_Policies>(nullptr);
  }

  RemoteStorageTarget_Policies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_Policies>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_Policies& from);
  void MergeFrom(const RemoteStorageTarget_Policies& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_Policies* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.RemoteStorageTarget.Policies";
  }
  protected:
  explicit RemoteStorageTarget_Policies(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalFlockFieldNumber = 1,
    kRemoteFlockFieldNumber = 2,
    kKeepDirStructureFieldNumber = 3,
    kKeepBeegfsMetadataFieldNumber = 4,
    kAutostartMaxSizeFieldNumber = 5,
  };
  // bool local_flock = 1;
  void clear_local_flock();
  bool local_flock() const;
  void set_local_flock(bool value);
  private:
  bool _internal_local_flock() const;
  void _internal_set_local_flock(bool value);
  public:

  // bool remote_flock = 2;
  void clear_remote_flock();
  bool remote_flock() const;
  void set_remote_flock(bool value);
  private:
  bool _internal_remote_flock() const;
  void _internal_set_remote_flock(bool value);
  public:

  // bool keep_dir_structure = 3;
  void clear_keep_dir_structure();
  bool keep_dir_structure() const;
  void set_keep_dir_structure(bool value);
  private:
  bool _internal_keep_dir_structure() const;
  void _internal_set_keep_dir_structure(bool value);
  public:

  // bool keep_beegfs_metadata = 4;
  void clear_keep_beegfs_metadata();
  bool keep_beegfs_metadata() const;
  void set_keep_beegfs_metadata(bool value);
  private:
  bool _internal_keep_beegfs_metadata() const;
  void _internal_set_keep_beegfs_metadata(bool value);
  public:

  // uint32 autostart_max_size = 5;
  void clear_autostart_max_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 autostart_max_size() const;
  void set_autostart_max_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_autostart_max_size() const;
  void _internal_set_autostart_max_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:beegfs.RemoteStorageTarget.Policies)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool local_flock_;
  bool remote_flock_;
  bool keep_dir_structure_;
  bool keep_beegfs_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 autostart_max_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_S3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.RemoteStorageTarget.S3) */ {
 public:
  inline RemoteStorageTarget_S3() : RemoteStorageTarget_S3(nullptr) {};
  virtual ~RemoteStorageTarget_S3();

  RemoteStorageTarget_S3(const RemoteStorageTarget_S3& from);
  RemoteStorageTarget_S3(RemoteStorageTarget_S3&& from) noexcept
    : RemoteStorageTarget_S3() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_S3& operator=(const RemoteStorageTarget_S3& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_S3& operator=(RemoteStorageTarget_S3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_S3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_S3* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_S3*>(
               &_RemoteStorageTarget_S3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RemoteStorageTarget_S3& a, RemoteStorageTarget_S3& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_S3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_S3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_S3* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_S3>(nullptr);
  }

  RemoteStorageTarget_S3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_S3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_S3& from);
  void MergeFrom(const RemoteStorageTarget_S3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_S3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.RemoteStorageTarget.S3";
  }
  protected:
  explicit RemoteStorageTarget_S3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 1,
    kRegionFieldNumber = 2,
    kEndpointFieldNumber = 3,
    kAccessKeyFieldNumber = 4,
    kSecretKeyFieldNumber = 5,
  };
  // string bucket = 1;
  void clear_bucket();
  const std::string& bucket() const;
  void set_bucket(const std::string& value);
  void set_bucket(std::string&& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  std::string* mutable_bucket();
  std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_bucket();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_bucket(
      std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // string region = 2;
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_region();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_region(
      std::string* region);
  private:
  const std::string& _internal_region() const;
  void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string endpoint = 3;
  void clear_endpoint();
  const std::string& endpoint() const;
  void set_endpoint(const std::string& value);
  void set_endpoint(std::string&& value);
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  std::string* mutable_endpoint();
  std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_endpoint();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_endpoint(
      std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // string access_key = 4;
  void clear_access_key();
  const std::string& access_key() const;
  void set_access_key(const std::string& value);
  void set_access_key(std::string&& value);
  void set_access_key(const char* value);
  void set_access_key(const char* value, size_t size);
  std::string* mutable_access_key();
  std::string* release_access_key();
  void set_allocated_access_key(std::string* access_key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_access_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_access_key(
      std::string* access_key);
  private:
  const std::string& _internal_access_key() const;
  void _internal_set_access_key(const std::string& value);
  std::string* _internal_mutable_access_key();
  public:

  // string secret_key = 5;
  void clear_secret_key();
  const std::string& secret_key() const;
  void set_secret_key(const std::string& value);
  void set_secret_key(std::string&& value);
  void set_secret_key(const char* value);
  void set_secret_key(const char* value, size_t size);
  std::string* mutable_secret_key();
  std::string* release_secret_key();
  void set_allocated_secret_key(std::string* secret_key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_secret_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_secret_key(
      std::string* secret_key);
  private:
  const std::string& _internal_secret_key() const;
  void _internal_set_secret_key(const std::string& value);
  std::string* _internal_mutable_secret_key();
  public:

  // @@protoc_insertion_point(class_scope:beegfs.RemoteStorageTarget.S3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_Azure PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.RemoteStorageTarget.Azure) */ {
 public:
  inline RemoteStorageTarget_Azure() : RemoteStorageTarget_Azure(nullptr) {};
  virtual ~RemoteStorageTarget_Azure();

  RemoteStorageTarget_Azure(const RemoteStorageTarget_Azure& from);
  RemoteStorageTarget_Azure(RemoteStorageTarget_Azure&& from) noexcept
    : RemoteStorageTarget_Azure() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_Azure& operator=(const RemoteStorageTarget_Azure& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_Azure& operator=(RemoteStorageTarget_Azure&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_Azure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_Azure* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_Azure*>(
               &_RemoteStorageTarget_Azure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RemoteStorageTarget_Azure& a, RemoteStorageTarget_Azure& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_Azure* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_Azure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_Azure* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_Azure>(nullptr);
  }

  RemoteStorageTarget_Azure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_Azure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_Azure& from);
  void MergeFrom(const RemoteStorageTarget_Azure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_Azure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.RemoteStorageTarget.Azure";
  }
  protected:
  explicit RemoteStorageTarget_Azure(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kS3FieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_account();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_account(
      std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // .beegfs.RemoteStorageTarget.S3 s3 = 1;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::beegfs::RemoteStorageTarget_S3& s3() const;
  ::beegfs::RemoteStorageTarget_S3* release_s3();
  ::beegfs::RemoteStorageTarget_S3* mutable_s3();
  void set_allocated_s3(::beegfs::RemoteStorageTarget_S3* s3);
  private:
  const ::beegfs::RemoteStorageTarget_S3& _internal_s3() const;
  ::beegfs::RemoteStorageTarget_S3* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::beegfs::RemoteStorageTarget_S3* s3);
  ::beegfs::RemoteStorageTarget_S3* unsafe_arena_release_s3();

  // @@protoc_insertion_point(class_scope:beegfs.RemoteStorageTarget.Azure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::beegfs::RemoteStorageTarget_S3* s3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_POSIX PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.RemoteStorageTarget.POSIX) */ {
 public:
  inline RemoteStorageTarget_POSIX() : RemoteStorageTarget_POSIX(nullptr) {};
  virtual ~RemoteStorageTarget_POSIX();

  RemoteStorageTarget_POSIX(const RemoteStorageTarget_POSIX& from);
  RemoteStorageTarget_POSIX(RemoteStorageTarget_POSIX&& from) noexcept
    : RemoteStorageTarget_POSIX() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_POSIX& operator=(const RemoteStorageTarget_POSIX& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_POSIX& operator=(RemoteStorageTarget_POSIX&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_POSIX& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_POSIX* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_POSIX*>(
               &_RemoteStorageTarget_POSIX_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RemoteStorageTarget_POSIX& a, RemoteStorageTarget_POSIX& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_POSIX* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_POSIX* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_POSIX* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_POSIX>(nullptr);
  }

  RemoteStorageTarget_POSIX* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_POSIX>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_POSIX& from);
  void MergeFrom(const RemoteStorageTarget_POSIX& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_POSIX* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.RemoteStorageTarget.POSIX";
  }
  protected:
  explicit RemoteStorageTarget_POSIX(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:beegfs.RemoteStorageTarget.POSIX)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beegfs.RemoteStorageTarget) */ {
 public:
  inline RemoteStorageTarget() : RemoteStorageTarget(nullptr) {};
  virtual ~RemoteStorageTarget();

  RemoteStorageTarget(const RemoteStorageTarget& from);
  RemoteStorageTarget(RemoteStorageTarget&& from) noexcept
    : RemoteStorageTarget() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget& operator=(const RemoteStorageTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget& operator=(RemoteStorageTarget&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget& default_instance();

  enum TypeCase {
    kS3 = 4,
    kPosix = 5,
    kAzure = 6,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget*>(
               &_RemoteStorageTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RemoteStorageTarget& a, RemoteStorageTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget>(nullptr);
  }

  RemoteStorageTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget& from);
  void MergeFrom(const RemoteStorageTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beegfs.RemoteStorageTarget";
  }
  protected:
  explicit RemoteStorageTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_beegfs_2eproto);
    return ::descriptor_table_beegfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RemoteStorageTarget_Policies Policies;
  typedef RemoteStorageTarget_S3 S3;
  typedef RemoteStorageTarget_Azure Azure;
  typedef RemoteStorageTarget_POSIX POSIX;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPoliciesFieldNumber = 3,
    kS3FieldNumber = 4,
    kPosixFieldNumber = 5,
    kAzureFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .beegfs.RemoteStorageTarget.Policies policies = 3;
  bool has_policies() const;
  private:
  bool _internal_has_policies() const;
  public:
  void clear_policies();
  const ::beegfs::RemoteStorageTarget_Policies& policies() const;
  ::beegfs::RemoteStorageTarget_Policies* release_policies();
  ::beegfs::RemoteStorageTarget_Policies* mutable_policies();
  void set_allocated_policies(::beegfs::RemoteStorageTarget_Policies* policies);
  private:
  const ::beegfs::RemoteStorageTarget_Policies& _internal_policies() const;
  ::beegfs::RemoteStorageTarget_Policies* _internal_mutable_policies();
  public:
  void unsafe_arena_set_allocated_policies(
      ::beegfs::RemoteStorageTarget_Policies* policies);
  ::beegfs::RemoteStorageTarget_Policies* unsafe_arena_release_policies();

  // .beegfs.RemoteStorageTarget.S3 s3 = 4;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::beegfs::RemoteStorageTarget_S3& s3() const;
  ::beegfs::RemoteStorageTarget_S3* release_s3();
  ::beegfs::RemoteStorageTarget_S3* mutable_s3();
  void set_allocated_s3(::beegfs::RemoteStorageTarget_S3* s3);
  private:
  const ::beegfs::RemoteStorageTarget_S3& _internal_s3() const;
  ::beegfs::RemoteStorageTarget_S3* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::beegfs::RemoteStorageTarget_S3* s3);
  ::beegfs::RemoteStorageTarget_S3* unsafe_arena_release_s3();

  // .beegfs.RemoteStorageTarget.POSIX posix = 5;
  bool has_posix() const;
  private:
  bool _internal_has_posix() const;
  public:
  void clear_posix();
  const ::beegfs::RemoteStorageTarget_POSIX& posix() const;
  ::beegfs::RemoteStorageTarget_POSIX* release_posix();
  ::beegfs::RemoteStorageTarget_POSIX* mutable_posix();
  void set_allocated_posix(::beegfs::RemoteStorageTarget_POSIX* posix);
  private:
  const ::beegfs::RemoteStorageTarget_POSIX& _internal_posix() const;
  ::beegfs::RemoteStorageTarget_POSIX* _internal_mutable_posix();
  public:
  void unsafe_arena_set_allocated_posix(
      ::beegfs::RemoteStorageTarget_POSIX* posix);
  ::beegfs::RemoteStorageTarget_POSIX* unsafe_arena_release_posix();

  // .beegfs.RemoteStorageTarget.Azure azure = 6;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::beegfs::RemoteStorageTarget_Azure& azure() const;
  ::beegfs::RemoteStorageTarget_Azure* release_azure();
  ::beegfs::RemoteStorageTarget_Azure* mutable_azure();
  void set_allocated_azure(::beegfs::RemoteStorageTarget_Azure* azure);
  private:
  const ::beegfs::RemoteStorageTarget_Azure& _internal_azure() const;
  ::beegfs::RemoteStorageTarget_Azure* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::beegfs::RemoteStorageTarget_Azure* azure);
  ::beegfs::RemoteStorageTarget_Azure* unsafe_arena_release_azure();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:beegfs.RemoteStorageTarget)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_posix();
  void set_has_azure();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::beegfs::RemoteStorageTarget_Policies* policies_;
  union TypeUnion {
    TypeUnion() {}
    ::beegfs::RemoteStorageTarget_S3* s3_;
    ::beegfs::RemoteStorageTarget_POSIX* posix_;
    ::beegfs::RemoteStorageTarget_Azure* azure_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_beegfs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Entry

// string id = 1;
inline void Entry::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Entry::id() const {
  // @@protoc_insertion_point(field_get:beegfs.Entry.id)
  return _internal_id();
}
inline void Entry::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beegfs.Entry.id)
}
inline std::string* Entry::mutable_id() {
  // @@protoc_insertion_point(field_mutable:beegfs.Entry.id)
  return _internal_mutable_id();
}
inline const std::string& Entry::_internal_id() const {
  return id_.Get();
}
inline void Entry::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Entry::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.Entry.id)
}
inline void Entry::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.Entry.id)
}
inline void Entry::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.Entry.id)
}
inline std::string* Entry::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Entry::release_id() {
  // @@protoc_insertion_point(field_release:beegfs.Entry.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Entry::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.Entry.id)
}
inline std::string* Entry::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.Entry.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Entry::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.Entry.id)
}

// string path = 2;
inline void Entry::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Entry::path() const {
  // @@protoc_insertion_point(field_get:beegfs.Entry.path)
  return _internal_path();
}
inline void Entry::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:beegfs.Entry.path)
}
inline std::string* Entry::mutable_path() {
  // @@protoc_insertion_point(field_mutable:beegfs.Entry.path)
  return _internal_mutable_path();
}
inline const std::string& Entry::_internal_path() const {
  return path_.Get();
}
inline void Entry::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Entry::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.Entry.path)
}
inline void Entry::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.Entry.path)
}
inline void Entry::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.Entry.path)
}
inline std::string* Entry::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Entry::release_path() {
  // @@protoc_insertion_point(field_release:beegfs.Entry.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Entry::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.Entry.path)
}
inline std::string* Entry::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.Entry.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Entry::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.Entry.path)
}

// string remote_storage_target = 3;
inline void Entry::clear_remote_storage_target() {
  remote_storage_target_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Entry::remote_storage_target() const {
  // @@protoc_insertion_point(field_get:beegfs.Entry.remote_storage_target)
  return _internal_remote_storage_target();
}
inline void Entry::set_remote_storage_target(const std::string& value) {
  _internal_set_remote_storage_target(value);
  // @@protoc_insertion_point(field_set:beegfs.Entry.remote_storage_target)
}
inline std::string* Entry::mutable_remote_storage_target() {
  // @@protoc_insertion_point(field_mutable:beegfs.Entry.remote_storage_target)
  return _internal_mutable_remote_storage_target();
}
inline const std::string& Entry::_internal_remote_storage_target() const {
  return remote_storage_target_.Get();
}
inline void Entry::_internal_set_remote_storage_target(const std::string& value) {
  
  remote_storage_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Entry::set_remote_storage_target(std::string&& value) {
  
  remote_storage_target_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.Entry.remote_storage_target)
}
inline void Entry::set_remote_storage_target(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  remote_storage_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.Entry.remote_storage_target)
}
inline void Entry::set_remote_storage_target(const char* value,
    size_t size) {
  
  remote_storage_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.Entry.remote_storage_target)
}
inline std::string* Entry::_internal_mutable_remote_storage_target() {
  
  return remote_storage_target_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Entry::release_remote_storage_target() {
  // @@protoc_insertion_point(field_release:beegfs.Entry.remote_storage_target)
  return remote_storage_target_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Entry::set_allocated_remote_storage_target(std::string* remote_storage_target) {
  if (remote_storage_target != nullptr) {
    
  } else {
    
  }
  remote_storage_target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_storage_target,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.Entry.remote_storage_target)
}
inline std::string* Entry::unsafe_arena_release_remote_storage_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.Entry.remote_storage_target)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return remote_storage_target_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Entry::unsafe_arena_set_allocated_remote_storage_target(
    std::string* remote_storage_target) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (remote_storage_target != nullptr) {
    
  } else {
    
  }
  remote_storage_target_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      remote_storage_target, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.Entry.remote_storage_target)
}

// uint64 file_size = 4;
inline void Entry::clear_file_size() {
  file_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::file_size() const {
  // @@protoc_insertion_point(field_get:beegfs.Entry.file_size)
  return _internal_file_size();
}
inline void Entry::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_size_ = value;
}
inline void Entry::set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:beegfs.Entry.file_size)
}

// -------------------------------------------------------------------

// RequestStatus

// .beegfs.RequestStatus.Status status = 1;
inline void RequestStatus::clear_status() {
  status_ = 0;
}
inline ::beegfs::RequestStatus_Status RequestStatus::_internal_status() const {
  return static_cast< ::beegfs::RequestStatus_Status >(status_);
}
inline ::beegfs::RequestStatus_Status RequestStatus::status() const {
  // @@protoc_insertion_point(field_get:beegfs.RequestStatus.status)
  return _internal_status();
}
inline void RequestStatus::_internal_set_status(::beegfs::RequestStatus_Status value) {
  
  status_ = value;
}
inline void RequestStatus::set_status(::beegfs::RequestStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:beegfs.RequestStatus.status)
}

// string message = 2;
inline void RequestStatus::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RequestStatus::message() const {
  // @@protoc_insertion_point(field_get:beegfs.RequestStatus.message)
  return _internal_message();
}
inline void RequestStatus::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:beegfs.RequestStatus.message)
}
inline std::string* RequestStatus::mutable_message() {
  // @@protoc_insertion_point(field_mutable:beegfs.RequestStatus.message)
  return _internal_mutable_message();
}
inline const std::string& RequestStatus::_internal_message() const {
  return message_.Get();
}
inline void RequestStatus::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestStatus::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RequestStatus.message)
}
inline void RequestStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RequestStatus.message)
}
inline void RequestStatus::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RequestStatus.message)
}
inline std::string* RequestStatus::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestStatus::release_message() {
  // @@protoc_insertion_point(field_release:beegfs.RequestStatus.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RequestStatus.message)
}
inline std::string* RequestStatus::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RequestStatus.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestStatus::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RequestStatus.message)
}

// -------------------------------------------------------------------

// JobMetadata

// string id = 1;
inline void JobMetadata::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& JobMetadata::id() const {
  // @@protoc_insertion_point(field_get:beegfs.JobMetadata.id)
  return _internal_id();
}
inline void JobMetadata::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beegfs.JobMetadata.id)
}
inline std::string* JobMetadata::mutable_id() {
  // @@protoc_insertion_point(field_mutable:beegfs.JobMetadata.id)
  return _internal_mutable_id();
}
inline const std::string& JobMetadata::_internal_id() const {
  return id_.Get();
}
inline void JobMetadata::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JobMetadata::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.JobMetadata.id)
}
inline void JobMetadata::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.JobMetadata.id)
}
inline void JobMetadata::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.JobMetadata.id)
}
inline std::string* JobMetadata::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JobMetadata::release_id() {
  // @@protoc_insertion_point(field_release:beegfs.JobMetadata.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JobMetadata::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.JobMetadata.id)
}
inline std::string* JobMetadata::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.JobMetadata.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void JobMetadata::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.JobMetadata.id)
}

// .beegfs.RequestStatus status = 2;
inline bool JobMetadata::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool JobMetadata::has_status() const {
  return _internal_has_status();
}
inline void JobMetadata::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::beegfs::RequestStatus& JobMetadata::_internal_status() const {
  const ::beegfs::RequestStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::beegfs::RequestStatus*>(
      &::beegfs::_RequestStatus_default_instance_);
}
inline const ::beegfs::RequestStatus& JobMetadata::status() const {
  // @@protoc_insertion_point(field_get:beegfs.JobMetadata.status)
  return _internal_status();
}
inline void JobMetadata::unsafe_arena_set_allocated_status(
    ::beegfs::RequestStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.JobMetadata.status)
}
inline ::beegfs::RequestStatus* JobMetadata::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::beegfs::RequestStatus* JobMetadata::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:beegfs.JobMetadata.status)
  
  ::beegfs::RequestStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::beegfs::RequestStatus* JobMetadata::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::beegfs::RequestStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::beegfs::RequestStatus* JobMetadata::mutable_status() {
  // @@protoc_insertion_point(field_mutable:beegfs.JobMetadata.status)
  return _internal_mutable_status();
}
inline void JobMetadata::set_allocated_status(::beegfs::RequestStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:beegfs.JobMetadata.status)
}

// -------------------------------------------------------------------

// WorkResponse

// string id = 1;
inline void WorkResponse::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkResponse::id() const {
  // @@protoc_insertion_point(field_get:beegfs.WorkResponse.id)
  return _internal_id();
}
inline void WorkResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beegfs.WorkResponse.id)
}
inline std::string* WorkResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:beegfs.WorkResponse.id)
  return _internal_mutable_id();
}
inline const std::string& WorkResponse::_internal_id() const {
  return id_.Get();
}
inline void WorkResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkResponse::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.WorkResponse.id)
}
inline void WorkResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.WorkResponse.id)
}
inline void WorkResponse::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.WorkResponse.id)
}
inline std::string* WorkResponse::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkResponse::release_id() {
  // @@protoc_insertion_point(field_release:beegfs.WorkResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.WorkResponse.id)
}
inline std::string* WorkResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.WorkResponse.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkResponse::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.WorkResponse.id)
}

// .beegfs.RequestStatus status = 2;
inline bool WorkResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool WorkResponse::has_status() const {
  return _internal_has_status();
}
inline void WorkResponse::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::beegfs::RequestStatus& WorkResponse::_internal_status() const {
  const ::beegfs::RequestStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::beegfs::RequestStatus*>(
      &::beegfs::_RequestStatus_default_instance_);
}
inline const ::beegfs::RequestStatus& WorkResponse::status() const {
  // @@protoc_insertion_point(field_get:beegfs.WorkResponse.status)
  return _internal_status();
}
inline void WorkResponse::unsafe_arena_set_allocated_status(
    ::beegfs::RequestStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.WorkResponse.status)
}
inline ::beegfs::RequestStatus* WorkResponse::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::beegfs::RequestStatus* WorkResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:beegfs.WorkResponse.status)
  
  ::beegfs::RequestStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::beegfs::RequestStatus* WorkResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::beegfs::RequestStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::beegfs::RequestStatus* WorkResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:beegfs.WorkResponse.status)
  return _internal_mutable_status();
}
inline void WorkResponse::set_allocated_status(::beegfs::RequestStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:beegfs.WorkResponse.status)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_Policies

// bool local_flock = 1;
inline void RemoteStorageTarget_Policies::clear_local_flock() {
  local_flock_ = false;
}
inline bool RemoteStorageTarget_Policies::_internal_local_flock() const {
  return local_flock_;
}
inline bool RemoteStorageTarget_Policies::local_flock() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Policies.local_flock)
  return _internal_local_flock();
}
inline void RemoteStorageTarget_Policies::_internal_set_local_flock(bool value) {
  
  local_flock_ = value;
}
inline void RemoteStorageTarget_Policies::set_local_flock(bool value) {
  _internal_set_local_flock(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.Policies.local_flock)
}

// bool remote_flock = 2;
inline void RemoteStorageTarget_Policies::clear_remote_flock() {
  remote_flock_ = false;
}
inline bool RemoteStorageTarget_Policies::_internal_remote_flock() const {
  return remote_flock_;
}
inline bool RemoteStorageTarget_Policies::remote_flock() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Policies.remote_flock)
  return _internal_remote_flock();
}
inline void RemoteStorageTarget_Policies::_internal_set_remote_flock(bool value) {
  
  remote_flock_ = value;
}
inline void RemoteStorageTarget_Policies::set_remote_flock(bool value) {
  _internal_set_remote_flock(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.Policies.remote_flock)
}

// bool keep_dir_structure = 3;
inline void RemoteStorageTarget_Policies::clear_keep_dir_structure() {
  keep_dir_structure_ = false;
}
inline bool RemoteStorageTarget_Policies::_internal_keep_dir_structure() const {
  return keep_dir_structure_;
}
inline bool RemoteStorageTarget_Policies::keep_dir_structure() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Policies.keep_dir_structure)
  return _internal_keep_dir_structure();
}
inline void RemoteStorageTarget_Policies::_internal_set_keep_dir_structure(bool value) {
  
  keep_dir_structure_ = value;
}
inline void RemoteStorageTarget_Policies::set_keep_dir_structure(bool value) {
  _internal_set_keep_dir_structure(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.Policies.keep_dir_structure)
}

// bool keep_beegfs_metadata = 4;
inline void RemoteStorageTarget_Policies::clear_keep_beegfs_metadata() {
  keep_beegfs_metadata_ = false;
}
inline bool RemoteStorageTarget_Policies::_internal_keep_beegfs_metadata() const {
  return keep_beegfs_metadata_;
}
inline bool RemoteStorageTarget_Policies::keep_beegfs_metadata() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Policies.keep_beegfs_metadata)
  return _internal_keep_beegfs_metadata();
}
inline void RemoteStorageTarget_Policies::_internal_set_keep_beegfs_metadata(bool value) {
  
  keep_beegfs_metadata_ = value;
}
inline void RemoteStorageTarget_Policies::set_keep_beegfs_metadata(bool value) {
  _internal_set_keep_beegfs_metadata(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.Policies.keep_beegfs_metadata)
}

// uint32 autostart_max_size = 5;
inline void RemoteStorageTarget_Policies::clear_autostart_max_size() {
  autostart_max_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RemoteStorageTarget_Policies::_internal_autostart_max_size() const {
  return autostart_max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RemoteStorageTarget_Policies::autostart_max_size() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Policies.autostart_max_size)
  return _internal_autostart_max_size();
}
inline void RemoteStorageTarget_Policies::_internal_set_autostart_max_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  autostart_max_size_ = value;
}
inline void RemoteStorageTarget_Policies::set_autostart_max_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_autostart_max_size(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.Policies.autostart_max_size)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_S3

// string bucket = 1;
inline void RemoteStorageTarget_S3::clear_bucket() {
  bucket_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::bucket() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.S3.bucket)
  return _internal_bucket();
}
inline void RemoteStorageTarget_S3::set_bucket(const std::string& value) {
  _internal_set_bucket(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.S3.bucket)
  return _internal_mutable_bucket();
}
inline const std::string& RemoteStorageTarget_S3::_internal_bucket() const {
  return bucket_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_bucket(const std::string& value) {
  
  bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_bucket(std::string&& value) {
  
  bucket_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.S3.bucket)
}
inline void RemoteStorageTarget_S3::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.S3.bucket)
}
inline void RemoteStorageTarget_S3::set_bucket(const char* value,
    size_t size) {
  
  bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_bucket() {
  
  return bucket_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_bucket() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.S3.bucket)
  return bucket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bucket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_bucket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.S3.bucket)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return bucket_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_bucket(
    std::string* bucket) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      bucket, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.S3.bucket)
}

// string region = 2;
inline void RemoteStorageTarget_S3::clear_region() {
  region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::region() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.S3.region)
  return _internal_region();
}
inline void RemoteStorageTarget_S3::set_region(const std::string& value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::mutable_region() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.S3.region)
  return _internal_mutable_region();
}
inline const std::string& RemoteStorageTarget_S3::_internal_region() const {
  return region_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_region(const std::string& value) {
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_region(std::string&& value) {
  
  region_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.S3.region)
}
inline void RemoteStorageTarget_S3::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.S3.region)
}
inline void RemoteStorageTarget_S3::set_region(const char* value,
    size_t size) {
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_region() {
  
  return region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_region() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.S3.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.S3.region)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return region_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_region(
    std::string* region) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (region != nullptr) {
    
  } else {
    
  }
  region_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      region, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.S3.region)
}

// string endpoint = 3;
inline void RemoteStorageTarget_S3::clear_endpoint() {
  endpoint_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::endpoint() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.S3.endpoint)
  return _internal_endpoint();
}
inline void RemoteStorageTarget_S3::set_endpoint(const std::string& value) {
  _internal_set_endpoint(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.S3.endpoint)
}
inline std::string* RemoteStorageTarget_S3::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.S3.endpoint)
  return _internal_mutable_endpoint();
}
inline const std::string& RemoteStorageTarget_S3::_internal_endpoint() const {
  return endpoint_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_endpoint(const std::string& value) {
  
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_endpoint(std::string&& value) {
  
  endpoint_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.S3.endpoint)
}
inline void RemoteStorageTarget_S3::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.S3.endpoint)
}
inline void RemoteStorageTarget_S3::set_endpoint(const char* value,
    size_t size) {
  
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.S3.endpoint)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_endpoint() {
  
  return endpoint_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_endpoint() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.S3.endpoint)
  return endpoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.S3.endpoint)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.S3.endpoint)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return endpoint_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_endpoint(
    std::string* endpoint) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (endpoint != nullptr) {
    
  } else {
    
  }
  endpoint_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      endpoint, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.S3.endpoint)
}

// string access_key = 4;
inline void RemoteStorageTarget_S3::clear_access_key() {
  access_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::access_key() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.S3.access_key)
  return _internal_access_key();
}
inline void RemoteStorageTarget_S3::set_access_key(const std::string& value) {
  _internal_set_access_key(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::mutable_access_key() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.S3.access_key)
  return _internal_mutable_access_key();
}
inline const std::string& RemoteStorageTarget_S3::_internal_access_key() const {
  return access_key_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_access_key(const std::string& value) {
  
  access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_access_key(std::string&& value) {
  
  access_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.S3.access_key)
}
inline void RemoteStorageTarget_S3::set_access_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.S3.access_key)
}
inline void RemoteStorageTarget_S3::set_access_key(const char* value,
    size_t size) {
  
  access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_access_key() {
  
  return access_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_access_key() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.S3.access_key)
  return access_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_access_key(std::string* access_key) {
  if (access_key != nullptr) {
    
  } else {
    
  }
  access_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_access_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.S3.access_key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return access_key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_access_key(
    std::string* access_key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (access_key != nullptr) {
    
  } else {
    
  }
  access_key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      access_key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.S3.access_key)
}

// string secret_key = 5;
inline void RemoteStorageTarget_S3::clear_secret_key() {
  secret_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::secret_key() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.S3.secret_key)
  return _internal_secret_key();
}
inline void RemoteStorageTarget_S3::set_secret_key(const std::string& value) {
  _internal_set_secret_key(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::mutable_secret_key() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.S3.secret_key)
  return _internal_mutable_secret_key();
}
inline const std::string& RemoteStorageTarget_S3::_internal_secret_key() const {
  return secret_key_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_secret_key(const std::string& value) {
  
  secret_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_secret_key(std::string&& value) {
  
  secret_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.S3.secret_key)
}
inline void RemoteStorageTarget_S3::set_secret_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  secret_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.S3.secret_key)
}
inline void RemoteStorageTarget_S3::set_secret_key(const char* value,
    size_t size) {
  
  secret_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_secret_key() {
  
  return secret_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_secret_key() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.S3.secret_key)
  return secret_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_secret_key(std::string* secret_key) {
  if (secret_key != nullptr) {
    
  } else {
    
  }
  secret_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_secret_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.S3.secret_key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return secret_key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_secret_key(
    std::string* secret_key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (secret_key != nullptr) {
    
  } else {
    
  }
  secret_key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      secret_key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.S3.secret_key)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_Azure

// .beegfs.RemoteStorageTarget.S3 s3 = 1;
inline bool RemoteStorageTarget_Azure::_internal_has_s3() const {
  return this != internal_default_instance() && s3_ != nullptr;
}
inline bool RemoteStorageTarget_Azure::has_s3() const {
  return _internal_has_s3();
}
inline void RemoteStorageTarget_Azure::clear_s3() {
  if (GetArena() == nullptr && s3_ != nullptr) {
    delete s3_;
  }
  s3_ = nullptr;
}
inline const ::beegfs::RemoteStorageTarget_S3& RemoteStorageTarget_Azure::_internal_s3() const {
  const ::beegfs::RemoteStorageTarget_S3* p = s3_;
  return p != nullptr ? *p : *reinterpret_cast<const ::beegfs::RemoteStorageTarget_S3*>(
      &::beegfs::_RemoteStorageTarget_S3_default_instance_);
}
inline const ::beegfs::RemoteStorageTarget_S3& RemoteStorageTarget_Azure::s3() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Azure.s3)
  return _internal_s3();
}
inline void RemoteStorageTarget_Azure::unsafe_arena_set_allocated_s3(
    ::beegfs::RemoteStorageTarget_S3* s3) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s3_);
  }
  s3_ = s3;
  if (s3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.Azure.s3)
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::release_s3() {
  auto temp = unsafe_arena_release_s3();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.Azure.s3)
  
  ::beegfs::RemoteStorageTarget_S3* temp = s3_;
  s3_ = nullptr;
  return temp;
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::_internal_mutable_s3() {
  
  if (s3_ == nullptr) {
    auto* p = CreateMaybeMessage<::beegfs::RemoteStorageTarget_S3>(GetArena());
    s3_ = p;
  }
  return s3_;
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::mutable_s3() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.Azure.s3)
  return _internal_mutable_s3();
}
inline void RemoteStorageTarget_Azure::set_allocated_s3(::beegfs::RemoteStorageTarget_S3* s3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete s3_;
  }
  if (s3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(s3);
    if (message_arena != submessage_arena) {
      s3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s3, submessage_arena);
    }
    
  } else {
    
  }
  s3_ = s3;
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.Azure.s3)
}

// string account = 2;
inline void RemoteStorageTarget_Azure::clear_account() {
  account_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_Azure::account() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.Azure.account)
  return _internal_account();
}
inline void RemoteStorageTarget_Azure::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::mutable_account() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.Azure.account)
  return _internal_mutable_account();
}
inline const std::string& RemoteStorageTarget_Azure::_internal_account() const {
  return account_.Get();
}
inline void RemoteStorageTarget_Azure::_internal_set_account(const std::string& value) {
  
  account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_Azure::set_account(std::string&& value) {
  
  account_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.Azure.account)
}
inline void RemoteStorageTarget_Azure::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.Azure.account)
}
inline void RemoteStorageTarget_Azure::set_account(const char* value,
    size_t size) {
  
  account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::_internal_mutable_account() {
  
  return account_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_Azure::release_account() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.Azure.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_Azure::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.Azure.account)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return account_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_Azure::unsafe_arena_set_allocated_account(
    std::string* account) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (account != nullptr) {
    
  } else {
    
  }
  account_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      account, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.Azure.account)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_POSIX

// string path = 1;
inline void RemoteStorageTarget_POSIX::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_POSIX::path() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.POSIX.path)
  return _internal_path();
}
inline void RemoteStorageTarget_POSIX::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::mutable_path() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.POSIX.path)
  return _internal_mutable_path();
}
inline const std::string& RemoteStorageTarget_POSIX::_internal_path() const {
  return path_.Get();
}
inline void RemoteStorageTarget_POSIX::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_POSIX::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.POSIX.path)
}
inline void RemoteStorageTarget_POSIX::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.POSIX.path)
}
inline void RemoteStorageTarget_POSIX::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_POSIX::release_path() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.POSIX.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_POSIX::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.POSIX.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_POSIX::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.POSIX.path)
}

// -------------------------------------------------------------------

// RemoteStorageTarget

// string id = 1;
inline void RemoteStorageTarget::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget::id() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.id)
  return _internal_id();
}
inline void RemoteStorageTarget::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.id)
}
inline std::string* RemoteStorageTarget::mutable_id() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.id)
  return _internal_mutable_id();
}
inline const std::string& RemoteStorageTarget::_internal_id() const {
  return id_.Get();
}
inline void RemoteStorageTarget::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.id)
}
inline void RemoteStorageTarget::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.id)
}
inline void RemoteStorageTarget::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.id)
}
inline std::string* RemoteStorageTarget::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget::release_id() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.id)
}
inline std::string* RemoteStorageTarget::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.id)
}

// string name = 2;
inline void RemoteStorageTarget::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget::name() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.name)
  return _internal_name();
}
inline void RemoteStorageTarget::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:beegfs.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::mutable_name() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.name)
  return _internal_mutable_name();
}
inline const std::string& RemoteStorageTarget::_internal_name() const {
  return name_.Get();
}
inline void RemoteStorageTarget::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:beegfs.RemoteStorageTarget.name)
}
inline void RemoteStorageTarget::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:beegfs.RemoteStorageTarget.name)
}
inline void RemoteStorageTarget::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:beegfs.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget::release_name() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.name)
}

// .beegfs.RemoteStorageTarget.Policies policies = 3;
inline bool RemoteStorageTarget::_internal_has_policies() const {
  return this != internal_default_instance() && policies_ != nullptr;
}
inline bool RemoteStorageTarget::has_policies() const {
  return _internal_has_policies();
}
inline void RemoteStorageTarget::clear_policies() {
  if (GetArena() == nullptr && policies_ != nullptr) {
    delete policies_;
  }
  policies_ = nullptr;
}
inline const ::beegfs::RemoteStorageTarget_Policies& RemoteStorageTarget::_internal_policies() const {
  const ::beegfs::RemoteStorageTarget_Policies* p = policies_;
  return p != nullptr ? *p : *reinterpret_cast<const ::beegfs::RemoteStorageTarget_Policies*>(
      &::beegfs::_RemoteStorageTarget_Policies_default_instance_);
}
inline const ::beegfs::RemoteStorageTarget_Policies& RemoteStorageTarget::policies() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.policies)
  return _internal_policies();
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_policies(
    ::beegfs::RemoteStorageTarget_Policies* policies) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(policies_);
  }
  policies_ = policies;
  if (policies) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.policies)
}
inline ::beegfs::RemoteStorageTarget_Policies* RemoteStorageTarget::release_policies() {
  auto temp = unsafe_arena_release_policies();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::beegfs::RemoteStorageTarget_Policies* RemoteStorageTarget::unsafe_arena_release_policies() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.policies)
  
  ::beegfs::RemoteStorageTarget_Policies* temp = policies_;
  policies_ = nullptr;
  return temp;
}
inline ::beegfs::RemoteStorageTarget_Policies* RemoteStorageTarget::_internal_mutable_policies() {
  
  if (policies_ == nullptr) {
    auto* p = CreateMaybeMessage<::beegfs::RemoteStorageTarget_Policies>(GetArena());
    policies_ = p;
  }
  return policies_;
}
inline ::beegfs::RemoteStorageTarget_Policies* RemoteStorageTarget::mutable_policies() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.policies)
  return _internal_mutable_policies();
}
inline void RemoteStorageTarget::set_allocated_policies(::beegfs::RemoteStorageTarget_Policies* policies) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete policies_;
  }
  if (policies) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(policies);
    if (message_arena != submessage_arena) {
      policies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policies, submessage_arena);
    }
    
  } else {
    
  }
  policies_ = policies;
  // @@protoc_insertion_point(field_set_allocated:beegfs.RemoteStorageTarget.policies)
}

// .beegfs.RemoteStorageTarget.S3 s3 = 4;
inline bool RemoteStorageTarget::_internal_has_s3() const {
  return type_case() == kS3;
}
inline bool RemoteStorageTarget::has_s3() const {
  return _internal_has_s3();
}
inline void RemoteStorageTarget::set_has_s3() {
  _oneof_case_[0] = kS3;
}
inline void RemoteStorageTarget::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArena() == nullptr) {
      delete type_.s3_;
    }
    clear_has_type();
  }
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget::release_s3() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.s3)
  if (_internal_has_s3()) {
    clear_has_type();
      ::beegfs::RemoteStorageTarget_S3* temp = type_.s3_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::beegfs::RemoteStorageTarget_S3& RemoteStorageTarget::_internal_s3() const {
  return _internal_has_s3()
      ? *type_.s3_
      : *reinterpret_cast< ::beegfs::RemoteStorageTarget_S3*>(&::beegfs::_RemoteStorageTarget_S3_default_instance_);
}
inline const ::beegfs::RemoteStorageTarget_S3& RemoteStorageTarget::s3() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.s3)
  return _internal_s3();
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.s3)
  if (_internal_has_s3()) {
    clear_has_type();
    ::beegfs::RemoteStorageTarget_S3* temp = type_.s3_;
    type_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_s3(::beegfs::RemoteStorageTarget_S3* s3) {
  clear_type();
  if (s3) {
    set_has_s3();
    type_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.s3)
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_type();
    set_has_s3();
    type_.s3_ = CreateMaybeMessage< ::beegfs::RemoteStorageTarget_S3 >(GetArena());
  }
  return type_.s3_;
}
inline ::beegfs::RemoteStorageTarget_S3* RemoteStorageTarget::mutable_s3() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.s3)
  return _internal_mutable_s3();
}

// .beegfs.RemoteStorageTarget.POSIX posix = 5;
inline bool RemoteStorageTarget::_internal_has_posix() const {
  return type_case() == kPosix;
}
inline bool RemoteStorageTarget::has_posix() const {
  return _internal_has_posix();
}
inline void RemoteStorageTarget::set_has_posix() {
  _oneof_case_[0] = kPosix;
}
inline void RemoteStorageTarget::clear_posix() {
  if (_internal_has_posix()) {
    if (GetArena() == nullptr) {
      delete type_.posix_;
    }
    clear_has_type();
  }
}
inline ::beegfs::RemoteStorageTarget_POSIX* RemoteStorageTarget::release_posix() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.posix)
  if (_internal_has_posix()) {
    clear_has_type();
      ::beegfs::RemoteStorageTarget_POSIX* temp = type_.posix_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.posix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::beegfs::RemoteStorageTarget_POSIX& RemoteStorageTarget::_internal_posix() const {
  return _internal_has_posix()
      ? *type_.posix_
      : *reinterpret_cast< ::beegfs::RemoteStorageTarget_POSIX*>(&::beegfs::_RemoteStorageTarget_POSIX_default_instance_);
}
inline const ::beegfs::RemoteStorageTarget_POSIX& RemoteStorageTarget::posix() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.posix)
  return _internal_posix();
}
inline ::beegfs::RemoteStorageTarget_POSIX* RemoteStorageTarget::unsafe_arena_release_posix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.posix)
  if (_internal_has_posix()) {
    clear_has_type();
    ::beegfs::RemoteStorageTarget_POSIX* temp = type_.posix_;
    type_.posix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_posix(::beegfs::RemoteStorageTarget_POSIX* posix) {
  clear_type();
  if (posix) {
    set_has_posix();
    type_.posix_ = posix;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.posix)
}
inline ::beegfs::RemoteStorageTarget_POSIX* RemoteStorageTarget::_internal_mutable_posix() {
  if (!_internal_has_posix()) {
    clear_type();
    set_has_posix();
    type_.posix_ = CreateMaybeMessage< ::beegfs::RemoteStorageTarget_POSIX >(GetArena());
  }
  return type_.posix_;
}
inline ::beegfs::RemoteStorageTarget_POSIX* RemoteStorageTarget::mutable_posix() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.posix)
  return _internal_mutable_posix();
}

// .beegfs.RemoteStorageTarget.Azure azure = 6;
inline bool RemoteStorageTarget::_internal_has_azure() const {
  return type_case() == kAzure;
}
inline bool RemoteStorageTarget::has_azure() const {
  return _internal_has_azure();
}
inline void RemoteStorageTarget::set_has_azure() {
  _oneof_case_[0] = kAzure;
}
inline void RemoteStorageTarget::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArena() == nullptr) {
      delete type_.azure_;
    }
    clear_has_type();
  }
}
inline ::beegfs::RemoteStorageTarget_Azure* RemoteStorageTarget::release_azure() {
  // @@protoc_insertion_point(field_release:beegfs.RemoteStorageTarget.azure)
  if (_internal_has_azure()) {
    clear_has_type();
      ::beegfs::RemoteStorageTarget_Azure* temp = type_.azure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::beegfs::RemoteStorageTarget_Azure& RemoteStorageTarget::_internal_azure() const {
  return _internal_has_azure()
      ? *type_.azure_
      : *reinterpret_cast< ::beegfs::RemoteStorageTarget_Azure*>(&::beegfs::_RemoteStorageTarget_Azure_default_instance_);
}
inline const ::beegfs::RemoteStorageTarget_Azure& RemoteStorageTarget::azure() const {
  // @@protoc_insertion_point(field_get:beegfs.RemoteStorageTarget.azure)
  return _internal_azure();
}
inline ::beegfs::RemoteStorageTarget_Azure* RemoteStorageTarget::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.RemoteStorageTarget.azure)
  if (_internal_has_azure()) {
    clear_has_type();
    ::beegfs::RemoteStorageTarget_Azure* temp = type_.azure_;
    type_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_azure(::beegfs::RemoteStorageTarget_Azure* azure) {
  clear_type();
  if (azure) {
    set_has_azure();
    type_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.RemoteStorageTarget.azure)
}
inline ::beegfs::RemoteStorageTarget_Azure* RemoteStorageTarget::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_type();
    set_has_azure();
    type_.azure_ = CreateMaybeMessage< ::beegfs::RemoteStorageTarget_Azure >(GetArena());
  }
  return type_.azure_;
}
inline ::beegfs::RemoteStorageTarget_Azure* RemoteStorageTarget::mutable_azure() {
  // @@protoc_insertion_point(field_mutable:beegfs.RemoteStorageTarget.azure)
  return _internal_mutable_azure();
}

inline bool RemoteStorageTarget::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RemoteStorageTarget::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline RemoteStorageTarget::TypeCase RemoteStorageTarget::type_case() const {
  return RemoteStorageTarget::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace beegfs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::beegfs::RequestStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::beegfs::RequestStatus_Status>() {
  return ::beegfs::RequestStatus_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto
