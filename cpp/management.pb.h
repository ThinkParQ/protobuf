// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: management.proto
// Protobuf C++ Version: 5.29.2

#ifndef management_2eproto_2epb_2eh
#define management_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "beegfs.pb.h"
#include "license.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_management_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_management_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_management_2eproto;
namespace management {
class AssignPoolRequest;
struct AssignPoolRequestDefaultTypeInternal;
extern AssignPoolRequestDefaultTypeInternal _AssignPoolRequest_default_instance_;
class AssignPoolResponse;
struct AssignPoolResponseDefaultTypeInternal;
extern AssignPoolResponseDefaultTypeInternal _AssignPoolResponse_default_instance_;
class CreateBuddyGroupRequest;
struct CreateBuddyGroupRequestDefaultTypeInternal;
extern CreateBuddyGroupRequestDefaultTypeInternal _CreateBuddyGroupRequest_default_instance_;
class CreateBuddyGroupResponse;
struct CreateBuddyGroupResponseDefaultTypeInternal;
extern CreateBuddyGroupResponseDefaultTypeInternal _CreateBuddyGroupResponse_default_instance_;
class CreatePoolRequest;
struct CreatePoolRequestDefaultTypeInternal;
extern CreatePoolRequestDefaultTypeInternal _CreatePoolRequest_default_instance_;
class CreatePoolResponse;
struct CreatePoolResponseDefaultTypeInternal;
extern CreatePoolResponseDefaultTypeInternal _CreatePoolResponse_default_instance_;
class DeleteBuddyGroupRequest;
struct DeleteBuddyGroupRequestDefaultTypeInternal;
extern DeleteBuddyGroupRequestDefaultTypeInternal _DeleteBuddyGroupRequest_default_instance_;
class DeleteBuddyGroupResponse;
struct DeleteBuddyGroupResponseDefaultTypeInternal;
extern DeleteBuddyGroupResponseDefaultTypeInternal _DeleteBuddyGroupResponse_default_instance_;
class DeleteNodeRequest;
struct DeleteNodeRequestDefaultTypeInternal;
extern DeleteNodeRequestDefaultTypeInternal _DeleteNodeRequest_default_instance_;
class DeleteNodeResponse;
struct DeleteNodeResponseDefaultTypeInternal;
extern DeleteNodeResponseDefaultTypeInternal _DeleteNodeResponse_default_instance_;
class DeletePoolRequest;
struct DeletePoolRequestDefaultTypeInternal;
extern DeletePoolRequestDefaultTypeInternal _DeletePoolRequest_default_instance_;
class DeletePoolResponse;
struct DeletePoolResponseDefaultTypeInternal;
extern DeletePoolResponseDefaultTypeInternal _DeletePoolResponse_default_instance_;
class DeleteTargetRequest;
struct DeleteTargetRequestDefaultTypeInternal;
extern DeleteTargetRequestDefaultTypeInternal _DeleteTargetRequest_default_instance_;
class DeleteTargetResponse;
struct DeleteTargetResponseDefaultTypeInternal;
extern DeleteTargetResponseDefaultTypeInternal _DeleteTargetResponse_default_instance_;
class GetBuddyGroupsRequest;
struct GetBuddyGroupsRequestDefaultTypeInternal;
extern GetBuddyGroupsRequestDefaultTypeInternal _GetBuddyGroupsRequest_default_instance_;
class GetBuddyGroupsResponse;
struct GetBuddyGroupsResponseDefaultTypeInternal;
extern GetBuddyGroupsResponseDefaultTypeInternal _GetBuddyGroupsResponse_default_instance_;
class GetBuddyGroupsResponse_BuddyGroup;
struct GetBuddyGroupsResponse_BuddyGroupDefaultTypeInternal;
extern GetBuddyGroupsResponse_BuddyGroupDefaultTypeInternal _GetBuddyGroupsResponse_BuddyGroup_default_instance_;
class GetLicenseRequest;
struct GetLicenseRequestDefaultTypeInternal;
extern GetLicenseRequestDefaultTypeInternal _GetLicenseRequest_default_instance_;
class GetLicenseResponse;
struct GetLicenseResponseDefaultTypeInternal;
extern GetLicenseResponseDefaultTypeInternal _GetLicenseResponse_default_instance_;
class GetNodesRequest;
struct GetNodesRequestDefaultTypeInternal;
extern GetNodesRequestDefaultTypeInternal _GetNodesRequest_default_instance_;
class GetNodesResponse;
struct GetNodesResponseDefaultTypeInternal;
extern GetNodesResponseDefaultTypeInternal _GetNodesResponse_default_instance_;
class GetNodesResponse_Node;
struct GetNodesResponse_NodeDefaultTypeInternal;
extern GetNodesResponse_NodeDefaultTypeInternal _GetNodesResponse_Node_default_instance_;
class GetNodesResponse_Node_Nic;
struct GetNodesResponse_Node_NicDefaultTypeInternal;
extern GetNodesResponse_Node_NicDefaultTypeInternal _GetNodesResponse_Node_Nic_default_instance_;
class GetPoolsRequest;
struct GetPoolsRequestDefaultTypeInternal;
extern GetPoolsRequestDefaultTypeInternal _GetPoolsRequest_default_instance_;
class GetPoolsResponse;
struct GetPoolsResponseDefaultTypeInternal;
extern GetPoolsResponseDefaultTypeInternal _GetPoolsResponse_default_instance_;
class GetPoolsResponse_StoragePool;
struct GetPoolsResponse_StoragePoolDefaultTypeInternal;
extern GetPoolsResponse_StoragePoolDefaultTypeInternal _GetPoolsResponse_StoragePool_default_instance_;
class GetQuotaLimitsRequest;
struct GetQuotaLimitsRequestDefaultTypeInternal;
extern GetQuotaLimitsRequestDefaultTypeInternal _GetQuotaLimitsRequest_default_instance_;
class GetQuotaLimitsResponse;
struct GetQuotaLimitsResponseDefaultTypeInternal;
extern GetQuotaLimitsResponseDefaultTypeInternal _GetQuotaLimitsResponse_default_instance_;
class GetQuotaUsageRequest;
struct GetQuotaUsageRequestDefaultTypeInternal;
extern GetQuotaUsageRequestDefaultTypeInternal _GetQuotaUsageRequest_default_instance_;
class GetQuotaUsageResponse;
struct GetQuotaUsageResponseDefaultTypeInternal;
extern GetQuotaUsageResponseDefaultTypeInternal _GetQuotaUsageResponse_default_instance_;
class GetTargetsRequest;
struct GetTargetsRequestDefaultTypeInternal;
extern GetTargetsRequestDefaultTypeInternal _GetTargetsRequest_default_instance_;
class GetTargetsResponse;
struct GetTargetsResponseDefaultTypeInternal;
extern GetTargetsResponseDefaultTypeInternal _GetTargetsResponse_default_instance_;
class GetTargetsResponse_Target;
struct GetTargetsResponse_TargetDefaultTypeInternal;
extern GetTargetsResponse_TargetDefaultTypeInternal _GetTargetsResponse_Target_default_instance_;
class MirrorRootInodeRequest;
struct MirrorRootInodeRequestDefaultTypeInternal;
extern MirrorRootInodeRequestDefaultTypeInternal _MirrorRootInodeRequest_default_instance_;
class MirrorRootInodeResponse;
struct MirrorRootInodeResponseDefaultTypeInternal;
extern MirrorRootInodeResponseDefaultTypeInternal _MirrorRootInodeResponse_default_instance_;
class QuotaInfo;
struct QuotaInfoDefaultTypeInternal;
extern QuotaInfoDefaultTypeInternal _QuotaInfo_default_instance_;
class SetAliasRequest;
struct SetAliasRequestDefaultTypeInternal;
extern SetAliasRequestDefaultTypeInternal _SetAliasRequest_default_instance_;
class SetAliasResponse;
struct SetAliasResponseDefaultTypeInternal;
extern SetAliasResponseDefaultTypeInternal _SetAliasResponse_default_instance_;
class SetDefaultQuotaLimitsRequest;
struct SetDefaultQuotaLimitsRequestDefaultTypeInternal;
extern SetDefaultQuotaLimitsRequestDefaultTypeInternal _SetDefaultQuotaLimitsRequest_default_instance_;
class SetDefaultQuotaLimitsResponse;
struct SetDefaultQuotaLimitsResponseDefaultTypeInternal;
extern SetDefaultQuotaLimitsResponseDefaultTypeInternal _SetDefaultQuotaLimitsResponse_default_instance_;
class SetQuotaLimitsRequest;
struct SetQuotaLimitsRequestDefaultTypeInternal;
extern SetQuotaLimitsRequestDefaultTypeInternal _SetQuotaLimitsRequest_default_instance_;
class SetQuotaLimitsResponse;
struct SetQuotaLimitsResponseDefaultTypeInternal;
extern SetQuotaLimitsResponseDefaultTypeInternal _SetQuotaLimitsResponse_default_instance_;
class SetTargetStateRequest;
struct SetTargetStateRequestDefaultTypeInternal;
extern SetTargetStateRequestDefaultTypeInternal _SetTargetStateRequest_default_instance_;
class SetTargetStateResponse;
struct SetTargetStateResponseDefaultTypeInternal;
extern SetTargetStateResponseDefaultTypeInternal _SetTargetStateResponse_default_instance_;
class StartResyncRequest;
struct StartResyncRequestDefaultTypeInternal;
extern StartResyncRequestDefaultTypeInternal _StartResyncRequest_default_instance_;
class StartResyncResponse;
struct StartResyncResponseDefaultTypeInternal;
extern StartResyncResponseDefaultTypeInternal _StartResyncResponse_default_instance_;
}  // namespace management
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace management {

// ===================================================================


// -------------------------------------------------------------------

class StartResyncResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.StartResyncResponse) */ {
 public:
  inline StartResyncResponse() : StartResyncResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartResyncResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartResyncResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartResyncResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline StartResyncResponse(const StartResyncResponse& from) : StartResyncResponse(nullptr, from) {}
  inline StartResyncResponse(StartResyncResponse&& from) noexcept
      : StartResyncResponse(nullptr, std::move(from)) {}
  inline StartResyncResponse& operator=(const StartResyncResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartResyncResponse& operator=(StartResyncResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartResyncResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartResyncResponse* internal_default_instance() {
    return reinterpret_cast<const StartResyncResponse*>(
        &_StartResyncResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(StartResyncResponse& a, StartResyncResponse& b) { a.Swap(&b); }
  inline void Swap(StartResyncResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartResyncResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartResyncResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<StartResyncResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartResyncResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartResyncResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.StartResyncResponse"; }

 protected:
  explicit StartResyncResponse(::google::protobuf::Arena* arena);
  StartResyncResponse(::google::protobuf::Arena* arena, const StartResyncResponse& from);
  StartResyncResponse(::google::protobuf::Arena* arena, StartResyncResponse&& from) noexcept
      : StartResyncResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.StartResyncResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StartResyncResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetTargetStateResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.SetTargetStateResponse) */ {
 public:
  inline SetTargetStateResponse() : SetTargetStateResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetTargetStateResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetTargetStateResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetTargetStateResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetTargetStateResponse(const SetTargetStateResponse& from) : SetTargetStateResponse(nullptr, from) {}
  inline SetTargetStateResponse(SetTargetStateResponse&& from) noexcept
      : SetTargetStateResponse(nullptr, std::move(from)) {}
  inline SetTargetStateResponse& operator=(const SetTargetStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTargetStateResponse& operator=(SetTargetStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTargetStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTargetStateResponse* internal_default_instance() {
    return reinterpret_cast<const SetTargetStateResponse*>(
        &_SetTargetStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SetTargetStateResponse& a, SetTargetStateResponse& b) { a.Swap(&b); }
  inline void Swap(SetTargetStateResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTargetStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTargetStateResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetTargetStateResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTargetStateResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTargetStateResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetTargetStateResponse"; }

 protected:
  explicit SetTargetStateResponse(::google::protobuf::Arena* arena);
  SetTargetStateResponse(::google::protobuf::Arena* arena, const SetTargetStateResponse& from);
  SetTargetStateResponse(::google::protobuf::Arena* arena, SetTargetStateResponse&& from) noexcept
      : SetTargetStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.SetTargetStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetTargetStateResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetQuotaLimitsResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.SetQuotaLimitsResponse) */ {
 public:
  inline SetQuotaLimitsResponse() : SetQuotaLimitsResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetQuotaLimitsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetQuotaLimitsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetQuotaLimitsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetQuotaLimitsResponse(const SetQuotaLimitsResponse& from) : SetQuotaLimitsResponse(nullptr, from) {}
  inline SetQuotaLimitsResponse(SetQuotaLimitsResponse&& from) noexcept
      : SetQuotaLimitsResponse(nullptr, std::move(from)) {}
  inline SetQuotaLimitsResponse& operator=(const SetQuotaLimitsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetQuotaLimitsResponse& operator=(SetQuotaLimitsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetQuotaLimitsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetQuotaLimitsResponse* internal_default_instance() {
    return reinterpret_cast<const SetQuotaLimitsResponse*>(
        &_SetQuotaLimitsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(SetQuotaLimitsResponse& a, SetQuotaLimitsResponse& b) { a.Swap(&b); }
  inline void Swap(SetQuotaLimitsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetQuotaLimitsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetQuotaLimitsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetQuotaLimitsResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetQuotaLimitsResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetQuotaLimitsResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetQuotaLimitsResponse"; }

 protected:
  explicit SetQuotaLimitsResponse(::google::protobuf::Arena* arena);
  SetQuotaLimitsResponse(::google::protobuf::Arena* arena, const SetQuotaLimitsResponse& from);
  SetQuotaLimitsResponse(::google::protobuf::Arena* arena, SetQuotaLimitsResponse&& from) noexcept
      : SetQuotaLimitsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.SetQuotaLimitsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetQuotaLimitsResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetDefaultQuotaLimitsResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.SetDefaultQuotaLimitsResponse) */ {
 public:
  inline SetDefaultQuotaLimitsResponse() : SetDefaultQuotaLimitsResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetDefaultQuotaLimitsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetDefaultQuotaLimitsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetDefaultQuotaLimitsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetDefaultQuotaLimitsResponse(const SetDefaultQuotaLimitsResponse& from) : SetDefaultQuotaLimitsResponse(nullptr, from) {}
  inline SetDefaultQuotaLimitsResponse(SetDefaultQuotaLimitsResponse&& from) noexcept
      : SetDefaultQuotaLimitsResponse(nullptr, std::move(from)) {}
  inline SetDefaultQuotaLimitsResponse& operator=(const SetDefaultQuotaLimitsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDefaultQuotaLimitsResponse& operator=(SetDefaultQuotaLimitsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDefaultQuotaLimitsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDefaultQuotaLimitsResponse* internal_default_instance() {
    return reinterpret_cast<const SetDefaultQuotaLimitsResponse*>(
        &_SetDefaultQuotaLimitsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(SetDefaultQuotaLimitsResponse& a, SetDefaultQuotaLimitsResponse& b) { a.Swap(&b); }
  inline void Swap(SetDefaultQuotaLimitsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDefaultQuotaLimitsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDefaultQuotaLimitsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetDefaultQuotaLimitsResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetDefaultQuotaLimitsResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetDefaultQuotaLimitsResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetDefaultQuotaLimitsResponse"; }

 protected:
  explicit SetDefaultQuotaLimitsResponse(::google::protobuf::Arena* arena);
  SetDefaultQuotaLimitsResponse(::google::protobuf::Arena* arena, const SetDefaultQuotaLimitsResponse& from);
  SetDefaultQuotaLimitsResponse(::google::protobuf::Arena* arena, SetDefaultQuotaLimitsResponse&& from) noexcept
      : SetDefaultQuotaLimitsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.SetDefaultQuotaLimitsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetDefaultQuotaLimitsResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetAliasResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.SetAliasResponse) */ {
 public:
  inline SetAliasResponse() : SetAliasResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetAliasResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetAliasResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetAliasResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetAliasResponse(const SetAliasResponse& from) : SetAliasResponse(nullptr, from) {}
  inline SetAliasResponse(SetAliasResponse&& from) noexcept
      : SetAliasResponse(nullptr, std::move(from)) {}
  inline SetAliasResponse& operator=(const SetAliasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAliasResponse& operator=(SetAliasResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAliasResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAliasResponse* internal_default_instance() {
    return reinterpret_cast<const SetAliasResponse*>(
        &_SetAliasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SetAliasResponse& a, SetAliasResponse& b) { a.Swap(&b); }
  inline void Swap(SetAliasResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAliasResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAliasResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetAliasResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetAliasResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetAliasResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetAliasResponse"; }

 protected:
  explicit SetAliasResponse(::google::protobuf::Arena* arena);
  SetAliasResponse(::google::protobuf::Arena* arena, const SetAliasResponse& from);
  SetAliasResponse(::google::protobuf::Arena* arena, SetAliasResponse&& from) noexcept
      : SetAliasResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.SetAliasResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetAliasResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class MirrorRootInodeResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.MirrorRootInodeResponse) */ {
 public:
  inline MirrorRootInodeResponse() : MirrorRootInodeResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MirrorRootInodeResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MirrorRootInodeResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MirrorRootInodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MirrorRootInodeResponse(const MirrorRootInodeResponse& from) : MirrorRootInodeResponse(nullptr, from) {}
  inline MirrorRootInodeResponse(MirrorRootInodeResponse&& from) noexcept
      : MirrorRootInodeResponse(nullptr, std::move(from)) {}
  inline MirrorRootInodeResponse& operator=(const MirrorRootInodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MirrorRootInodeResponse& operator=(MirrorRootInodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MirrorRootInodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MirrorRootInodeResponse* internal_default_instance() {
    return reinterpret_cast<const MirrorRootInodeResponse*>(
        &_MirrorRootInodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(MirrorRootInodeResponse& a, MirrorRootInodeResponse& b) { a.Swap(&b); }
  inline void Swap(MirrorRootInodeResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MirrorRootInodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MirrorRootInodeResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<MirrorRootInodeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MirrorRootInodeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MirrorRootInodeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.MirrorRootInodeResponse"; }

 protected:
  explicit MirrorRootInodeResponse(::google::protobuf::Arena* arena);
  MirrorRootInodeResponse(::google::protobuf::Arena* arena, const MirrorRootInodeResponse& from);
  MirrorRootInodeResponse(::google::protobuf::Arena* arena, MirrorRootInodeResponse&& from) noexcept
      : MirrorRootInodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.MirrorRootInodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MirrorRootInodeResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class MirrorRootInodeRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.MirrorRootInodeRequest) */ {
 public:
  inline MirrorRootInodeRequest() : MirrorRootInodeRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MirrorRootInodeRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MirrorRootInodeRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MirrorRootInodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MirrorRootInodeRequest(const MirrorRootInodeRequest& from) : MirrorRootInodeRequest(nullptr, from) {}
  inline MirrorRootInodeRequest(MirrorRootInodeRequest&& from) noexcept
      : MirrorRootInodeRequest(nullptr, std::move(from)) {}
  inline MirrorRootInodeRequest& operator=(const MirrorRootInodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MirrorRootInodeRequest& operator=(MirrorRootInodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MirrorRootInodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MirrorRootInodeRequest* internal_default_instance() {
    return reinterpret_cast<const MirrorRootInodeRequest*>(
        &_MirrorRootInodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(MirrorRootInodeRequest& a, MirrorRootInodeRequest& b) { a.Swap(&b); }
  inline void Swap(MirrorRootInodeRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MirrorRootInodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MirrorRootInodeRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<MirrorRootInodeRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MirrorRootInodeRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MirrorRootInodeRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.MirrorRootInodeRequest"; }

 protected:
  explicit MirrorRootInodeRequest(::google::protobuf::Arena* arena);
  MirrorRootInodeRequest(::google::protobuf::Arena* arena, const MirrorRootInodeRequest& from);
  MirrorRootInodeRequest(::google::protobuf::Arena* arena, MirrorRootInodeRequest&& from) noexcept
      : MirrorRootInodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.MirrorRootInodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MirrorRootInodeRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetTargetsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.GetTargetsRequest) */ {
 public:
  inline GetTargetsRequest() : GetTargetsRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTargetsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTargetsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTargetsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTargetsRequest(const GetTargetsRequest& from) : GetTargetsRequest(nullptr, from) {}
  inline GetTargetsRequest(GetTargetsRequest&& from) noexcept
      : GetTargetsRequest(nullptr, std::move(from)) {}
  inline GetTargetsRequest& operator=(const GetTargetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTargetsRequest& operator=(GetTargetsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTargetsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTargetsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTargetsRequest*>(
        &_GetTargetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetTargetsRequest& a, GetTargetsRequest& b) { a.Swap(&b); }
  inline void Swap(GetTargetsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTargetsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTargetsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetTargetsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetTargetsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetTargetsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetTargetsRequest"; }

 protected:
  explicit GetTargetsRequest(::google::protobuf::Arena* arena);
  GetTargetsRequest(::google::protobuf::Arena* arena, const GetTargetsRequest& from);
  GetTargetsRequest(::google::protobuf::Arena* arena, GetTargetsRequest&& from) noexcept
      : GetTargetsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.GetTargetsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTargetsRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetPoolsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetPoolsRequest) */ {
 public:
  inline GetPoolsRequest() : GetPoolsRequest(nullptr) {}
  ~GetPoolsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPoolsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPoolsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPoolsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPoolsRequest(const GetPoolsRequest& from) : GetPoolsRequest(nullptr, from) {}
  inline GetPoolsRequest(GetPoolsRequest&& from) noexcept
      : GetPoolsRequest(nullptr, std::move(from)) {}
  inline GetPoolsRequest& operator=(const GetPoolsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoolsRequest& operator=(GetPoolsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoolsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoolsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPoolsRequest*>(
        &_GetPoolsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetPoolsRequest& a, GetPoolsRequest& b) { a.Swap(&b); }
  inline void Swap(GetPoolsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoolsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoolsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPoolsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPoolsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPoolsRequest& from) { GetPoolsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPoolsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetPoolsRequest"; }

 protected:
  explicit GetPoolsRequest(::google::protobuf::Arena* arena);
  GetPoolsRequest(::google::protobuf::Arena* arena, const GetPoolsRequest& from);
  GetPoolsRequest(::google::protobuf::Arena* arena, GetPoolsRequest&& from) noexcept
      : GetPoolsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWithQuotaLimitsFieldNumber = 1,
  };
  // bool with_quota_limits = 1;
  void clear_with_quota_limits() ;
  bool with_quota_limits() const;
  void set_with_quota_limits(bool value);

  private:
  bool _internal_with_quota_limits() const;
  void _internal_set_with_quota_limits(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetPoolsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPoolsRequest& from_msg);
    bool with_quota_limits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResponse_Node_Nic final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetNodesResponse.Node.Nic) */ {
 public:
  inline GetNodesResponse_Node_Nic() : GetNodesResponse_Node_Nic(nullptr) {}
  ~GetNodesResponse_Node_Nic() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetNodesResponse_Node_Nic* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetNodesResponse_Node_Nic));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResponse_Node_Nic(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResponse_Node_Nic(const GetNodesResponse_Node_Nic& from) : GetNodesResponse_Node_Nic(nullptr, from) {}
  inline GetNodesResponse_Node_Nic(GetNodesResponse_Node_Nic&& from) noexcept
      : GetNodesResponse_Node_Nic(nullptr, std::move(from)) {}
  inline GetNodesResponse_Node_Nic& operator=(const GetNodesResponse_Node_Nic& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResponse_Node_Nic& operator=(GetNodesResponse_Node_Nic&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResponse_Node_Nic& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResponse_Node_Nic* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse_Node_Nic*>(
        &_GetNodesResponse_Node_Nic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GetNodesResponse_Node_Nic& a, GetNodesResponse_Node_Nic& b) { a.Swap(&b); }
  inline void Swap(GetNodesResponse_Node_Nic* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResponse_Node_Nic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResponse_Node_Nic* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResponse_Node_Nic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResponse_Node_Nic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResponse_Node_Nic& from) { GetNodesResponse_Node_Nic::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetNodesResponse_Node_Nic* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetNodesResponse.Node.Nic"; }

 protected:
  explicit GetNodesResponse_Node_Nic(::google::protobuf::Arena* arena);
  GetNodesResponse_Node_Nic(::google::protobuf::Arena* arena, const GetNodesResponse_Node_Nic& from);
  GetNodesResponse_Node_Nic(::google::protobuf::Arena* arena, GetNodesResponse_Node_Nic&& from) noexcept
      : GetNodesResponse_Node_Nic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddrFieldNumber = 1,
    kNameFieldNumber = 2,
    kNicTypeFieldNumber = 3,
  };
  // string addr = 1;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .beegfs.NicType nic_type = 3;
  void clear_nic_type() ;
  ::beegfs::NicType nic_type() const;
  void set_nic_type(::beegfs::NicType value);

  private:
  ::beegfs::NicType _internal_nic_type() const;
  void _internal_set_nic_type(::beegfs::NicType value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetNodesResponse.Node.Nic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetNodesResponse_Node_Nic& from_msg);
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    int nic_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetNodesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetNodesRequest) */ {
 public:
  inline GetNodesRequest() : GetNodesRequest(nullptr) {}
  ~GetNodesRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetNodesRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetNodesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesRequest(const GetNodesRequest& from) : GetNodesRequest(nullptr, from) {}
  inline GetNodesRequest(GetNodesRequest&& from) noexcept
      : GetNodesRequest(nullptr, std::move(from)) {}
  inline GetNodesRequest& operator=(const GetNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesRequest& operator=(GetNodesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodesRequest*>(
        &_GetNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetNodesRequest& a, GetNodesRequest& b) { a.Swap(&b); }
  inline void Swap(GetNodesRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesRequest& from) { GetNodesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetNodesRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetNodesRequest"; }

 protected:
  explicit GetNodesRequest(::google::protobuf::Arena* arena);
  GetNodesRequest(::google::protobuf::Arena* arena, const GetNodesRequest& from);
  GetNodesRequest(::google::protobuf::Arena* arena, GetNodesRequest&& from) noexcept
      : GetNodesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIncludeNicsFieldNumber = 1,
  };
  // bool include_nics = 1;
  void clear_include_nics() ;
  bool include_nics() const;
  void set_include_nics(bool value);

  private:
  bool _internal_include_nics() const;
  void _internal_set_include_nics(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetNodesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetNodesRequest& from_msg);
    bool include_nics_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetLicenseRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetLicenseRequest) */ {
 public:
  inline GetLicenseRequest() : GetLicenseRequest(nullptr) {}
  ~GetLicenseRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetLicenseRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetLicenseRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetLicenseRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetLicenseRequest(const GetLicenseRequest& from) : GetLicenseRequest(nullptr, from) {}
  inline GetLicenseRequest(GetLicenseRequest&& from) noexcept
      : GetLicenseRequest(nullptr, std::move(from)) {}
  inline GetLicenseRequest& operator=(const GetLicenseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLicenseRequest& operator=(GetLicenseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLicenseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLicenseRequest* internal_default_instance() {
    return reinterpret_cast<const GetLicenseRequest*>(
        &_GetLicenseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(GetLicenseRequest& a, GetLicenseRequest& b) { a.Swap(&b); }
  inline void Swap(GetLicenseRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLicenseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLicenseRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetLicenseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLicenseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetLicenseRequest& from) { GetLicenseRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetLicenseRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetLicenseRequest"; }

 protected:
  explicit GetLicenseRequest(::google::protobuf::Arena* arena);
  GetLicenseRequest(::google::protobuf::Arena* arena, const GetLicenseRequest& from);
  GetLicenseRequest(::google::protobuf::Arena* arena, GetLicenseRequest&& from) noexcept
      : GetLicenseRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReloadFieldNumber = 1,
  };
  // optional bool reload = 1;
  bool has_reload() const;
  void clear_reload() ;
  bool reload() const;
  void set_reload(bool value);

  private:
  bool _internal_reload() const;
  void _internal_set_reload(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetLicenseRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetLicenseRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool reload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetBuddyGroupsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:management.GetBuddyGroupsRequest) */ {
 public:
  inline GetBuddyGroupsRequest() : GetBuddyGroupsRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBuddyGroupsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBuddyGroupsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBuddyGroupsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBuddyGroupsRequest(const GetBuddyGroupsRequest& from) : GetBuddyGroupsRequest(nullptr, from) {}
  inline GetBuddyGroupsRequest(GetBuddyGroupsRequest&& from) noexcept
      : GetBuddyGroupsRequest(nullptr, std::move(from)) {}
  inline GetBuddyGroupsRequest& operator=(const GetBuddyGroupsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBuddyGroupsRequest& operator=(GetBuddyGroupsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBuddyGroupsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBuddyGroupsRequest* internal_default_instance() {
    return reinterpret_cast<const GetBuddyGroupsRequest*>(
        &_GetBuddyGroupsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(GetBuddyGroupsRequest& a, GetBuddyGroupsRequest& b) { a.Swap(&b); }
  inline void Swap(GetBuddyGroupsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBuddyGroupsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBuddyGroupsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetBuddyGroupsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBuddyGroupsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBuddyGroupsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetBuddyGroupsRequest"; }

 protected:
  explicit GetBuddyGroupsRequest(::google::protobuf::Arena* arena);
  GetBuddyGroupsRequest(::google::protobuf::Arena* arena, const GetBuddyGroupsRequest& from);
  GetBuddyGroupsRequest(::google::protobuf::Arena* arena, GetBuddyGroupsRequest&& from) noexcept
      : GetBuddyGroupsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:management.GetBuddyGroupsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBuddyGroupsRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class StartResyncRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.StartResyncRequest) */ {
 public:
  inline StartResyncRequest() : StartResyncRequest(nullptr) {}
  ~StartResyncRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartResyncRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartResyncRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartResyncRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline StartResyncRequest(const StartResyncRequest& from) : StartResyncRequest(nullptr, from) {}
  inline StartResyncRequest(StartResyncRequest&& from) noexcept
      : StartResyncRequest(nullptr, std::move(from)) {}
  inline StartResyncRequest& operator=(const StartResyncRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartResyncRequest& operator=(StartResyncRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartResyncRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartResyncRequest* internal_default_instance() {
    return reinterpret_cast<const StartResyncRequest*>(
        &_StartResyncRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(StartResyncRequest& a, StartResyncRequest& b) { a.Swap(&b); }
  inline void Swap(StartResyncRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartResyncRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartResyncRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StartResyncRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StartResyncRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StartResyncRequest& from) { StartResyncRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StartResyncRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.StartResyncRequest"; }

 protected:
  explicit StartResyncRequest(::google::protobuf::Arena* arena);
  StartResyncRequest(::google::protobuf::Arena* arena, const StartResyncRequest& from);
  StartResyncRequest(::google::protobuf::Arena* arena, StartResyncRequest&& from) noexcept
      : StartResyncRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuddyGroupFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kRestartFieldNumber = 3,
  };
  // optional .beegfs.EntityIdSet buddy_group = 1;
  bool has_buddy_group() const;
  void clear_buddy_group() ;
  const ::beegfs::EntityIdSet& buddy_group() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_buddy_group();
  ::beegfs::EntityIdSet* mutable_buddy_group();
  void set_allocated_buddy_group(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_buddy_group(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_buddy_group();

  private:
  const ::beegfs::EntityIdSet& _internal_buddy_group() const;
  ::beegfs::EntityIdSet* _internal_mutable_buddy_group();

  public:
  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // optional bool restart = 3;
  bool has_restart() const;
  void clear_restart() ;
  bool restart() const;
  void set_restart(bool value);

  private:
  bool _internal_restart() const;
  void _internal_set_restart(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.StartResyncRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StartResyncRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* buddy_group_;
    ::int64_t timestamp_;
    bool restart_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetTargetStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.SetTargetStateRequest) */ {
 public:
  inline SetTargetStateRequest() : SetTargetStateRequest(nullptr) {}
  ~SetTargetStateRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetTargetStateRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetTargetStateRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetTargetStateRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetTargetStateRequest(const SetTargetStateRequest& from) : SetTargetStateRequest(nullptr, from) {}
  inline SetTargetStateRequest(SetTargetStateRequest&& from) noexcept
      : SetTargetStateRequest(nullptr, std::move(from)) {}
  inline SetTargetStateRequest& operator=(const SetTargetStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTargetStateRequest& operator=(SetTargetStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTargetStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTargetStateRequest* internal_default_instance() {
    return reinterpret_cast<const SetTargetStateRequest*>(
        &_SetTargetStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SetTargetStateRequest& a, SetTargetStateRequest& b) { a.Swap(&b); }
  inline void Swap(SetTargetStateRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTargetStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTargetStateRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetTargetStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetTargetStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetTargetStateRequest& from) { SetTargetStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetTargetStateRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetTargetStateRequest"; }

 protected:
  explicit SetTargetStateRequest(::google::protobuf::Arena* arena);
  SetTargetStateRequest(::google::protobuf::Arena* arena, const SetTargetStateRequest& from);
  SetTargetStateRequest(::google::protobuf::Arena* arena, SetTargetStateRequest&& from) noexcept
      : SetTargetStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kConsistencyStateFieldNumber = 2,
  };
  // optional .beegfs.EntityIdSet target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::beegfs::EntityIdSet& target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_target();
  ::beegfs::EntityIdSet* mutable_target();
  void set_allocated_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_target();

  private:
  const ::beegfs::EntityIdSet& _internal_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_target();

  public:
  // optional .beegfs.ConsistencyState consistency_state = 2;
  bool has_consistency_state() const;
  void clear_consistency_state() ;
  ::beegfs::ConsistencyState consistency_state() const;
  void set_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_consistency_state() const;
  void _internal_set_consistency_state(::beegfs::ConsistencyState value);

  public:
  // @@protoc_insertion_point(class_scope:management.SetTargetStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetTargetStateRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* target_;
    int consistency_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetDefaultQuotaLimitsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.SetDefaultQuotaLimitsRequest) */ {
 public:
  inline SetDefaultQuotaLimitsRequest() : SetDefaultQuotaLimitsRequest(nullptr) {}
  ~SetDefaultQuotaLimitsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetDefaultQuotaLimitsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetDefaultQuotaLimitsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetDefaultQuotaLimitsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetDefaultQuotaLimitsRequest(const SetDefaultQuotaLimitsRequest& from) : SetDefaultQuotaLimitsRequest(nullptr, from) {}
  inline SetDefaultQuotaLimitsRequest(SetDefaultQuotaLimitsRequest&& from) noexcept
      : SetDefaultQuotaLimitsRequest(nullptr, std::move(from)) {}
  inline SetDefaultQuotaLimitsRequest& operator=(const SetDefaultQuotaLimitsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDefaultQuotaLimitsRequest& operator=(SetDefaultQuotaLimitsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDefaultQuotaLimitsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDefaultQuotaLimitsRequest* internal_default_instance() {
    return reinterpret_cast<const SetDefaultQuotaLimitsRequest*>(
        &_SetDefaultQuotaLimitsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(SetDefaultQuotaLimitsRequest& a, SetDefaultQuotaLimitsRequest& b) { a.Swap(&b); }
  inline void Swap(SetDefaultQuotaLimitsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDefaultQuotaLimitsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDefaultQuotaLimitsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetDefaultQuotaLimitsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetDefaultQuotaLimitsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetDefaultQuotaLimitsRequest& from) { SetDefaultQuotaLimitsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetDefaultQuotaLimitsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetDefaultQuotaLimitsRequest"; }

 protected:
  explicit SetDefaultQuotaLimitsRequest(::google::protobuf::Arena* arena);
  SetDefaultQuotaLimitsRequest(::google::protobuf::Arena* arena, const SetDefaultQuotaLimitsRequest& from);
  SetDefaultQuotaLimitsRequest(::google::protobuf::Arena* arena, SetDefaultQuotaLimitsRequest&& from) noexcept
      : SetDefaultQuotaLimitsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoolFieldNumber = 1,
    kUserSpaceLimitFieldNumber = 2,
    kUserInodeLimitFieldNumber = 3,
    kGroupSpaceLimitFieldNumber = 4,
    kGroupInodeLimitFieldNumber = 5,
  };
  // optional .beegfs.EntityIdSet pool = 1;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // optional int64 user_space_limit = 2;
  bool has_user_space_limit() const;
  void clear_user_space_limit() ;
  ::int64_t user_space_limit() const;
  void set_user_space_limit(::int64_t value);

  private:
  ::int64_t _internal_user_space_limit() const;
  void _internal_set_user_space_limit(::int64_t value);

  public:
  // optional int64 user_inode_limit = 3;
  bool has_user_inode_limit() const;
  void clear_user_inode_limit() ;
  ::int64_t user_inode_limit() const;
  void set_user_inode_limit(::int64_t value);

  private:
  ::int64_t _internal_user_inode_limit() const;
  void _internal_set_user_inode_limit(::int64_t value);

  public:
  // optional int64 group_space_limit = 4;
  bool has_group_space_limit() const;
  void clear_group_space_limit() ;
  ::int64_t group_space_limit() const;
  void set_group_space_limit(::int64_t value);

  private:
  ::int64_t _internal_group_space_limit() const;
  void _internal_set_group_space_limit(::int64_t value);

  public:
  // optional int64 group_inode_limit = 5;
  bool has_group_inode_limit() const;
  void clear_group_inode_limit() ;
  ::int64_t group_inode_limit() const;
  void set_group_inode_limit(::int64_t value);

  private:
  ::int64_t _internal_group_inode_limit() const;
  void _internal_set_group_inode_limit(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.SetDefaultQuotaLimitsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetDefaultQuotaLimitsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* pool_;
    ::int64_t user_space_limit_;
    ::int64_t user_inode_limit_;
    ::int64_t group_space_limit_;
    ::int64_t group_inode_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetAliasRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.SetAliasRequest) */ {
 public:
  inline SetAliasRequest() : SetAliasRequest(nullptr) {}
  ~SetAliasRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetAliasRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetAliasRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetAliasRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetAliasRequest(const SetAliasRequest& from) : SetAliasRequest(nullptr, from) {}
  inline SetAliasRequest(SetAliasRequest&& from) noexcept
      : SetAliasRequest(nullptr, std::move(from)) {}
  inline SetAliasRequest& operator=(const SetAliasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAliasRequest& operator=(SetAliasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAliasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAliasRequest* internal_default_instance() {
    return reinterpret_cast<const SetAliasRequest*>(
        &_SetAliasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SetAliasRequest& a, SetAliasRequest& b) { a.Swap(&b); }
  inline void Swap(SetAliasRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAliasRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAliasRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetAliasRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetAliasRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetAliasRequest& from) { SetAliasRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetAliasRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetAliasRequest"; }

 protected:
  explicit SetAliasRequest(::google::protobuf::Arena* arena);
  SetAliasRequest(::google::protobuf::Arena* arena, const SetAliasRequest& from);
  SetAliasRequest(::google::protobuf::Arena* arena, SetAliasRequest&& from) noexcept
      : SetAliasRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewAliasFieldNumber = 3,
    kEntityIdFieldNumber = 1,
    kEntityTypeFieldNumber = 2,
  };
  // string new_alias = 3;
  void clear_new_alias() ;
  const std::string& new_alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_alias(Arg_&& arg, Args_... args);
  std::string* mutable_new_alias();
  PROTOBUF_NODISCARD std::string* release_new_alias();
  void set_allocated_new_alias(std::string* value);

  private:
  const std::string& _internal_new_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_alias(
      const std::string& value);
  std::string* _internal_mutable_new_alias();

  public:
  // .beegfs.EntityIdSet entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id() ;
  const ::beegfs::EntityIdSet& entity_id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_entity_id();
  ::beegfs::EntityIdSet* mutable_entity_id();
  void set_allocated_entity_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_entity_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_entity_id();

  private:
  const ::beegfs::EntityIdSet& _internal_entity_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_entity_id();

  public:
  // .beegfs.EntityType entity_type = 2;
  void clear_entity_type() ;
  ::beegfs::EntityType entity_type() const;
  void set_entity_type(::beegfs::EntityType value);

  private:
  ::beegfs::EntityType _internal_entity_type() const;
  void _internal_set_entity_type(::beegfs::EntityType value);

  public:
  // @@protoc_insertion_point(class_scope:management.SetAliasRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      44, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetAliasRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_alias_;
    ::beegfs::EntityIdSet* entity_id_;
    int entity_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class QuotaInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.QuotaInfo) */ {
 public:
  inline QuotaInfo() : QuotaInfo(nullptr) {}
  ~QuotaInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QuotaInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QuotaInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QuotaInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline QuotaInfo(const QuotaInfo& from) : QuotaInfo(nullptr, from) {}
  inline QuotaInfo(QuotaInfo&& from) noexcept
      : QuotaInfo(nullptr, std::move(from)) {}
  inline QuotaInfo& operator=(const QuotaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuotaInfo& operator=(QuotaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuotaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuotaInfo* internal_default_instance() {
    return reinterpret_cast<const QuotaInfo*>(
        &_QuotaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(QuotaInfo& a, QuotaInfo& b) { a.Swap(&b); }
  inline void Swap(QuotaInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuotaInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuotaInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QuotaInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuotaInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QuotaInfo& from) { QuotaInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QuotaInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.QuotaInfo"; }

 protected:
  explicit QuotaInfo(::google::protobuf::Arena* arena);
  QuotaInfo(::google::protobuf::Arena* arena, const QuotaInfo& from);
  QuotaInfo(::google::protobuf::Arena* arena, QuotaInfo&& from) noexcept
      : QuotaInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoolFieldNumber = 3,
    kQuotaIdFieldNumber = 1,
    kIdTypeFieldNumber = 2,
    kSpaceLimitFieldNumber = 4,
    kInodeLimitFieldNumber = 5,
    kSpaceUsedFieldNumber = 6,
    kInodeUsedFieldNumber = 7,
  };
  // optional .beegfs.EntityIdSet pool = 3;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // optional uint32 quota_id = 1;
  bool has_quota_id() const;
  void clear_quota_id() ;
  ::uint32_t quota_id() const;
  void set_quota_id(::uint32_t value);

  private:
  ::uint32_t _internal_quota_id() const;
  void _internal_set_quota_id(::uint32_t value);

  public:
  // .beegfs.QuotaIdType id_type = 2;
  void clear_id_type() ;
  ::beegfs::QuotaIdType id_type() const;
  void set_id_type(::beegfs::QuotaIdType value);

  private:
  ::beegfs::QuotaIdType _internal_id_type() const;
  void _internal_set_id_type(::beegfs::QuotaIdType value);

  public:
  // optional int64 space_limit = 4;
  bool has_space_limit() const;
  void clear_space_limit() ;
  ::int64_t space_limit() const;
  void set_space_limit(::int64_t value);

  private:
  ::int64_t _internal_space_limit() const;
  void _internal_set_space_limit(::int64_t value);

  public:
  // optional int64 inode_limit = 5;
  bool has_inode_limit() const;
  void clear_inode_limit() ;
  ::int64_t inode_limit() const;
  void set_inode_limit(::int64_t value);

  private:
  ::int64_t _internal_inode_limit() const;
  void _internal_set_inode_limit(::int64_t value);

  public:
  // optional int64 space_used = 6;
  bool has_space_used() const;
  void clear_space_used() ;
  ::int64_t space_used() const;
  void set_space_used(::int64_t value);

  private:
  ::int64_t _internal_space_used() const;
  void _internal_set_space_used(::int64_t value);

  public:
  // optional int64 inode_used = 7;
  bool has_inode_used() const;
  void clear_inode_used() ;
  ::int64_t inode_used() const;
  void set_inode_used(::int64_t value);

  private:
  ::int64_t _internal_inode_used() const;
  void _internal_set_inode_used(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.QuotaInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QuotaInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* pool_;
    ::uint32_t quota_id_;
    int id_type_;
    ::int64_t space_limit_;
    ::int64_t inode_limit_;
    ::int64_t space_used_;
    ::int64_t inode_used_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetTargetsResponse_Target final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetTargetsResponse.Target) */ {
 public:
  inline GetTargetsResponse_Target() : GetTargetsResponse_Target(nullptr) {}
  ~GetTargetsResponse_Target() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTargetsResponse_Target* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTargetsResponse_Target));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTargetsResponse_Target(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTargetsResponse_Target(const GetTargetsResponse_Target& from) : GetTargetsResponse_Target(nullptr, from) {}
  inline GetTargetsResponse_Target(GetTargetsResponse_Target&& from) noexcept
      : GetTargetsResponse_Target(nullptr, std::move(from)) {}
  inline GetTargetsResponse_Target& operator=(const GetTargetsResponse_Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTargetsResponse_Target& operator=(GetTargetsResponse_Target&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTargetsResponse_Target& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTargetsResponse_Target* internal_default_instance() {
    return reinterpret_cast<const GetTargetsResponse_Target*>(
        &_GetTargetsResponse_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetTargetsResponse_Target& a, GetTargetsResponse_Target& b) { a.Swap(&b); }
  inline void Swap(GetTargetsResponse_Target* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTargetsResponse_Target* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTargetsResponse_Target* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTargetsResponse_Target>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTargetsResponse_Target& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTargetsResponse_Target& from) { GetTargetsResponse_Target::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTargetsResponse_Target* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetTargetsResponse.Target"; }

 protected:
  explicit GetTargetsResponse_Target(::google::protobuf::Arena* arena);
  GetTargetsResponse_Target(::google::protobuf::Arena* arena, const GetTargetsResponse_Target& from);
  GetTargetsResponse_Target(::google::protobuf::Arena* arena, GetTargetsResponse_Target&& from) noexcept
      : GetTargetsResponse_Target(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNodeFieldNumber = 11,
    kStoragePoolFieldNumber = 12,
    kNodeTypeFieldNumber = 2,
    kReachabilityStateFieldNumber = 3,
    kLastContactSFieldNumber = 5,
    kTotalSpaceBytesFieldNumber = 6,
    kFreeSpaceBytesFieldNumber = 7,
    kConsistencyStateFieldNumber = 4,
    kCapPoolFieldNumber = 10,
    kTotalInodesFieldNumber = 8,
    kFreeInodesFieldNumber = 9,
  };
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // .beegfs.EntityIdSet node = 11;
  bool has_node() const;
  void clear_node() ;
  const ::beegfs::EntityIdSet& node() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_node();
  ::beegfs::EntityIdSet* mutable_node();
  void set_allocated_node(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_node();

  private:
  const ::beegfs::EntityIdSet& _internal_node() const;
  ::beegfs::EntityIdSet* _internal_mutable_node();

  public:
  // optional .beegfs.EntityIdSet storage_pool = 12;
  bool has_storage_pool() const;
  void clear_storage_pool() ;
  const ::beegfs::EntityIdSet& storage_pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_storage_pool();
  ::beegfs::EntityIdSet* mutable_storage_pool();
  void set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_storage_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_storage_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_storage_pool();

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // .beegfs.ReachabilityState reachability_state = 3;
  void clear_reachability_state() ;
  ::beegfs::ReachabilityState reachability_state() const;
  void set_reachability_state(::beegfs::ReachabilityState value);

  private:
  ::beegfs::ReachabilityState _internal_reachability_state() const;
  void _internal_set_reachability_state(::beegfs::ReachabilityState value);

  public:
  // optional uint64 last_contact_s = 5;
  bool has_last_contact_s() const;
  void clear_last_contact_s() ;
  ::uint64_t last_contact_s() const;
  void set_last_contact_s(::uint64_t value);

  private:
  ::uint64_t _internal_last_contact_s() const;
  void _internal_set_last_contact_s(::uint64_t value);

  public:
  // optional uint64 total_space_bytes = 6;
  bool has_total_space_bytes() const;
  void clear_total_space_bytes() ;
  ::uint64_t total_space_bytes() const;
  void set_total_space_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_total_space_bytes() const;
  void _internal_set_total_space_bytes(::uint64_t value);

  public:
  // optional uint64 free_space_bytes = 7;
  bool has_free_space_bytes() const;
  void clear_free_space_bytes() ;
  ::uint64_t free_space_bytes() const;
  void set_free_space_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_free_space_bytes() const;
  void _internal_set_free_space_bytes(::uint64_t value);

  public:
  // .beegfs.ConsistencyState consistency_state = 4;
  void clear_consistency_state() ;
  ::beegfs::ConsistencyState consistency_state() const;
  void set_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_consistency_state() const;
  void _internal_set_consistency_state(::beegfs::ConsistencyState value);

  public:
  // .beegfs.CapacityPool cap_pool = 10;
  void clear_cap_pool() ;
  ::beegfs::CapacityPool cap_pool() const;
  void set_cap_pool(::beegfs::CapacityPool value);

  private:
  ::beegfs::CapacityPool _internal_cap_pool() const;
  void _internal_set_cap_pool(::beegfs::CapacityPool value);

  public:
  // optional uint64 total_inodes = 8;
  bool has_total_inodes() const;
  void clear_total_inodes() ;
  ::uint64_t total_inodes() const;
  void set_total_inodes(::uint64_t value);

  private:
  ::uint64_t _internal_total_inodes() const;
  void _internal_set_total_inodes(::uint64_t value);

  public:
  // optional uint64 free_inodes = 9;
  bool has_free_inodes() const;
  void clear_free_inodes() ;
  ::uint64_t free_inodes() const;
  void set_free_inodes(::uint64_t value);

  private:
  ::uint64_t _internal_free_inodes() const;
  void _internal_set_free_inodes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetTargetsResponse.Target)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTargetsResponse_Target& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* id_;
    ::beegfs::EntityIdSet* node_;
    ::beegfs::EntityIdSet* storage_pool_;
    int node_type_;
    int reachability_state_;
    ::uint64_t last_contact_s_;
    ::uint64_t total_space_bytes_;
    ::uint64_t free_space_bytes_;
    int consistency_state_;
    int cap_pool_;
    ::uint64_t total_inodes_;
    ::uint64_t free_inodes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetQuotaUsageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetQuotaUsageRequest) */ {
 public:
  inline GetQuotaUsageRequest() : GetQuotaUsageRequest(nullptr) {}
  ~GetQuotaUsageRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetQuotaUsageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetQuotaUsageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetQuotaUsageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetQuotaUsageRequest(const GetQuotaUsageRequest& from) : GetQuotaUsageRequest(nullptr, from) {}
  inline GetQuotaUsageRequest(GetQuotaUsageRequest&& from) noexcept
      : GetQuotaUsageRequest(nullptr, std::move(from)) {}
  inline GetQuotaUsageRequest& operator=(const GetQuotaUsageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuotaUsageRequest& operator=(GetQuotaUsageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuotaUsageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuotaUsageRequest* internal_default_instance() {
    return reinterpret_cast<const GetQuotaUsageRequest*>(
        &_GetQuotaUsageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(GetQuotaUsageRequest& a, GetQuotaUsageRequest& b) { a.Swap(&b); }
  inline void Swap(GetQuotaUsageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuotaUsageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuotaUsageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetQuotaUsageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetQuotaUsageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetQuotaUsageRequest& from) { GetQuotaUsageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetQuotaUsageRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetQuotaUsageRequest"; }

 protected:
  explicit GetQuotaUsageRequest(::google::protobuf::Arena* arena);
  GetQuotaUsageRequest(::google::protobuf::Arena* arena, const GetQuotaUsageRequest& from);
  GetQuotaUsageRequest(::google::protobuf::Arena* arena, GetQuotaUsageRequest&& from) noexcept
      : GetQuotaUsageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdListFieldNumber = 3,
    kGroupIdListFieldNumber = 6,
    kPoolFieldNumber = 7,
    kUserIdMinFieldNumber = 1,
    kUserIdMaxFieldNumber = 2,
    kGroupIdMinFieldNumber = 4,
    kGroupIdMaxFieldNumber = 5,
    kExceededFieldNumber = 8,
  };
  // repeated uint32 user_id_list = 3;
  int user_id_list_size() const;
  private:
  int _internal_user_id_list_size() const;

  public:
  void clear_user_id_list() ;
  ::uint32_t user_id_list(int index) const;
  void set_user_id_list(int index, ::uint32_t value);
  void add_user_id_list(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& user_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_user_id_list();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_user_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_user_id_list();

  public:
  // repeated uint32 group_id_list = 6;
  int group_id_list_size() const;
  private:
  int _internal_group_id_list_size() const;

  public:
  void clear_group_id_list() ;
  ::uint32_t group_id_list(int index) const;
  void set_group_id_list(int index, ::uint32_t value);
  void add_group_id_list(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& group_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_group_id_list();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_group_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_group_id_list();

  public:
  // optional .beegfs.EntityIdSet pool = 7;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // optional uint32 user_id_min = 1;
  bool has_user_id_min() const;
  void clear_user_id_min() ;
  ::uint32_t user_id_min() const;
  void set_user_id_min(::uint32_t value);

  private:
  ::uint32_t _internal_user_id_min() const;
  void _internal_set_user_id_min(::uint32_t value);

  public:
  // optional uint32 user_id_max = 2;
  bool has_user_id_max() const;
  void clear_user_id_max() ;
  ::uint32_t user_id_max() const;
  void set_user_id_max(::uint32_t value);

  private:
  ::uint32_t _internal_user_id_max() const;
  void _internal_set_user_id_max(::uint32_t value);

  public:
  // optional uint32 group_id_min = 4;
  bool has_group_id_min() const;
  void clear_group_id_min() ;
  ::uint32_t group_id_min() const;
  void set_group_id_min(::uint32_t value);

  private:
  ::uint32_t _internal_group_id_min() const;
  void _internal_set_group_id_min(::uint32_t value);

  public:
  // optional uint32 group_id_max = 5;
  bool has_group_id_max() const;
  void clear_group_id_max() ;
  ::uint32_t group_id_max() const;
  void set_group_id_max(::uint32_t value);

  private:
  ::uint32_t _internal_group_id_max() const;
  void _internal_set_group_id_max(::uint32_t value);

  public:
  // optional bool exceeded = 8;
  bool has_exceeded() const;
  void clear_exceeded() ;
  bool exceeded() const;
  void set_exceeded(bool value);

  private:
  bool _internal_exceeded() const;
  void _internal_set_exceeded(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetQuotaUsageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetQuotaUsageRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> user_id_list_;
    ::google::protobuf::internal::CachedSize _user_id_list_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> group_id_list_;
    ::google::protobuf::internal::CachedSize _group_id_list_cached_byte_size_;
    ::beegfs::EntityIdSet* pool_;
    ::uint32_t user_id_min_;
    ::uint32_t user_id_max_;
    ::uint32_t group_id_min_;
    ::uint32_t group_id_max_;
    bool exceeded_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetQuotaLimitsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetQuotaLimitsRequest) */ {
 public:
  inline GetQuotaLimitsRequest() : GetQuotaLimitsRequest(nullptr) {}
  ~GetQuotaLimitsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetQuotaLimitsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetQuotaLimitsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetQuotaLimitsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetQuotaLimitsRequest(const GetQuotaLimitsRequest& from) : GetQuotaLimitsRequest(nullptr, from) {}
  inline GetQuotaLimitsRequest(GetQuotaLimitsRequest&& from) noexcept
      : GetQuotaLimitsRequest(nullptr, std::move(from)) {}
  inline GetQuotaLimitsRequest& operator=(const GetQuotaLimitsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuotaLimitsRequest& operator=(GetQuotaLimitsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuotaLimitsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuotaLimitsRequest* internal_default_instance() {
    return reinterpret_cast<const GetQuotaLimitsRequest*>(
        &_GetQuotaLimitsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(GetQuotaLimitsRequest& a, GetQuotaLimitsRequest& b) { a.Swap(&b); }
  inline void Swap(GetQuotaLimitsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuotaLimitsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuotaLimitsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetQuotaLimitsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetQuotaLimitsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetQuotaLimitsRequest& from) { GetQuotaLimitsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetQuotaLimitsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetQuotaLimitsRequest"; }

 protected:
  explicit GetQuotaLimitsRequest(::google::protobuf::Arena* arena);
  GetQuotaLimitsRequest(::google::protobuf::Arena* arena, const GetQuotaLimitsRequest& from);
  GetQuotaLimitsRequest(::google::protobuf::Arena* arena, GetQuotaLimitsRequest&& from) noexcept
      : GetQuotaLimitsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdListFieldNumber = 3,
    kGroupIdListFieldNumber = 6,
    kPoolFieldNumber = 7,
    kUserIdMinFieldNumber = 1,
    kUserIdMaxFieldNumber = 2,
    kGroupIdMinFieldNumber = 4,
    kGroupIdMaxFieldNumber = 5,
  };
  // repeated uint32 user_id_list = 3;
  int user_id_list_size() const;
  private:
  int _internal_user_id_list_size() const;

  public:
  void clear_user_id_list() ;
  ::uint32_t user_id_list(int index) const;
  void set_user_id_list(int index, ::uint32_t value);
  void add_user_id_list(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& user_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_user_id_list();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_user_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_user_id_list();

  public:
  // repeated uint32 group_id_list = 6;
  int group_id_list_size() const;
  private:
  int _internal_group_id_list_size() const;

  public:
  void clear_group_id_list() ;
  ::uint32_t group_id_list(int index) const;
  void set_group_id_list(int index, ::uint32_t value);
  void add_group_id_list(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& group_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_group_id_list();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_group_id_list() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_group_id_list();

  public:
  // optional .beegfs.EntityIdSet pool = 7;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // optional uint32 user_id_min = 1;
  bool has_user_id_min() const;
  void clear_user_id_min() ;
  ::uint32_t user_id_min() const;
  void set_user_id_min(::uint32_t value);

  private:
  ::uint32_t _internal_user_id_min() const;
  void _internal_set_user_id_min(::uint32_t value);

  public:
  // optional uint32 user_id_max = 2;
  bool has_user_id_max() const;
  void clear_user_id_max() ;
  ::uint32_t user_id_max() const;
  void set_user_id_max(::uint32_t value);

  private:
  ::uint32_t _internal_user_id_max() const;
  void _internal_set_user_id_max(::uint32_t value);

  public:
  // optional uint32 group_id_min = 4;
  bool has_group_id_min() const;
  void clear_group_id_min() ;
  ::uint32_t group_id_min() const;
  void set_group_id_min(::uint32_t value);

  private:
  ::uint32_t _internal_group_id_min() const;
  void _internal_set_group_id_min(::uint32_t value);

  public:
  // optional uint32 group_id_max = 5;
  bool has_group_id_max() const;
  void clear_group_id_max() ;
  ::uint32_t group_id_max() const;
  void set_group_id_max(::uint32_t value);

  private:
  ::uint32_t _internal_group_id_max() const;
  void _internal_set_group_id_max(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetQuotaLimitsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetQuotaLimitsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> user_id_list_;
    ::google::protobuf::internal::CachedSize _user_id_list_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> group_id_list_;
    ::google::protobuf::internal::CachedSize _group_id_list_cached_byte_size_;
    ::beegfs::EntityIdSet* pool_;
    ::uint32_t user_id_min_;
    ::uint32_t user_id_max_;
    ::uint32_t group_id_min_;
    ::uint32_t group_id_max_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetPoolsResponse_StoragePool final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetPoolsResponse.StoragePool) */ {
 public:
  inline GetPoolsResponse_StoragePool() : GetPoolsResponse_StoragePool(nullptr) {}
  ~GetPoolsResponse_StoragePool() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPoolsResponse_StoragePool* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPoolsResponse_StoragePool));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPoolsResponse_StoragePool(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPoolsResponse_StoragePool(const GetPoolsResponse_StoragePool& from) : GetPoolsResponse_StoragePool(nullptr, from) {}
  inline GetPoolsResponse_StoragePool(GetPoolsResponse_StoragePool&& from) noexcept
      : GetPoolsResponse_StoragePool(nullptr, std::move(from)) {}
  inline GetPoolsResponse_StoragePool& operator=(const GetPoolsResponse_StoragePool& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoolsResponse_StoragePool& operator=(GetPoolsResponse_StoragePool&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoolsResponse_StoragePool& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoolsResponse_StoragePool* internal_default_instance() {
    return reinterpret_cast<const GetPoolsResponse_StoragePool*>(
        &_GetPoolsResponse_StoragePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(GetPoolsResponse_StoragePool& a, GetPoolsResponse_StoragePool& b) { a.Swap(&b); }
  inline void Swap(GetPoolsResponse_StoragePool* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoolsResponse_StoragePool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoolsResponse_StoragePool* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPoolsResponse_StoragePool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPoolsResponse_StoragePool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPoolsResponse_StoragePool& from) { GetPoolsResponse_StoragePool::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPoolsResponse_StoragePool* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetPoolsResponse.StoragePool"; }

 protected:
  explicit GetPoolsResponse_StoragePool(::google::protobuf::Arena* arena);
  GetPoolsResponse_StoragePool(::google::protobuf::Arena* arena, const GetPoolsResponse_StoragePool& from);
  GetPoolsResponse_StoragePool(::google::protobuf::Arena* arena, GetPoolsResponse_StoragePool&& from) noexcept
      : GetPoolsResponse_StoragePool(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 2,
    kBuddyGroupsFieldNumber = 3,
    kIdFieldNumber = 1,
    kUserSpaceLimitFieldNumber = 4,
    kUserInodeLimitFieldNumber = 5,
    kGroupSpaceLimitFieldNumber = 6,
    kGroupInodeLimitFieldNumber = 7,
  };
  // repeated .beegfs.EntityIdSet targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::beegfs::EntityIdSet* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_targets();
  public:
  const ::beegfs::EntityIdSet& targets(int index) const;
  ::beegfs::EntityIdSet* add_targets();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& targets() const;
  // repeated .beegfs.EntityIdSet buddy_groups = 3;
  int buddy_groups_size() const;
  private:
  int _internal_buddy_groups_size() const;

  public:
  void clear_buddy_groups() ;
  ::beegfs::EntityIdSet* mutable_buddy_groups(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_buddy_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_buddy_groups() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_buddy_groups();
  public:
  const ::beegfs::EntityIdSet& buddy_groups(int index) const;
  ::beegfs::EntityIdSet* add_buddy_groups();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& buddy_groups() const;
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // optional int64 user_space_limit = 4;
  bool has_user_space_limit() const;
  void clear_user_space_limit() ;
  ::int64_t user_space_limit() const;
  void set_user_space_limit(::int64_t value);

  private:
  ::int64_t _internal_user_space_limit() const;
  void _internal_set_user_space_limit(::int64_t value);

  public:
  // optional int64 user_inode_limit = 5;
  bool has_user_inode_limit() const;
  void clear_user_inode_limit() ;
  ::int64_t user_inode_limit() const;
  void set_user_inode_limit(::int64_t value);

  private:
  ::int64_t _internal_user_inode_limit() const;
  void _internal_set_user_inode_limit(::int64_t value);

  public:
  // optional int64 group_space_limit = 6;
  bool has_group_space_limit() const;
  void clear_group_space_limit() ;
  ::int64_t group_space_limit() const;
  void set_group_space_limit(::int64_t value);

  private:
  ::int64_t _internal_group_space_limit() const;
  void _internal_set_group_space_limit(::int64_t value);

  public:
  // optional int64 group_inode_limit = 7;
  bool has_group_inode_limit() const;
  void clear_group_inode_limit() ;
  ::int64_t group_inode_limit() const;
  void set_group_inode_limit(::int64_t value);

  private:
  ::int64_t _internal_group_inode_limit() const;
  void _internal_set_group_inode_limit(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetPoolsResponse.StoragePool)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPoolsResponse_StoragePool& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > targets_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > buddy_groups_;
    ::beegfs::EntityIdSet* id_;
    ::int64_t user_space_limit_;
    ::int64_t user_inode_limit_;
    ::int64_t group_space_limit_;
    ::int64_t group_inode_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResponse_Node final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetNodesResponse.Node) */ {
 public:
  inline GetNodesResponse_Node() : GetNodesResponse_Node(nullptr) {}
  ~GetNodesResponse_Node() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetNodesResponse_Node* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetNodesResponse_Node));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResponse_Node(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResponse_Node(const GetNodesResponse_Node& from) : GetNodesResponse_Node(nullptr, from) {}
  inline GetNodesResponse_Node(GetNodesResponse_Node&& from) noexcept
      : GetNodesResponse_Node(nullptr, std::move(from)) {}
  inline GetNodesResponse_Node& operator=(const GetNodesResponse_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResponse_Node& operator=(GetNodesResponse_Node&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResponse_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResponse_Node* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse_Node*>(
        &_GetNodesResponse_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GetNodesResponse_Node& a, GetNodesResponse_Node& b) { a.Swap(&b); }
  inline void Swap(GetNodesResponse_Node* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResponse_Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResponse_Node* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResponse_Node>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResponse_Node& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResponse_Node& from) { GetNodesResponse_Node::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetNodesResponse_Node* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetNodesResponse.Node"; }

 protected:
  explicit GetNodesResponse_Node(::google::protobuf::Arena* arena);
  GetNodesResponse_Node(::google::protobuf::Arena* arena, const GetNodesResponse_Node& from);
  GetNodesResponse_Node(::google::protobuf::Arena* arena, GetNodesResponse_Node&& from) noexcept
      : GetNodesResponse_Node(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Nic = GetNodesResponse_Node_Nic;

  // accessors -------------------------------------------------------
  enum : int {
    kNicsFieldNumber = 4,
    kIdFieldNumber = 1,
    kNodeTypeFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // repeated .management.GetNodesResponse.Node.Nic nics = 4;
  int nics_size() const;
  private:
  int _internal_nics_size() const;

  public:
  void clear_nics() ;
  ::management::GetNodesResponse_Node_Nic* mutable_nics(int index);
  ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>* mutable_nics();

  private:
  const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>& _internal_nics() const;
  ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>* _internal_mutable_nics();
  public:
  const ::management::GetNodesResponse_Node_Nic& nics(int index) const;
  ::management::GetNodesResponse_Node_Nic* add_nics();
  const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>& nics() const;
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetNodesResponse.Node)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetNodesResponse_Node& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::management::GetNodesResponse_Node_Nic > nics_;
    ::beegfs::EntityIdSet* id_;
    int node_type_;
    ::uint32_t port_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetBuddyGroupsResponse_BuddyGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetBuddyGroupsResponse.BuddyGroup) */ {
 public:
  inline GetBuddyGroupsResponse_BuddyGroup() : GetBuddyGroupsResponse_BuddyGroup(nullptr) {}
  ~GetBuddyGroupsResponse_BuddyGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBuddyGroupsResponse_BuddyGroup* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBuddyGroupsResponse_BuddyGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBuddyGroupsResponse_BuddyGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBuddyGroupsResponse_BuddyGroup(const GetBuddyGroupsResponse_BuddyGroup& from) : GetBuddyGroupsResponse_BuddyGroup(nullptr, from) {}
  inline GetBuddyGroupsResponse_BuddyGroup(GetBuddyGroupsResponse_BuddyGroup&& from) noexcept
      : GetBuddyGroupsResponse_BuddyGroup(nullptr, std::move(from)) {}
  inline GetBuddyGroupsResponse_BuddyGroup& operator=(const GetBuddyGroupsResponse_BuddyGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBuddyGroupsResponse_BuddyGroup& operator=(GetBuddyGroupsResponse_BuddyGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBuddyGroupsResponse_BuddyGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBuddyGroupsResponse_BuddyGroup* internal_default_instance() {
    return reinterpret_cast<const GetBuddyGroupsResponse_BuddyGroup*>(
        &_GetBuddyGroupsResponse_BuddyGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(GetBuddyGroupsResponse_BuddyGroup& a, GetBuddyGroupsResponse_BuddyGroup& b) { a.Swap(&b); }
  inline void Swap(GetBuddyGroupsResponse_BuddyGroup* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBuddyGroupsResponse_BuddyGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBuddyGroupsResponse_BuddyGroup* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetBuddyGroupsResponse_BuddyGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBuddyGroupsResponse_BuddyGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBuddyGroupsResponse_BuddyGroup& from) { GetBuddyGroupsResponse_BuddyGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetBuddyGroupsResponse_BuddyGroup* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetBuddyGroupsResponse.BuddyGroup"; }

 protected:
  explicit GetBuddyGroupsResponse_BuddyGroup(::google::protobuf::Arena* arena);
  GetBuddyGroupsResponse_BuddyGroup(::google::protobuf::Arena* arena, const GetBuddyGroupsResponse_BuddyGroup& from);
  GetBuddyGroupsResponse_BuddyGroup(::google::protobuf::Arena* arena, GetBuddyGroupsResponse_BuddyGroup&& from) noexcept
      : GetBuddyGroupsResponse_BuddyGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kPrimaryTargetFieldNumber = 3,
    kSecondaryTargetFieldNumber = 4,
    kStoragePoolFieldNumber = 7,
    kNodeTypeFieldNumber = 2,
    kPrimaryConsistencyStateFieldNumber = 5,
    kSecondaryConsistencyStateFieldNumber = 6,
  };
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // .beegfs.EntityIdSet primary_target = 3;
  bool has_primary_target() const;
  void clear_primary_target() ;
  const ::beegfs::EntityIdSet& primary_target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_primary_target();
  ::beegfs::EntityIdSet* mutable_primary_target();
  void set_allocated_primary_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_primary_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_primary_target();

  private:
  const ::beegfs::EntityIdSet& _internal_primary_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_primary_target();

  public:
  // .beegfs.EntityIdSet secondary_target = 4;
  bool has_secondary_target() const;
  void clear_secondary_target() ;
  const ::beegfs::EntityIdSet& secondary_target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_secondary_target();
  ::beegfs::EntityIdSet* mutable_secondary_target();
  void set_allocated_secondary_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_secondary_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_secondary_target();

  private:
  const ::beegfs::EntityIdSet& _internal_secondary_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_secondary_target();

  public:
  // optional .beegfs.EntityIdSet storage_pool = 7;
  bool has_storage_pool() const;
  void clear_storage_pool() ;
  const ::beegfs::EntityIdSet& storage_pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_storage_pool();
  ::beegfs::EntityIdSet* mutable_storage_pool();
  void set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_storage_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_storage_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_storage_pool();

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // .beegfs.ConsistencyState primary_consistency_state = 5;
  void clear_primary_consistency_state() ;
  ::beegfs::ConsistencyState primary_consistency_state() const;
  void set_primary_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_primary_consistency_state() const;
  void _internal_set_primary_consistency_state(::beegfs::ConsistencyState value);

  public:
  // .beegfs.ConsistencyState secondary_consistency_state = 6;
  void clear_secondary_consistency_state() ;
  ::beegfs::ConsistencyState secondary_consistency_state() const;
  void set_secondary_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_secondary_consistency_state() const;
  void _internal_set_secondary_consistency_state(::beegfs::ConsistencyState value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetBuddyGroupsResponse.BuddyGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBuddyGroupsResponse_BuddyGroup& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* id_;
    ::beegfs::EntityIdSet* primary_target_;
    ::beegfs::EntityIdSet* secondary_target_;
    ::beegfs::EntityIdSet* storage_pool_;
    int node_type_;
    int primary_consistency_state_;
    int secondary_consistency_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeleteTargetResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeleteTargetResponse) */ {
 public:
  inline DeleteTargetResponse() : DeleteTargetResponse(nullptr) {}
  ~DeleteTargetResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteTargetResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteTargetResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteTargetResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteTargetResponse(const DeleteTargetResponse& from) : DeleteTargetResponse(nullptr, from) {}
  inline DeleteTargetResponse(DeleteTargetResponse&& from) noexcept
      : DeleteTargetResponse(nullptr, std::move(from)) {}
  inline DeleteTargetResponse& operator=(const DeleteTargetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTargetResponse& operator=(DeleteTargetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTargetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTargetResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTargetResponse*>(
        &_DeleteTargetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DeleteTargetResponse& a, DeleteTargetResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteTargetResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTargetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTargetResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteTargetResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteTargetResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteTargetResponse& from) { DeleteTargetResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteTargetResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeleteTargetResponse"; }

 protected:
  explicit DeleteTargetResponse(::google::protobuf::Arena* arena);
  DeleteTargetResponse(::google::protobuf::Arena* arena, const DeleteTargetResponse& from);
  DeleteTargetResponse(::google::protobuf::Arena* arena, DeleteTargetResponse&& from) noexcept
      : DeleteTargetResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::beegfs::EntityIdSet& target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_target();
  ::beegfs::EntityIdSet* mutable_target();
  void set_allocated_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_target();

  private:
  const ::beegfs::EntityIdSet& _internal_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:management.DeleteTargetResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteTargetResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeleteTargetRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeleteTargetRequest) */ {
 public:
  inline DeleteTargetRequest() : DeleteTargetRequest(nullptr) {}
  ~DeleteTargetRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteTargetRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteTargetRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteTargetRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteTargetRequest(const DeleteTargetRequest& from) : DeleteTargetRequest(nullptr, from) {}
  inline DeleteTargetRequest(DeleteTargetRequest&& from) noexcept
      : DeleteTargetRequest(nullptr, std::move(from)) {}
  inline DeleteTargetRequest& operator=(const DeleteTargetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTargetRequest& operator=(DeleteTargetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTargetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTargetRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTargetRequest*>(
        &_DeleteTargetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(DeleteTargetRequest& a, DeleteTargetRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteTargetRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTargetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTargetRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteTargetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteTargetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteTargetRequest& from) { DeleteTargetRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteTargetRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeleteTargetRequest"; }

 protected:
  explicit DeleteTargetRequest(::google::protobuf::Arena* arena);
  DeleteTargetRequest(::google::protobuf::Arena* arena, const DeleteTargetRequest& from);
  DeleteTargetRequest(::google::protobuf::Arena* arena, DeleteTargetRequest&& from) noexcept
      : DeleteTargetRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kExecuteFieldNumber = 2,
  };
  // optional .beegfs.EntityIdSet target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::beegfs::EntityIdSet& target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_target();
  ::beegfs::EntityIdSet* mutable_target();
  void set_allocated_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_target();

  private:
  const ::beegfs::EntityIdSet& _internal_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_target();

  public:
  // optional bool execute = 2;
  bool has_execute() const;
  void clear_execute() ;
  bool execute() const;
  void set_execute(bool value);

  private:
  bool _internal_execute() const;
  void _internal_set_execute(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.DeleteTargetRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteTargetRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* target_;
    bool execute_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeletePoolResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeletePoolResponse) */ {
 public:
  inline DeletePoolResponse() : DeletePoolResponse(nullptr) {}
  ~DeletePoolResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePoolResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePoolResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePoolResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeletePoolResponse(const DeletePoolResponse& from) : DeletePoolResponse(nullptr, from) {}
  inline DeletePoolResponse(DeletePoolResponse&& from) noexcept
      : DeletePoolResponse(nullptr, std::move(from)) {}
  inline DeletePoolResponse& operator=(const DeletePoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePoolResponse& operator=(DeletePoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePoolResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePoolResponse*>(
        &_DeletePoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(DeletePoolResponse& a, DeletePoolResponse& b) { a.Swap(&b); }
  inline void Swap(DeletePoolResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePoolResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePoolResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeletePoolResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeletePoolResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeletePoolResponse& from) { DeletePoolResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeletePoolResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeletePoolResponse"; }

 protected:
  explicit DeletePoolResponse(::google::protobuf::Arena* arena);
  DeletePoolResponse(::google::protobuf::Arena* arena, const DeletePoolResponse& from);
  DeletePoolResponse(::google::protobuf::Arena* arena, DeletePoolResponse&& from) noexcept
      : DeletePoolResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoolFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet pool = 1;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // @@protoc_insertion_point(class_scope:management.DeletePoolResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeletePoolResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* pool_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeletePoolRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeletePoolRequest) */ {
 public:
  inline DeletePoolRequest() : DeletePoolRequest(nullptr) {}
  ~DeletePoolRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePoolRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePoolRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePoolRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeletePoolRequest(const DeletePoolRequest& from) : DeletePoolRequest(nullptr, from) {}
  inline DeletePoolRequest(DeletePoolRequest&& from) noexcept
      : DeletePoolRequest(nullptr, std::move(from)) {}
  inline DeletePoolRequest& operator=(const DeletePoolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePoolRequest& operator=(DeletePoolRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePoolRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePoolRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePoolRequest*>(
        &_DeletePoolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(DeletePoolRequest& a, DeletePoolRequest& b) { a.Swap(&b); }
  inline void Swap(DeletePoolRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePoolRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePoolRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeletePoolRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeletePoolRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeletePoolRequest& from) { DeletePoolRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeletePoolRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeletePoolRequest"; }

 protected:
  explicit DeletePoolRequest(::google::protobuf::Arena* arena);
  DeletePoolRequest(::google::protobuf::Arena* arena, const DeletePoolRequest& from);
  DeletePoolRequest(::google::protobuf::Arena* arena, DeletePoolRequest&& from) noexcept
      : DeletePoolRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoolFieldNumber = 1,
    kExecuteFieldNumber = 2,
  };
  // optional .beegfs.EntityIdSet pool = 1;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // optional bool execute = 2;
  bool has_execute() const;
  void clear_execute() ;
  bool execute() const;
  void set_execute(bool value);

  private:
  bool _internal_execute() const;
  void _internal_set_execute(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.DeletePoolRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeletePoolRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* pool_;
    bool execute_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeleteNodeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeleteNodeResponse) */ {
 public:
  inline DeleteNodeResponse() : DeleteNodeResponse(nullptr) {}
  ~DeleteNodeResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteNodeResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteNodeResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteNodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteNodeResponse(const DeleteNodeResponse& from) : DeleteNodeResponse(nullptr, from) {}
  inline DeleteNodeResponse(DeleteNodeResponse&& from) noexcept
      : DeleteNodeResponse(nullptr, std::move(from)) {}
  inline DeleteNodeResponse& operator=(const DeleteNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNodeResponse& operator=(DeleteNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNodeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteNodeResponse*>(
        &_DeleteNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DeleteNodeResponse& a, DeleteNodeResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteNodeResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNodeResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteNodeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteNodeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteNodeResponse& from) { DeleteNodeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteNodeResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeleteNodeResponse"; }

 protected:
  explicit DeleteNodeResponse(::google::protobuf::Arena* arena);
  DeleteNodeResponse(::google::protobuf::Arena* arena, const DeleteNodeResponse& from);
  DeleteNodeResponse(::google::protobuf::Arena* arena, DeleteNodeResponse&& from) noexcept
      : DeleteNodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet node = 1;
  bool has_node() const;
  void clear_node() ;
  const ::beegfs::EntityIdSet& node() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_node();
  ::beegfs::EntityIdSet* mutable_node();
  void set_allocated_node(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_node();

  private:
  const ::beegfs::EntityIdSet& _internal_node() const;
  ::beegfs::EntityIdSet* _internal_mutable_node();

  public:
  // @@protoc_insertion_point(class_scope:management.DeleteNodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteNodeResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* node_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeleteNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeleteNodeRequest) */ {
 public:
  inline DeleteNodeRequest() : DeleteNodeRequest(nullptr) {}
  ~DeleteNodeRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteNodeRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteNodeRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteNodeRequest(const DeleteNodeRequest& from) : DeleteNodeRequest(nullptr, from) {}
  inline DeleteNodeRequest(DeleteNodeRequest&& from) noexcept
      : DeleteNodeRequest(nullptr, std::move(from)) {}
  inline DeleteNodeRequest& operator=(const DeleteNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNodeRequest& operator=(DeleteNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNodeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNodeRequest*>(
        &_DeleteNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(DeleteNodeRequest& a, DeleteNodeRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteNodeRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteNodeRequest& from) { DeleteNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteNodeRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeleteNodeRequest"; }

 protected:
  explicit DeleteNodeRequest(::google::protobuf::Arena* arena);
  DeleteNodeRequest(::google::protobuf::Arena* arena, const DeleteNodeRequest& from);
  DeleteNodeRequest(::google::protobuf::Arena* arena, DeleteNodeRequest&& from) noexcept
      : DeleteNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 1,
    kExecuteFieldNumber = 2,
  };
  // optional .beegfs.EntityIdSet node = 1;
  bool has_node() const;
  void clear_node() ;
  const ::beegfs::EntityIdSet& node() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_node();
  ::beegfs::EntityIdSet* mutable_node();
  void set_allocated_node(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_node();

  private:
  const ::beegfs::EntityIdSet& _internal_node() const;
  ::beegfs::EntityIdSet* _internal_mutable_node();

  public:
  // optional bool execute = 2;
  bool has_execute() const;
  void clear_execute() ;
  bool execute() const;
  void set_execute(bool value);

  private:
  bool _internal_execute() const;
  void _internal_set_execute(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.DeleteNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteNodeRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* node_;
    bool execute_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeleteBuddyGroupResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeleteBuddyGroupResponse) */ {
 public:
  inline DeleteBuddyGroupResponse() : DeleteBuddyGroupResponse(nullptr) {}
  ~DeleteBuddyGroupResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteBuddyGroupResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteBuddyGroupResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteBuddyGroupResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteBuddyGroupResponse(const DeleteBuddyGroupResponse& from) : DeleteBuddyGroupResponse(nullptr, from) {}
  inline DeleteBuddyGroupResponse(DeleteBuddyGroupResponse&& from) noexcept
      : DeleteBuddyGroupResponse(nullptr, std::move(from)) {}
  inline DeleteBuddyGroupResponse& operator=(const DeleteBuddyGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBuddyGroupResponse& operator=(DeleteBuddyGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBuddyGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBuddyGroupResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteBuddyGroupResponse*>(
        &_DeleteBuddyGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(DeleteBuddyGroupResponse& a, DeleteBuddyGroupResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteBuddyGroupResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBuddyGroupResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBuddyGroupResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteBuddyGroupResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteBuddyGroupResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteBuddyGroupResponse& from) { DeleteBuddyGroupResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteBuddyGroupResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeleteBuddyGroupResponse"; }

 protected:
  explicit DeleteBuddyGroupResponse(::google::protobuf::Arena* arena);
  DeleteBuddyGroupResponse(::google::protobuf::Arena* arena, const DeleteBuddyGroupResponse& from);
  DeleteBuddyGroupResponse(::google::protobuf::Arena* arena, DeleteBuddyGroupResponse&& from) noexcept
      : DeleteBuddyGroupResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet group = 1;
  bool has_group() const;
  void clear_group() ;
  const ::beegfs::EntityIdSet& group() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_group();
  ::beegfs::EntityIdSet* mutable_group();
  void set_allocated_group(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_group(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_group();

  private:
  const ::beegfs::EntityIdSet& _internal_group() const;
  ::beegfs::EntityIdSet* _internal_mutable_group();

  public:
  // @@protoc_insertion_point(class_scope:management.DeleteBuddyGroupResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteBuddyGroupResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* group_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class DeleteBuddyGroupRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.DeleteBuddyGroupRequest) */ {
 public:
  inline DeleteBuddyGroupRequest() : DeleteBuddyGroupRequest(nullptr) {}
  ~DeleteBuddyGroupRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteBuddyGroupRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteBuddyGroupRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteBuddyGroupRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteBuddyGroupRequest(const DeleteBuddyGroupRequest& from) : DeleteBuddyGroupRequest(nullptr, from) {}
  inline DeleteBuddyGroupRequest(DeleteBuddyGroupRequest&& from) noexcept
      : DeleteBuddyGroupRequest(nullptr, std::move(from)) {}
  inline DeleteBuddyGroupRequest& operator=(const DeleteBuddyGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBuddyGroupRequest& operator=(DeleteBuddyGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBuddyGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBuddyGroupRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteBuddyGroupRequest*>(
        &_DeleteBuddyGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(DeleteBuddyGroupRequest& a, DeleteBuddyGroupRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteBuddyGroupRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBuddyGroupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBuddyGroupRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteBuddyGroupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteBuddyGroupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteBuddyGroupRequest& from) { DeleteBuddyGroupRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteBuddyGroupRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.DeleteBuddyGroupRequest"; }

 protected:
  explicit DeleteBuddyGroupRequest(::google::protobuf::Arena* arena);
  DeleteBuddyGroupRequest(::google::protobuf::Arena* arena, const DeleteBuddyGroupRequest& from);
  DeleteBuddyGroupRequest(::google::protobuf::Arena* arena, DeleteBuddyGroupRequest&& from) noexcept
      : DeleteBuddyGroupRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupFieldNumber = 1,
    kExecuteFieldNumber = 2,
  };
  // optional .beegfs.EntityIdSet group = 1;
  bool has_group() const;
  void clear_group() ;
  const ::beegfs::EntityIdSet& group() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_group();
  ::beegfs::EntityIdSet* mutable_group();
  void set_allocated_group(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_group(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_group();

  private:
  const ::beegfs::EntityIdSet& _internal_group() const;
  ::beegfs::EntityIdSet* _internal_mutable_group();

  public:
  // optional bool execute = 2;
  bool has_execute() const;
  void clear_execute() ;
  bool execute() const;
  void set_execute(bool value);

  private:
  bool _internal_execute() const;
  void _internal_set_execute(bool value);

  public:
  // @@protoc_insertion_point(class_scope:management.DeleteBuddyGroupRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteBuddyGroupRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* group_;
    bool execute_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class CreatePoolResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.CreatePoolResponse) */ {
 public:
  inline CreatePoolResponse() : CreatePoolResponse(nullptr) {}
  ~CreatePoolResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreatePoolResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreatePoolResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreatePoolResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreatePoolResponse(const CreatePoolResponse& from) : CreatePoolResponse(nullptr, from) {}
  inline CreatePoolResponse(CreatePoolResponse&& from) noexcept
      : CreatePoolResponse(nullptr, std::move(from)) {}
  inline CreatePoolResponse& operator=(const CreatePoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePoolResponse& operator=(CreatePoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePoolResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePoolResponse*>(
        &_CreatePoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(CreatePoolResponse& a, CreatePoolResponse& b) { a.Swap(&b); }
  inline void Swap(CreatePoolResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePoolResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePoolResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreatePoolResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreatePoolResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreatePoolResponse& from) { CreatePoolResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreatePoolResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.CreatePoolResponse"; }

 protected:
  explicit CreatePoolResponse(::google::protobuf::Arena* arena);
  CreatePoolResponse(::google::protobuf::Arena* arena, const CreatePoolResponse& from);
  CreatePoolResponse(::google::protobuf::Arena* arena, CreatePoolResponse&& from) noexcept
      : CreatePoolResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoolFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet pool = 1;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // @@protoc_insertion_point(class_scope:management.CreatePoolResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreatePoolResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* pool_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class CreatePoolRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.CreatePoolRequest) */ {
 public:
  inline CreatePoolRequest() : CreatePoolRequest(nullptr) {}
  ~CreatePoolRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreatePoolRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreatePoolRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreatePoolRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreatePoolRequest(const CreatePoolRequest& from) : CreatePoolRequest(nullptr, from) {}
  inline CreatePoolRequest(CreatePoolRequest&& from) noexcept
      : CreatePoolRequest(nullptr, std::move(from)) {}
  inline CreatePoolRequest& operator=(const CreatePoolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePoolRequest& operator=(CreatePoolRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePoolRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePoolRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePoolRequest*>(
        &_CreatePoolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(CreatePoolRequest& a, CreatePoolRequest& b) { a.Swap(&b); }
  inline void Swap(CreatePoolRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePoolRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePoolRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreatePoolRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreatePoolRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreatePoolRequest& from) { CreatePoolRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreatePoolRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.CreatePoolRequest"; }

 protected:
  explicit CreatePoolRequest(::google::protobuf::Arena* arena);
  CreatePoolRequest(::google::protobuf::Arena* arena, const CreatePoolRequest& from);
  CreatePoolRequest(::google::protobuf::Arena* arena, CreatePoolRequest&& from) noexcept
      : CreatePoolRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 4,
    kBuddyGroupsFieldNumber = 5,
    kAliasFieldNumber = 3,
    kNodeTypeFieldNumber = 1,
    kNumIdFieldNumber = 2,
  };
  // repeated .beegfs.EntityIdSet targets = 4;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::beegfs::EntityIdSet* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_targets();
  public:
  const ::beegfs::EntityIdSet& targets(int index) const;
  ::beegfs::EntityIdSet* add_targets();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& targets() const;
  // repeated .beegfs.EntityIdSet buddy_groups = 5;
  int buddy_groups_size() const;
  private:
  int _internal_buddy_groups_size() const;

  public:
  void clear_buddy_groups() ;
  ::beegfs::EntityIdSet* mutable_buddy_groups(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_buddy_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_buddy_groups() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_buddy_groups();
  public:
  const ::beegfs::EntityIdSet& buddy_groups(int index) const;
  ::beegfs::EntityIdSet* add_buddy_groups();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& buddy_groups() const;
  // optional string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional .beegfs.NodeType node_type = 1;
  bool has_node_type() const;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // optional uint32 num_id = 2;
  bool has_num_id() const;
  void clear_num_id() ;
  ::uint32_t num_id() const;
  void set_num_id(::uint32_t value);

  private:
  ::uint32_t _internal_num_id() const;
  void _internal_set_num_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.CreatePoolRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreatePoolRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > targets_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > buddy_groups_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    int node_type_;
    ::uint32_t num_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class CreateBuddyGroupResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.CreateBuddyGroupResponse) */ {
 public:
  inline CreateBuddyGroupResponse() : CreateBuddyGroupResponse(nullptr) {}
  ~CreateBuddyGroupResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateBuddyGroupResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateBuddyGroupResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBuddyGroupResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateBuddyGroupResponse(const CreateBuddyGroupResponse& from) : CreateBuddyGroupResponse(nullptr, from) {}
  inline CreateBuddyGroupResponse(CreateBuddyGroupResponse&& from) noexcept
      : CreateBuddyGroupResponse(nullptr, std::move(from)) {}
  inline CreateBuddyGroupResponse& operator=(const CreateBuddyGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBuddyGroupResponse& operator=(CreateBuddyGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBuddyGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBuddyGroupResponse* internal_default_instance() {
    return reinterpret_cast<const CreateBuddyGroupResponse*>(
        &_CreateBuddyGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(CreateBuddyGroupResponse& a, CreateBuddyGroupResponse& b) { a.Swap(&b); }
  inline void Swap(CreateBuddyGroupResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBuddyGroupResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBuddyGroupResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateBuddyGroupResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBuddyGroupResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateBuddyGroupResponse& from) { CreateBuddyGroupResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateBuddyGroupResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.CreateBuddyGroupResponse"; }

 protected:
  explicit CreateBuddyGroupResponse(::google::protobuf::Arena* arena);
  CreateBuddyGroupResponse(::google::protobuf::Arena* arena, const CreateBuddyGroupResponse& from);
  CreateBuddyGroupResponse(::google::protobuf::Arena* arena, CreateBuddyGroupResponse&& from) noexcept
      : CreateBuddyGroupResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet group = 1;
  bool has_group() const;
  void clear_group() ;
  const ::beegfs::EntityIdSet& group() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_group();
  ::beegfs::EntityIdSet* mutable_group();
  void set_allocated_group(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_group(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_group();

  private:
  const ::beegfs::EntityIdSet& _internal_group() const;
  ::beegfs::EntityIdSet* _internal_mutable_group();

  public:
  // @@protoc_insertion_point(class_scope:management.CreateBuddyGroupResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateBuddyGroupResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* group_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class CreateBuddyGroupRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.CreateBuddyGroupRequest) */ {
 public:
  inline CreateBuddyGroupRequest() : CreateBuddyGroupRequest(nullptr) {}
  ~CreateBuddyGroupRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateBuddyGroupRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateBuddyGroupRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBuddyGroupRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateBuddyGroupRequest(const CreateBuddyGroupRequest& from) : CreateBuddyGroupRequest(nullptr, from) {}
  inline CreateBuddyGroupRequest(CreateBuddyGroupRequest&& from) noexcept
      : CreateBuddyGroupRequest(nullptr, std::move(from)) {}
  inline CreateBuddyGroupRequest& operator=(const CreateBuddyGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBuddyGroupRequest& operator=(CreateBuddyGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBuddyGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBuddyGroupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateBuddyGroupRequest*>(
        &_CreateBuddyGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(CreateBuddyGroupRequest& a, CreateBuddyGroupRequest& b) { a.Swap(&b); }
  inline void Swap(CreateBuddyGroupRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBuddyGroupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBuddyGroupRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateBuddyGroupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBuddyGroupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateBuddyGroupRequest& from) { CreateBuddyGroupRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateBuddyGroupRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.CreateBuddyGroupRequest"; }

 protected:
  explicit CreateBuddyGroupRequest(::google::protobuf::Arena* arena);
  CreateBuddyGroupRequest(::google::protobuf::Arena* arena, const CreateBuddyGroupRequest& from);
  CreateBuddyGroupRequest(::google::protobuf::Arena* arena, CreateBuddyGroupRequest&& from) noexcept
      : CreateBuddyGroupRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAliasFieldNumber = 3,
    kPrimaryTargetFieldNumber = 4,
    kSecondaryTargetFieldNumber = 5,
    kNodeTypeFieldNumber = 1,
    kNumIdFieldNumber = 2,
  };
  // optional string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional .beegfs.EntityIdSet primary_target = 4;
  bool has_primary_target() const;
  void clear_primary_target() ;
  const ::beegfs::EntityIdSet& primary_target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_primary_target();
  ::beegfs::EntityIdSet* mutable_primary_target();
  void set_allocated_primary_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_primary_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_primary_target();

  private:
  const ::beegfs::EntityIdSet& _internal_primary_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_primary_target();

  public:
  // optional .beegfs.EntityIdSet secondary_target = 5;
  bool has_secondary_target() const;
  void clear_secondary_target() ;
  const ::beegfs::EntityIdSet& secondary_target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_secondary_target();
  ::beegfs::EntityIdSet* mutable_secondary_target();
  void set_allocated_secondary_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_secondary_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_secondary_target();

  private:
  const ::beegfs::EntityIdSet& _internal_secondary_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_secondary_target();

  public:
  // optional .beegfs.NodeType node_type = 1;
  bool has_node_type() const;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // optional uint32 num_id = 2;
  bool has_num_id() const;
  void clear_num_id() ;
  ::uint32_t num_id() const;
  void set_num_id(::uint32_t value);

  private:
  ::uint32_t _internal_num_id() const;
  void _internal_set_num_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.CreateBuddyGroupRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateBuddyGroupRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::beegfs::EntityIdSet* primary_target_;
    ::beegfs::EntityIdSet* secondary_target_;
    int node_type_;
    ::uint32_t num_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class AssignPoolResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.AssignPoolResponse) */ {
 public:
  inline AssignPoolResponse() : AssignPoolResponse(nullptr) {}
  ~AssignPoolResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AssignPoolResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AssignPoolResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssignPoolResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssignPoolResponse(const AssignPoolResponse& from) : AssignPoolResponse(nullptr, from) {}
  inline AssignPoolResponse(AssignPoolResponse&& from) noexcept
      : AssignPoolResponse(nullptr, std::move(from)) {}
  inline AssignPoolResponse& operator=(const AssignPoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignPoolResponse& operator=(AssignPoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignPoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignPoolResponse* internal_default_instance() {
    return reinterpret_cast<const AssignPoolResponse*>(
        &_AssignPoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(AssignPoolResponse& a, AssignPoolResponse& b) { a.Swap(&b); }
  inline void Swap(AssignPoolResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignPoolResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignPoolResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AssignPoolResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssignPoolResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssignPoolResponse& from) { AssignPoolResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AssignPoolResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.AssignPoolResponse"; }

 protected:
  explicit AssignPoolResponse(::google::protobuf::Arena* arena);
  AssignPoolResponse(::google::protobuf::Arena* arena, const AssignPoolResponse& from);
  AssignPoolResponse(::google::protobuf::Arena* arena, AssignPoolResponse&& from) noexcept
      : AssignPoolResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoolFieldNumber = 1,
  };
  // optional .beegfs.EntityIdSet pool = 1;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // @@protoc_insertion_point(class_scope:management.AssignPoolResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssignPoolResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* pool_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class AssignPoolRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.AssignPoolRequest) */ {
 public:
  inline AssignPoolRequest() : AssignPoolRequest(nullptr) {}
  ~AssignPoolRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AssignPoolRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AssignPoolRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssignPoolRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssignPoolRequest(const AssignPoolRequest& from) : AssignPoolRequest(nullptr, from) {}
  inline AssignPoolRequest(AssignPoolRequest&& from) noexcept
      : AssignPoolRequest(nullptr, std::move(from)) {}
  inline AssignPoolRequest& operator=(const AssignPoolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignPoolRequest& operator=(AssignPoolRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignPoolRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignPoolRequest* internal_default_instance() {
    return reinterpret_cast<const AssignPoolRequest*>(
        &_AssignPoolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(AssignPoolRequest& a, AssignPoolRequest& b) { a.Swap(&b); }
  inline void Swap(AssignPoolRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignPoolRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignPoolRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AssignPoolRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssignPoolRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssignPoolRequest& from) { AssignPoolRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AssignPoolRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.AssignPoolRequest"; }

 protected:
  explicit AssignPoolRequest(::google::protobuf::Arena* arena);
  AssignPoolRequest(::google::protobuf::Arena* arena, const AssignPoolRequest& from);
  AssignPoolRequest(::google::protobuf::Arena* arena, AssignPoolRequest&& from) noexcept
      : AssignPoolRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 2,
    kBuddyGroupsFieldNumber = 3,
    kPoolFieldNumber = 1,
  };
  // repeated .beegfs.EntityIdSet targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::beegfs::EntityIdSet* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_targets();
  public:
  const ::beegfs::EntityIdSet& targets(int index) const;
  ::beegfs::EntityIdSet* add_targets();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& targets() const;
  // repeated .beegfs.EntityIdSet buddy_groups = 3;
  int buddy_groups_size() const;
  private:
  int _internal_buddy_groups_size() const;

  public:
  void clear_buddy_groups() ;
  ::beegfs::EntityIdSet* mutable_buddy_groups(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_buddy_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_buddy_groups() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_buddy_groups();
  public:
  const ::beegfs::EntityIdSet& buddy_groups(int index) const;
  ::beegfs::EntityIdSet* add_buddy_groups();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& buddy_groups() const;
  // optional .beegfs.EntityIdSet pool = 1;
  bool has_pool() const;
  void clear_pool() ;
  const ::beegfs::EntityIdSet& pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_pool();
  ::beegfs::EntityIdSet* mutable_pool();
  void set_allocated_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_pool();

  public:
  // @@protoc_insertion_point(class_scope:management.AssignPoolRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssignPoolRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > targets_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > buddy_groups_;
    ::beegfs::EntityIdSet* pool_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class SetQuotaLimitsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.SetQuotaLimitsRequest) */ {
 public:
  inline SetQuotaLimitsRequest() : SetQuotaLimitsRequest(nullptr) {}
  ~SetQuotaLimitsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetQuotaLimitsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetQuotaLimitsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetQuotaLimitsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetQuotaLimitsRequest(const SetQuotaLimitsRequest& from) : SetQuotaLimitsRequest(nullptr, from) {}
  inline SetQuotaLimitsRequest(SetQuotaLimitsRequest&& from) noexcept
      : SetQuotaLimitsRequest(nullptr, std::move(from)) {}
  inline SetQuotaLimitsRequest& operator=(const SetQuotaLimitsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetQuotaLimitsRequest& operator=(SetQuotaLimitsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetQuotaLimitsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetQuotaLimitsRequest* internal_default_instance() {
    return reinterpret_cast<const SetQuotaLimitsRequest*>(
        &_SetQuotaLimitsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(SetQuotaLimitsRequest& a, SetQuotaLimitsRequest& b) { a.Swap(&b); }
  inline void Swap(SetQuotaLimitsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetQuotaLimitsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetQuotaLimitsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetQuotaLimitsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetQuotaLimitsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetQuotaLimitsRequest& from) { SetQuotaLimitsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetQuotaLimitsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.SetQuotaLimitsRequest"; }

 protected:
  explicit SetQuotaLimitsRequest(::google::protobuf::Arena* arena);
  SetQuotaLimitsRequest(::google::protobuf::Arena* arena, const SetQuotaLimitsRequest& from);
  SetQuotaLimitsRequest(::google::protobuf::Arena* arena, SetQuotaLimitsRequest&& from) noexcept
      : SetQuotaLimitsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLimitsFieldNumber = 1,
  };
  // repeated .management.QuotaInfo limits = 1;
  int limits_size() const;
  private:
  int _internal_limits_size() const;

  public:
  void clear_limits() ;
  ::management::QuotaInfo* mutable_limits(int index);
  ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>* mutable_limits();

  private:
  const ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>& _internal_limits() const;
  ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>* _internal_mutable_limits();
  public:
  const ::management::QuotaInfo& limits(int index) const;
  ::management::QuotaInfo* add_limits();
  const ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>& limits() const;
  // @@protoc_insertion_point(class_scope:management.SetQuotaLimitsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetQuotaLimitsRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::management::QuotaInfo > limits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetTargetsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetTargetsResponse) */ {
 public:
  inline GetTargetsResponse() : GetTargetsResponse(nullptr) {}
  ~GetTargetsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTargetsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTargetsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTargetsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTargetsResponse(const GetTargetsResponse& from) : GetTargetsResponse(nullptr, from) {}
  inline GetTargetsResponse(GetTargetsResponse&& from) noexcept
      : GetTargetsResponse(nullptr, std::move(from)) {}
  inline GetTargetsResponse& operator=(const GetTargetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTargetsResponse& operator=(GetTargetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTargetsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTargetsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTargetsResponse*>(
        &_GetTargetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GetTargetsResponse& a, GetTargetsResponse& b) { a.Swap(&b); }
  inline void Swap(GetTargetsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTargetsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTargetsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTargetsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTargetsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTargetsResponse& from) { GetTargetsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTargetsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetTargetsResponse"; }

 protected:
  explicit GetTargetsResponse(::google::protobuf::Arena* arena);
  GetTargetsResponse(::google::protobuf::Arena* arena, const GetTargetsResponse& from);
  GetTargetsResponse(::google::protobuf::Arena* arena, GetTargetsResponse&& from) noexcept
      : GetTargetsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Target = GetTargetsResponse_Target;

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .management.GetTargetsResponse.Target targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::management::GetTargetsResponse_Target* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>* _internal_mutable_targets();
  public:
  const ::management::GetTargetsResponse_Target& targets(int index) const;
  ::management::GetTargetsResponse_Target* add_targets();
  const ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>& targets() const;
  // @@protoc_insertion_point(class_scope:management.GetTargetsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTargetsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::management::GetTargetsResponse_Target > targets_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetQuotaUsageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetQuotaUsageResponse) */ {
 public:
  inline GetQuotaUsageResponse() : GetQuotaUsageResponse(nullptr) {}
  ~GetQuotaUsageResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetQuotaUsageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetQuotaUsageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetQuotaUsageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetQuotaUsageResponse(const GetQuotaUsageResponse& from) : GetQuotaUsageResponse(nullptr, from) {}
  inline GetQuotaUsageResponse(GetQuotaUsageResponse&& from) noexcept
      : GetQuotaUsageResponse(nullptr, std::move(from)) {}
  inline GetQuotaUsageResponse& operator=(const GetQuotaUsageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuotaUsageResponse& operator=(GetQuotaUsageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuotaUsageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuotaUsageResponse* internal_default_instance() {
    return reinterpret_cast<const GetQuotaUsageResponse*>(
        &_GetQuotaUsageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(GetQuotaUsageResponse& a, GetQuotaUsageResponse& b) { a.Swap(&b); }
  inline void Swap(GetQuotaUsageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuotaUsageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuotaUsageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetQuotaUsageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetQuotaUsageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetQuotaUsageResponse& from) { GetQuotaUsageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetQuotaUsageResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetQuotaUsageResponse"; }

 protected:
  explicit GetQuotaUsageResponse(::google::protobuf::Arena* arena);
  GetQuotaUsageResponse(::google::protobuf::Arena* arena, const GetQuotaUsageResponse& from);
  GetQuotaUsageResponse(::google::protobuf::Arena* arena, GetQuotaUsageResponse&& from) noexcept
      : GetQuotaUsageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntryFieldNumber = 1,
    kRefreshPeriodSFieldNumber = 2,
  };
  // optional .management.QuotaInfo entry = 1;
  bool has_entry() const;
  void clear_entry() ;
  const ::management::QuotaInfo& entry() const;
  PROTOBUF_NODISCARD ::management::QuotaInfo* release_entry();
  ::management::QuotaInfo* mutable_entry();
  void set_allocated_entry(::management::QuotaInfo* value);
  void unsafe_arena_set_allocated_entry(::management::QuotaInfo* value);
  ::management::QuotaInfo* unsafe_arena_release_entry();

  private:
  const ::management::QuotaInfo& _internal_entry() const;
  ::management::QuotaInfo* _internal_mutable_entry();

  public:
  // optional uint64 refresh_period_s = 2;
  bool has_refresh_period_s() const;
  void clear_refresh_period_s() ;
  ::uint64_t refresh_period_s() const;
  void set_refresh_period_s(::uint64_t value);

  private:
  ::uint64_t _internal_refresh_period_s() const;
  void _internal_set_refresh_period_s(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:management.GetQuotaUsageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetQuotaUsageResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::management::QuotaInfo* entry_;
    ::uint64_t refresh_period_s_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetQuotaLimitsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetQuotaLimitsResponse) */ {
 public:
  inline GetQuotaLimitsResponse() : GetQuotaLimitsResponse(nullptr) {}
  ~GetQuotaLimitsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetQuotaLimitsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetQuotaLimitsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetQuotaLimitsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetQuotaLimitsResponse(const GetQuotaLimitsResponse& from) : GetQuotaLimitsResponse(nullptr, from) {}
  inline GetQuotaLimitsResponse(GetQuotaLimitsResponse&& from) noexcept
      : GetQuotaLimitsResponse(nullptr, std::move(from)) {}
  inline GetQuotaLimitsResponse& operator=(const GetQuotaLimitsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuotaLimitsResponse& operator=(GetQuotaLimitsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuotaLimitsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuotaLimitsResponse* internal_default_instance() {
    return reinterpret_cast<const GetQuotaLimitsResponse*>(
        &_GetQuotaLimitsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(GetQuotaLimitsResponse& a, GetQuotaLimitsResponse& b) { a.Swap(&b); }
  inline void Swap(GetQuotaLimitsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuotaLimitsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuotaLimitsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetQuotaLimitsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetQuotaLimitsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetQuotaLimitsResponse& from) { GetQuotaLimitsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetQuotaLimitsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetQuotaLimitsResponse"; }

 protected:
  explicit GetQuotaLimitsResponse(::google::protobuf::Arena* arena);
  GetQuotaLimitsResponse(::google::protobuf::Arena* arena, const GetQuotaLimitsResponse& from);
  GetQuotaLimitsResponse(::google::protobuf::Arena* arena, GetQuotaLimitsResponse&& from) noexcept
      : GetQuotaLimitsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLimitsFieldNumber = 1,
  };
  // optional .management.QuotaInfo limits = 1;
  bool has_limits() const;
  void clear_limits() ;
  const ::management::QuotaInfo& limits() const;
  PROTOBUF_NODISCARD ::management::QuotaInfo* release_limits();
  ::management::QuotaInfo* mutable_limits();
  void set_allocated_limits(::management::QuotaInfo* value);
  void unsafe_arena_set_allocated_limits(::management::QuotaInfo* value);
  ::management::QuotaInfo* unsafe_arena_release_limits();

  private:
  const ::management::QuotaInfo& _internal_limits() const;
  ::management::QuotaInfo* _internal_mutable_limits();

  public:
  // @@protoc_insertion_point(class_scope:management.GetQuotaLimitsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetQuotaLimitsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::management::QuotaInfo* limits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetPoolsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetPoolsResponse) */ {
 public:
  inline GetPoolsResponse() : GetPoolsResponse(nullptr) {}
  ~GetPoolsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPoolsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPoolsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPoolsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPoolsResponse(const GetPoolsResponse& from) : GetPoolsResponse(nullptr, from) {}
  inline GetPoolsResponse(GetPoolsResponse&& from) noexcept
      : GetPoolsResponse(nullptr, std::move(from)) {}
  inline GetPoolsResponse& operator=(const GetPoolsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoolsResponse& operator=(GetPoolsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoolsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoolsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPoolsResponse*>(
        &_GetPoolsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(GetPoolsResponse& a, GetPoolsResponse& b) { a.Swap(&b); }
  inline void Swap(GetPoolsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoolsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoolsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPoolsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPoolsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPoolsResponse& from) { GetPoolsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPoolsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetPoolsResponse"; }

 protected:
  explicit GetPoolsResponse(::google::protobuf::Arena* arena);
  GetPoolsResponse(::google::protobuf::Arena* arena, const GetPoolsResponse& from);
  GetPoolsResponse(::google::protobuf::Arena* arena, GetPoolsResponse&& from) noexcept
      : GetPoolsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StoragePool = GetPoolsResponse_StoragePool;

  // accessors -------------------------------------------------------
  enum : int {
    kPoolsFieldNumber = 1,
  };
  // repeated .management.GetPoolsResponse.StoragePool pools = 1;
  int pools_size() const;
  private:
  int _internal_pools_size() const;

  public:
  void clear_pools() ;
  ::management::GetPoolsResponse_StoragePool* mutable_pools(int index);
  ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>* mutable_pools();

  private:
  const ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>& _internal_pools() const;
  ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>* _internal_mutable_pools();
  public:
  const ::management::GetPoolsResponse_StoragePool& pools(int index) const;
  ::management::GetPoolsResponse_StoragePool* add_pools();
  const ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>& pools() const;
  // @@protoc_insertion_point(class_scope:management.GetPoolsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPoolsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::management::GetPoolsResponse_StoragePool > pools_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetNodesResponse) */ {
 public:
  inline GetNodesResponse() : GetNodesResponse(nullptr) {}
  ~GetNodesResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetNodesResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetNodesResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResponse(const GetNodesResponse& from) : GetNodesResponse(nullptr, from) {}
  inline GetNodesResponse(GetNodesResponse&& from) noexcept
      : GetNodesResponse(nullptr, std::move(from)) {}
  inline GetNodesResponse& operator=(const GetNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResponse& operator=(GetNodesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse*>(
        &_GetNodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GetNodesResponse& a, GetNodesResponse& b) { a.Swap(&b); }
  inline void Swap(GetNodesResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResponse& from) { GetNodesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetNodesResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetNodesResponse"; }

 protected:
  explicit GetNodesResponse(::google::protobuf::Arena* arena);
  GetNodesResponse(::google::protobuf::Arena* arena, const GetNodesResponse& from);
  GetNodesResponse(::google::protobuf::Arena* arena, GetNodesResponse&& from) noexcept
      : GetNodesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Node = GetNodesResponse_Node;

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 1,
    kFsUuidFieldNumber = 3,
    kMetaRootNodeFieldNumber = 2,
  };
  // repeated .management.GetNodesResponse.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::management::GetNodesResponse_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>* mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>* _internal_mutable_nodes();
  public:
  const ::management::GetNodesResponse_Node& nodes(int index) const;
  ::management::GetNodesResponse_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>& nodes() const;
  // optional string fs_uuid = 3;
  bool has_fs_uuid() const;
  void clear_fs_uuid() ;
  const std::string& fs_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fs_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_fs_uuid();
  PROTOBUF_NODISCARD std::string* release_fs_uuid();
  void set_allocated_fs_uuid(std::string* value);

  private:
  const std::string& _internal_fs_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fs_uuid(
      const std::string& value);
  std::string* _internal_mutable_fs_uuid();

  public:
  // optional .beegfs.EntityIdSet meta_root_node = 2;
  bool has_meta_root_node() const;
  void clear_meta_root_node() ;
  const ::beegfs::EntityIdSet& meta_root_node() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_meta_root_node();
  ::beegfs::EntityIdSet* mutable_meta_root_node();
  void set_allocated_meta_root_node(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_meta_root_node(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_meta_root_node();

  private:
  const ::beegfs::EntityIdSet& _internal_meta_root_node() const;
  ::beegfs::EntityIdSet* _internal_mutable_meta_root_node();

  public:
  // @@protoc_insertion_point(class_scope:management.GetNodesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetNodesResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::management::GetNodesResponse_Node > nodes_;
    ::google::protobuf::internal::ArenaStringPtr fs_uuid_;
    ::beegfs::EntityIdSet* meta_root_node_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetLicenseResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetLicenseResponse) */ {
 public:
  inline GetLicenseResponse() : GetLicenseResponse(nullptr) {}
  ~GetLicenseResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetLicenseResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetLicenseResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetLicenseResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetLicenseResponse(const GetLicenseResponse& from) : GetLicenseResponse(nullptr, from) {}
  inline GetLicenseResponse(GetLicenseResponse&& from) noexcept
      : GetLicenseResponse(nullptr, std::move(from)) {}
  inline GetLicenseResponse& operator=(const GetLicenseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLicenseResponse& operator=(GetLicenseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLicenseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLicenseResponse* internal_default_instance() {
    return reinterpret_cast<const GetLicenseResponse*>(
        &_GetLicenseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(GetLicenseResponse& a, GetLicenseResponse& b) { a.Swap(&b); }
  inline void Swap(GetLicenseResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLicenseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLicenseResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetLicenseResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLicenseResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetLicenseResponse& from) { GetLicenseResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetLicenseResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetLicenseResponse"; }

 protected:
  explicit GetLicenseResponse(::google::protobuf::Arena* arena);
  GetLicenseResponse(::google::protobuf::Arena* arena, const GetLicenseResponse& from);
  GetLicenseResponse(::google::protobuf::Arena* arena, GetLicenseResponse&& from) noexcept
      : GetLicenseResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCertDataFieldNumber = 1,
  };
  // optional .license.GetCertDataResult cert_data = 1;
  bool has_cert_data() const;
  void clear_cert_data() ;
  const ::license::GetCertDataResult& cert_data() const;
  PROTOBUF_NODISCARD ::license::GetCertDataResult* release_cert_data();
  ::license::GetCertDataResult* mutable_cert_data();
  void set_allocated_cert_data(::license::GetCertDataResult* value);
  void unsafe_arena_set_allocated_cert_data(::license::GetCertDataResult* value);
  ::license::GetCertDataResult* unsafe_arena_release_cert_data();

  private:
  const ::license::GetCertDataResult& _internal_cert_data() const;
  ::license::GetCertDataResult* _internal_mutable_cert_data();

  public:
  // @@protoc_insertion_point(class_scope:management.GetLicenseResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetLicenseResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::license::GetCertDataResult* cert_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};
// -------------------------------------------------------------------

class GetBuddyGroupsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:management.GetBuddyGroupsResponse) */ {
 public:
  inline GetBuddyGroupsResponse() : GetBuddyGroupsResponse(nullptr) {}
  ~GetBuddyGroupsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBuddyGroupsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBuddyGroupsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBuddyGroupsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBuddyGroupsResponse(const GetBuddyGroupsResponse& from) : GetBuddyGroupsResponse(nullptr, from) {}
  inline GetBuddyGroupsResponse(GetBuddyGroupsResponse&& from) noexcept
      : GetBuddyGroupsResponse(nullptr, std::move(from)) {}
  inline GetBuddyGroupsResponse& operator=(const GetBuddyGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBuddyGroupsResponse& operator=(GetBuddyGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBuddyGroupsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBuddyGroupsResponse* internal_default_instance() {
    return reinterpret_cast<const GetBuddyGroupsResponse*>(
        &_GetBuddyGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(GetBuddyGroupsResponse& a, GetBuddyGroupsResponse& b) { a.Swap(&b); }
  inline void Swap(GetBuddyGroupsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBuddyGroupsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBuddyGroupsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetBuddyGroupsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBuddyGroupsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBuddyGroupsResponse& from) { GetBuddyGroupsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetBuddyGroupsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "management.GetBuddyGroupsResponse"; }

 protected:
  explicit GetBuddyGroupsResponse(::google::protobuf::Arena* arena);
  GetBuddyGroupsResponse(::google::protobuf::Arena* arena, const GetBuddyGroupsResponse& from);
  GetBuddyGroupsResponse(::google::protobuf::Arena* arena, GetBuddyGroupsResponse&& from) noexcept
      : GetBuddyGroupsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BuddyGroup = GetBuddyGroupsResponse_BuddyGroup;

  // accessors -------------------------------------------------------
  enum : int {
    kBuddyGroupsFieldNumber = 1,
  };
  // repeated .management.GetBuddyGroupsResponse.BuddyGroup buddy_groups = 1;
  int buddy_groups_size() const;
  private:
  int _internal_buddy_groups_size() const;

  public:
  void clear_buddy_groups() ;
  ::management::GetBuddyGroupsResponse_BuddyGroup* mutable_buddy_groups(int index);
  ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>* mutable_buddy_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>& _internal_buddy_groups() const;
  ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>* _internal_mutable_buddy_groups();
  public:
  const ::management::GetBuddyGroupsResponse_BuddyGroup& buddy_groups(int index) const;
  ::management::GetBuddyGroupsResponse_BuddyGroup* add_buddy_groups();
  const ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>& buddy_groups() const;
  // @@protoc_insertion_point(class_scope:management.GetBuddyGroupsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBuddyGroupsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::management::GetBuddyGroupsResponse_BuddyGroup > buddy_groups_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_management_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SetAliasRequest

// .beegfs.EntityIdSet entity_id = 1;
inline bool SetAliasRequest::has_entity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_id_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& SetAliasRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.entity_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& SetAliasRequest::entity_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.SetAliasRequest.entity_id)
  return _internal_entity_id();
}
inline void SetAliasRequest::unsafe_arena_set_allocated_entity_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_id_);
  }
  _impl_.entity_id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.SetAliasRequest.entity_id)
}
inline ::beegfs::EntityIdSet* SetAliasRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* SetAliasRequest::unsafe_arena_release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.SetAliasRequest.entity_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* SetAliasRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entity_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.entity_id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.entity_id_;
}
inline ::beegfs::EntityIdSet* SetAliasRequest::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:management.SetAliasRequest.entity_id)
  return _msg;
}
inline void SetAliasRequest::set_allocated_entity_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.entity_id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.SetAliasRequest.entity_id)
}

// .beegfs.EntityType entity_type = 2;
inline void SetAliasRequest::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_ = 0;
}
inline ::beegfs::EntityType SetAliasRequest::entity_type() const {
  // @@protoc_insertion_point(field_get:management.SetAliasRequest.entity_type)
  return _internal_entity_type();
}
inline void SetAliasRequest::set_entity_type(::beegfs::EntityType value) {
  _internal_set_entity_type(value);
  // @@protoc_insertion_point(field_set:management.SetAliasRequest.entity_type)
}
inline ::beegfs::EntityType SetAliasRequest::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::EntityType>(_impl_.entity_type_);
}
inline void SetAliasRequest::_internal_set_entity_type(::beegfs::EntityType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_ = value;
}

// string new_alias = 3;
inline void SetAliasRequest::clear_new_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_alias_.ClearToEmpty();
}
inline const std::string& SetAliasRequest::new_alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.SetAliasRequest.new_alias)
  return _internal_new_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetAliasRequest::set_new_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:management.SetAliasRequest.new_alias)
}
inline std::string* SetAliasRequest::mutable_new_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_alias();
  // @@protoc_insertion_point(field_mutable:management.SetAliasRequest.new_alias)
  return _s;
}
inline const std::string& SetAliasRequest::_internal_new_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_alias_.Get();
}
inline void SetAliasRequest::_internal_set_new_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_alias_.Set(value, GetArena());
}
inline std::string* SetAliasRequest::_internal_mutable_new_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_alias_.Mutable( GetArena());
}
inline std::string* SetAliasRequest::release_new_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.SetAliasRequest.new_alias)
  return _impl_.new_alias_.Release();
}
inline void SetAliasRequest::set_allocated_new_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.new_alias_.IsDefault()) {
    _impl_.new_alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:management.SetAliasRequest.new_alias)
}

// -------------------------------------------------------------------

// SetAliasResponse

// -------------------------------------------------------------------

// GetNodesRequest

// bool include_nics = 1;
inline void GetNodesRequest::clear_include_nics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_nics_ = false;
}
inline bool GetNodesRequest::include_nics() const {
  // @@protoc_insertion_point(field_get:management.GetNodesRequest.include_nics)
  return _internal_include_nics();
}
inline void GetNodesRequest::set_include_nics(bool value) {
  _internal_set_include_nics(value);
  // @@protoc_insertion_point(field_set:management.GetNodesRequest.include_nics)
}
inline bool GetNodesRequest::_internal_include_nics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_nics_;
}
inline void GetNodesRequest::_internal_set_include_nics(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_nics_ = value;
}

// -------------------------------------------------------------------

// GetNodesResponse_Node_Nic

// string addr = 1;
inline void GetNodesResponse_Node_Nic::clear_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetNodesResponse_Node_Nic::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.Nic.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetNodesResponse_Node_Nic::set_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:management.GetNodesResponse.Node.Nic.addr)
}
inline std::string* GetNodesResponse_Node_Nic::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.Node.Nic.addr)
  return _s;
}
inline const std::string& GetNodesResponse_Node_Nic::_internal_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.addr_.Get();
}
inline void GetNodesResponse_Node_Nic::_internal_set_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::_internal_mutable_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::release_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetNodesResponse.Node.Nic.addr)
  return _impl_.addr_.Release();
}
inline void GetNodesResponse_Node_Nic::set_allocated_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:management.GetNodesResponse.Node.Nic.addr)
}

// string name = 2;
inline void GetNodesResponse_Node_Nic::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNodesResponse_Node_Nic::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.Nic.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetNodesResponse_Node_Nic::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:management.GetNodesResponse.Node.Nic.name)
}
inline std::string* GetNodesResponse_Node_Nic::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.Node.Nic.name)
  return _s;
}
inline const std::string& GetNodesResponse_Node_Nic::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void GetNodesResponse_Node_Nic::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetNodesResponse.Node.Nic.name)
  return _impl_.name_.Release();
}
inline void GetNodesResponse_Node_Nic::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:management.GetNodesResponse.Node.Nic.name)
}

// .beegfs.NicType nic_type = 3;
inline void GetNodesResponse_Node_Nic::clear_nic_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nic_type_ = 0;
}
inline ::beegfs::NicType GetNodesResponse_Node_Nic::nic_type() const {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.Nic.nic_type)
  return _internal_nic_type();
}
inline void GetNodesResponse_Node_Nic::set_nic_type(::beegfs::NicType value) {
  _internal_set_nic_type(value);
  // @@protoc_insertion_point(field_set:management.GetNodesResponse.Node.Nic.nic_type)
}
inline ::beegfs::NicType GetNodesResponse_Node_Nic::_internal_nic_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NicType>(_impl_.nic_type_);
}
inline void GetNodesResponse_Node_Nic::_internal_set_nic_type(::beegfs::NicType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nic_type_ = value;
}

// -------------------------------------------------------------------

// GetNodesResponse_Node

// .beegfs.EntityIdSet id = 1;
inline bool GetNodesResponse_Node::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetNodesResponse_Node::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetNodesResponse_Node::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.id)
  return _internal_id();
}
inline void GetNodesResponse_Node::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetNodesResponse.Node.id)
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetNodesResponse.Node.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.Node.id)
  return _msg;
}
inline void GetNodesResponse_Node::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetNodesResponse.Node.id)
}

// .beegfs.NodeType node_type = 2;
inline void GetNodesResponse_Node::clear_node_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType GetNodesResponse_Node::node_type() const {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.node_type)
  return _internal_node_type();
}
inline void GetNodesResponse_Node::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:management.GetNodesResponse.Node.node_type)
}
inline ::beegfs::NodeType GetNodesResponse_Node::_internal_node_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void GetNodesResponse_Node::_internal_set_node_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = value;
}

// uint32 port = 3;
inline void GetNodesResponse_Node::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0u;
}
inline ::uint32_t GetNodesResponse_Node::port() const {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.port)
  return _internal_port();
}
inline void GetNodesResponse_Node::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:management.GetNodesResponse.Node.port)
}
inline ::uint32_t GetNodesResponse_Node::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void GetNodesResponse_Node::_internal_set_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// repeated .management.GetNodesResponse.Node.Nic nics = 4;
inline int GetNodesResponse_Node::_internal_nics_size() const {
  return _internal_nics().size();
}
inline int GetNodesResponse_Node::nics_size() const {
  return _internal_nics_size();
}
inline void GetNodesResponse_Node::clear_nics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nics_.Clear();
}
inline ::management::GetNodesResponse_Node_Nic* GetNodesResponse_Node::mutable_nics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.Node.nics)
  return _internal_mutable_nics()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>* GetNodesResponse_Node::mutable_nics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetNodesResponse.Node.nics)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nics();
}
inline const ::management::GetNodesResponse_Node_Nic& GetNodesResponse_Node::nics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.Node.nics)
  return _internal_nics().Get(index);
}
inline ::management::GetNodesResponse_Node_Nic* GetNodesResponse_Node::add_nics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::management::GetNodesResponse_Node_Nic* _add = _internal_mutable_nics()->Add();
  // @@protoc_insertion_point(field_add:management.GetNodesResponse.Node.nics)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>& GetNodesResponse_Node::nics() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetNodesResponse.Node.nics)
  return _internal_nics();
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>&
GetNodesResponse_Node::_internal_nics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nics_;
}
inline ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node_Nic>*
GetNodesResponse_Node::_internal_mutable_nics() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nics_;
}

// -------------------------------------------------------------------

// GetNodesResponse

// repeated .management.GetNodesResponse.Node nodes = 1;
inline int GetNodesResponse::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int GetNodesResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetNodesResponse::clear_nodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodes_.Clear();
}
inline ::management::GetNodesResponse_Node* GetNodesResponse::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>* GetNodesResponse::mutable_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetNodesResponse.nodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nodes();
}
inline const ::management::GetNodesResponse_Node& GetNodesResponse::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.nodes)
  return _internal_nodes().Get(index);
}
inline ::management::GetNodesResponse_Node* GetNodesResponse::add_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::management::GetNodesResponse_Node* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:management.GetNodesResponse.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>& GetNodesResponse::nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetNodesResponse.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>&
GetNodesResponse::_internal_nodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::management::GetNodesResponse_Node>*
GetNodesResponse::_internal_mutable_nodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nodes_;
}

// optional .beegfs.EntityIdSet meta_root_node = 2;
inline bool GetNodesResponse::has_meta_root_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_root_node_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetNodesResponse::_internal_meta_root_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.meta_root_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetNodesResponse::meta_root_node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.meta_root_node)
  return _internal_meta_root_node();
}
inline void GetNodesResponse::unsafe_arena_set_allocated_meta_root_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_root_node_);
  }
  _impl_.meta_root_node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetNodesResponse.meta_root_node)
}
inline ::beegfs::EntityIdSet* GetNodesResponse::release_meta_root_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* released = _impl_.meta_root_node_;
  _impl_.meta_root_node_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetNodesResponse::unsafe_arena_release_meta_root_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetNodesResponse.meta_root_node)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* temp = _impl_.meta_root_node_;
  _impl_.meta_root_node_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetNodesResponse::_internal_mutable_meta_root_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.meta_root_node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.meta_root_node_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.meta_root_node_;
}
inline ::beegfs::EntityIdSet* GetNodesResponse::mutable_meta_root_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_meta_root_node();
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.meta_root_node)
  return _msg;
}
inline void GetNodesResponse::set_allocated_meta_root_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_root_node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.meta_root_node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetNodesResponse.meta_root_node)
}

// optional string fs_uuid = 3;
inline bool GetNodesResponse::has_fs_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetNodesResponse::clear_fs_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fs_uuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetNodesResponse::fs_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetNodesResponse.fs_uuid)
  return _internal_fs_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetNodesResponse::set_fs_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fs_uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:management.GetNodesResponse.fs_uuid)
}
inline std::string* GetNodesResponse::mutable_fs_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fs_uuid();
  // @@protoc_insertion_point(field_mutable:management.GetNodesResponse.fs_uuid)
  return _s;
}
inline const std::string& GetNodesResponse::_internal_fs_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fs_uuid_.Get();
}
inline void GetNodesResponse::_internal_set_fs_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fs_uuid_.Set(value, GetArena());
}
inline std::string* GetNodesResponse::_internal_mutable_fs_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fs_uuid_.Mutable( GetArena());
}
inline std::string* GetNodesResponse::release_fs_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetNodesResponse.fs_uuid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fs_uuid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fs_uuid_.Set("", GetArena());
  }
  return released;
}
inline void GetNodesResponse::set_allocated_fs_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fs_uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fs_uuid_.IsDefault()) {
    _impl_.fs_uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:management.GetNodesResponse.fs_uuid)
}

// -------------------------------------------------------------------

// DeleteNodeRequest

// optional .beegfs.EntityIdSet node = 1;
inline bool DeleteNodeRequest::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeleteNodeRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeleteNodeRequest::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeleteNodeRequest.node)
  return _internal_node();
}
inline void DeleteNodeRequest::unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeleteNodeRequest.node)
}
inline ::beegfs::EntityIdSet* DeleteNodeRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.node_;
  _impl_.node_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeleteNodeRequest::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeleteNodeRequest.node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeleteNodeRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.node_;
}
inline ::beegfs::EntityIdSet* DeleteNodeRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:management.DeleteNodeRequest.node)
  return _msg;
}
inline void DeleteNodeRequest::set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeleteNodeRequest.node)
}

// optional bool execute = 2;
inline bool DeleteNodeRequest::has_execute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeleteNodeRequest::clear_execute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeleteNodeRequest::execute() const {
  // @@protoc_insertion_point(field_get:management.DeleteNodeRequest.execute)
  return _internal_execute();
}
inline void DeleteNodeRequest::set_execute(bool value) {
  _internal_set_execute(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.DeleteNodeRequest.execute)
}
inline bool DeleteNodeRequest::_internal_execute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execute_;
}
inline void DeleteNodeRequest::_internal_set_execute(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = value;
}

// -------------------------------------------------------------------

// DeleteNodeResponse

// optional .beegfs.EntityIdSet node = 1;
inline bool DeleteNodeResponse::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeleteNodeResponse::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeleteNodeResponse::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeleteNodeResponse.node)
  return _internal_node();
}
inline void DeleteNodeResponse::unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeleteNodeResponse.node)
}
inline ::beegfs::EntityIdSet* DeleteNodeResponse::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.node_;
  _impl_.node_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeleteNodeResponse::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeleteNodeResponse.node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeleteNodeResponse::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.node_;
}
inline ::beegfs::EntityIdSet* DeleteNodeResponse::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:management.DeleteNodeResponse.node)
  return _msg;
}
inline void DeleteNodeResponse::set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeleteNodeResponse.node)
}

// -------------------------------------------------------------------

// GetTargetsRequest

// -------------------------------------------------------------------

// GetTargetsResponse_Target

// .beegfs.EntityIdSet id = 1;
inline bool GetTargetsResponse_Target::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.id)
  return _internal_id();
}
inline void GetTargetsResponse_Target::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetTargetsResponse.Target.id)
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetTargetsResponse.Target.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:management.GetTargetsResponse.Target.id)
  return _msg;
}
inline void GetTargetsResponse_Target::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetTargetsResponse.Target.id)
}

// .beegfs.NodeType node_type = 2;
inline void GetTargetsResponse_Target::clear_node_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType GetTargetsResponse_Target::node_type() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.node_type)
  return _internal_node_type();
}
inline void GetTargetsResponse_Target::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.node_type)
}
inline ::beegfs::NodeType GetTargetsResponse_Target::_internal_node_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void GetTargetsResponse_Target::_internal_set_node_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = value;
}

// .beegfs.ReachabilityState reachability_state = 3;
inline void GetTargetsResponse_Target::clear_reachability_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reachability_state_ = 0;
}
inline ::beegfs::ReachabilityState GetTargetsResponse_Target::reachability_state() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.reachability_state)
  return _internal_reachability_state();
}
inline void GetTargetsResponse_Target::set_reachability_state(::beegfs::ReachabilityState value) {
  _internal_set_reachability_state(value);
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.reachability_state)
}
inline ::beegfs::ReachabilityState GetTargetsResponse_Target::_internal_reachability_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::ReachabilityState>(_impl_.reachability_state_);
}
inline void GetTargetsResponse_Target::_internal_set_reachability_state(::beegfs::ReachabilityState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reachability_state_ = value;
}

// .beegfs.ConsistencyState consistency_state = 4;
inline void GetTargetsResponse_Target::clear_consistency_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.consistency_state_ = 0;
}
inline ::beegfs::ConsistencyState GetTargetsResponse_Target::consistency_state() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.consistency_state)
  return _internal_consistency_state();
}
inline void GetTargetsResponse_Target::set_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_consistency_state(value);
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.consistency_state)
}
inline ::beegfs::ConsistencyState GetTargetsResponse_Target::_internal_consistency_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::ConsistencyState>(_impl_.consistency_state_);
}
inline void GetTargetsResponse_Target::_internal_set_consistency_state(::beegfs::ConsistencyState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.consistency_state_ = value;
}

// optional uint64 last_contact_s = 5;
inline bool GetTargetsResponse_Target::has_last_contact_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_last_contact_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_contact_s_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t GetTargetsResponse_Target::last_contact_s() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.last_contact_s)
  return _internal_last_contact_s();
}
inline void GetTargetsResponse_Target::set_last_contact_s(::uint64_t value) {
  _internal_set_last_contact_s(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.last_contact_s)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_last_contact_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_contact_s_;
}
inline void GetTargetsResponse_Target::_internal_set_last_contact_s(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_contact_s_ = value;
}

// optional uint64 total_space_bytes = 6;
inline bool GetTargetsResponse_Target::has_total_space_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_total_space_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_space_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t GetTargetsResponse_Target::total_space_bytes() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.total_space_bytes)
  return _internal_total_space_bytes();
}
inline void GetTargetsResponse_Target::set_total_space_bytes(::uint64_t value) {
  _internal_set_total_space_bytes(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.total_space_bytes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_total_space_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_space_bytes_;
}
inline void GetTargetsResponse_Target::_internal_set_total_space_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_space_bytes_ = value;
}

// optional uint64 free_space_bytes = 7;
inline bool GetTargetsResponse_Target::has_free_space_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_free_space_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_space_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t GetTargetsResponse_Target::free_space_bytes() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.free_space_bytes)
  return _internal_free_space_bytes();
}
inline void GetTargetsResponse_Target::set_free_space_bytes(::uint64_t value) {
  _internal_set_free_space_bytes(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.free_space_bytes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_free_space_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_space_bytes_;
}
inline void GetTargetsResponse_Target::_internal_set_free_space_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_space_bytes_ = value;
}

// optional uint64 total_inodes = 8;
inline bool GetTargetsResponse_Target::has_total_inodes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_total_inodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_inodes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t GetTargetsResponse_Target::total_inodes() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.total_inodes)
  return _internal_total_inodes();
}
inline void GetTargetsResponse_Target::set_total_inodes(::uint64_t value) {
  _internal_set_total_inodes(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.total_inodes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_total_inodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_inodes_;
}
inline void GetTargetsResponse_Target::_internal_set_total_inodes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_inodes_ = value;
}

// optional uint64 free_inodes = 9;
inline bool GetTargetsResponse_Target::has_free_inodes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_free_inodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_inodes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t GetTargetsResponse_Target::free_inodes() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.free_inodes)
  return _internal_free_inodes();
}
inline void GetTargetsResponse_Target::set_free_inodes(::uint64_t value) {
  _internal_set_free_inodes(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.free_inodes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_free_inodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_inodes_;
}
inline void GetTargetsResponse_Target::_internal_set_free_inodes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_inodes_ = value;
}

// .beegfs.CapacityPool cap_pool = 10;
inline void GetTargetsResponse_Target::clear_cap_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cap_pool_ = 0;
}
inline ::beegfs::CapacityPool GetTargetsResponse_Target::cap_pool() const {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.cap_pool)
  return _internal_cap_pool();
}
inline void GetTargetsResponse_Target::set_cap_pool(::beegfs::CapacityPool value) {
  _internal_set_cap_pool(value);
  // @@protoc_insertion_point(field_set:management.GetTargetsResponse.Target.cap_pool)
}
inline ::beegfs::CapacityPool GetTargetsResponse_Target::_internal_cap_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::CapacityPool>(_impl_.cap_pool_);
}
inline void GetTargetsResponse_Target::_internal_set_cap_pool(::beegfs::CapacityPool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cap_pool_ = value;
}

// .beegfs.EntityIdSet node = 11;
inline bool GetTargetsResponse_Target::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.node)
  return _internal_node();
}
inline void GetTargetsResponse_Target::unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetTargetsResponse.Target.node)
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* released = _impl_.node_;
  _impl_.node_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetTargetsResponse.Target.node)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.node_;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:management.GetTargetsResponse.Target.node)
  return _msg;
}
inline void GetTargetsResponse_Target::set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetTargetsResponse.Target.node)
}

// optional .beegfs.EntityIdSet storage_pool = 12;
inline bool GetTargetsResponse_Target::has_storage_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::_internal_storage_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.storage_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::storage_pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.Target.storage_pool)
  return _internal_storage_pool();
}
inline void GetTargetsResponse_Target::unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_pool_);
  }
  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetTargetsResponse.Target.storage_pool)
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::release_storage_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* released = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::unsafe_arena_release_storage_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetTargetsResponse.Target.storage_pool)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* temp = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::_internal_mutable_storage_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.storage_pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.storage_pool_;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::mutable_storage_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_storage_pool();
  // @@protoc_insertion_point(field_mutable:management.GetTargetsResponse.Target.storage_pool)
  return _msg;
}
inline void GetTargetsResponse_Target::set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetTargetsResponse.Target.storage_pool)
}

// -------------------------------------------------------------------

// GetTargetsResponse

// repeated .management.GetTargetsResponse.Target targets = 1;
inline int GetTargetsResponse::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int GetTargetsResponse::targets_size() const {
  return _internal_targets_size();
}
inline void GetTargetsResponse::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline ::management::GetTargetsResponse_Target* GetTargetsResponse::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetTargetsResponse.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>* GetTargetsResponse::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetTargetsResponse.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::management::GetTargetsResponse_Target& GetTargetsResponse::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetTargetsResponse.targets)
  return _internal_targets().Get(index);
}
inline ::management::GetTargetsResponse_Target* GetTargetsResponse::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::management::GetTargetsResponse_Target* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:management.GetTargetsResponse.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>& GetTargetsResponse::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetTargetsResponse.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>&
GetTargetsResponse::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::management::GetTargetsResponse_Target>*
GetTargetsResponse::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// DeleteTargetRequest

// optional .beegfs.EntityIdSet target = 1;
inline bool DeleteTargetRequest::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeleteTargetRequest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeleteTargetRequest::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeleteTargetRequest.target)
  return _internal_target();
}
inline void DeleteTargetRequest::unsafe_arena_set_allocated_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeleteTargetRequest.target)
}
inline ::beegfs::EntityIdSet* DeleteTargetRequest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeleteTargetRequest::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeleteTargetRequest.target)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeleteTargetRequest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.target_;
}
inline ::beegfs::EntityIdSet* DeleteTargetRequest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:management.DeleteTargetRequest.target)
  return _msg;
}
inline void DeleteTargetRequest::set_allocated_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeleteTargetRequest.target)
}

// optional bool execute = 2;
inline bool DeleteTargetRequest::has_execute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeleteTargetRequest::clear_execute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeleteTargetRequest::execute() const {
  // @@protoc_insertion_point(field_get:management.DeleteTargetRequest.execute)
  return _internal_execute();
}
inline void DeleteTargetRequest::set_execute(bool value) {
  _internal_set_execute(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.DeleteTargetRequest.execute)
}
inline bool DeleteTargetRequest::_internal_execute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execute_;
}
inline void DeleteTargetRequest::_internal_set_execute(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = value;
}

// -------------------------------------------------------------------

// DeleteTargetResponse

// optional .beegfs.EntityIdSet target = 1;
inline bool DeleteTargetResponse::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeleteTargetResponse::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeleteTargetResponse::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeleteTargetResponse.target)
  return _internal_target();
}
inline void DeleteTargetResponse::unsafe_arena_set_allocated_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeleteTargetResponse.target)
}
inline ::beegfs::EntityIdSet* DeleteTargetResponse::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeleteTargetResponse::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeleteTargetResponse.target)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeleteTargetResponse::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.target_;
}
inline ::beegfs::EntityIdSet* DeleteTargetResponse::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:management.DeleteTargetResponse.target)
  return _msg;
}
inline void DeleteTargetResponse::set_allocated_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeleteTargetResponse.target)
}

// -------------------------------------------------------------------

// SetTargetStateRequest

// optional .beegfs.EntityIdSet target = 1;
inline bool SetTargetStateRequest::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& SetTargetStateRequest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& SetTargetStateRequest::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.SetTargetStateRequest.target)
  return _internal_target();
}
inline void SetTargetStateRequest::unsafe_arena_set_allocated_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.SetTargetStateRequest.target)
}
inline ::beegfs::EntityIdSet* SetTargetStateRequest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* SetTargetStateRequest::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.SetTargetStateRequest.target)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* SetTargetStateRequest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.target_;
}
inline ::beegfs::EntityIdSet* SetTargetStateRequest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:management.SetTargetStateRequest.target)
  return _msg;
}
inline void SetTargetStateRequest::set_allocated_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.SetTargetStateRequest.target)
}

// optional .beegfs.ConsistencyState consistency_state = 2;
inline bool SetTargetStateRequest::has_consistency_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SetTargetStateRequest::clear_consistency_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.consistency_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::beegfs::ConsistencyState SetTargetStateRequest::consistency_state() const {
  // @@protoc_insertion_point(field_get:management.SetTargetStateRequest.consistency_state)
  return _internal_consistency_state();
}
inline void SetTargetStateRequest::set_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_consistency_state(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.SetTargetStateRequest.consistency_state)
}
inline ::beegfs::ConsistencyState SetTargetStateRequest::_internal_consistency_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::ConsistencyState>(_impl_.consistency_state_);
}
inline void SetTargetStateRequest::_internal_set_consistency_state(::beegfs::ConsistencyState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.consistency_state_ = value;
}

// -------------------------------------------------------------------

// SetTargetStateResponse

// -------------------------------------------------------------------

// GetPoolsRequest

// bool with_quota_limits = 1;
inline void GetPoolsRequest::clear_with_quota_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.with_quota_limits_ = false;
}
inline bool GetPoolsRequest::with_quota_limits() const {
  // @@protoc_insertion_point(field_get:management.GetPoolsRequest.with_quota_limits)
  return _internal_with_quota_limits();
}
inline void GetPoolsRequest::set_with_quota_limits(bool value) {
  _internal_set_with_quota_limits(value);
  // @@protoc_insertion_point(field_set:management.GetPoolsRequest.with_quota_limits)
}
inline bool GetPoolsRequest::_internal_with_quota_limits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.with_quota_limits_;
}
inline void GetPoolsRequest::_internal_set_with_quota_limits(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.with_quota_limits_ = value;
}

// -------------------------------------------------------------------

// GetPoolsResponse_StoragePool

// .beegfs.EntityIdSet id = 1;
inline bool GetPoolsResponse_StoragePool::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetPoolsResponse_StoragePool::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetPoolsResponse_StoragePool::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.id)
  return _internal_id();
}
inline void GetPoolsResponse_StoragePool::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetPoolsResponse.StoragePool.id)
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetPoolsResponse.StoragePool.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:management.GetPoolsResponse.StoragePool.id)
  return _msg;
}
inline void GetPoolsResponse_StoragePool::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetPoolsResponse.StoragePool.id)
}

// repeated .beegfs.EntityIdSet targets = 2;
inline int GetPoolsResponse_StoragePool::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int GetPoolsResponse_StoragePool::targets_size() const {
  return _internal_targets_size();
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetPoolsResponse.StoragePool.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* GetPoolsResponse_StoragePool::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetPoolsResponse.StoragePool.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::beegfs::EntityIdSet& GetPoolsResponse_StoragePool::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.targets)
  return _internal_targets().Get(index);
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::beegfs::EntityIdSet* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:management.GetPoolsResponse.StoragePool.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& GetPoolsResponse_StoragePool::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetPoolsResponse.StoragePool.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
GetPoolsResponse_StoragePool::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
GetPoolsResponse_StoragePool::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// repeated .beegfs.EntityIdSet buddy_groups = 3;
inline int GetPoolsResponse_StoragePool::_internal_buddy_groups_size() const {
  return _internal_buddy_groups().size();
}
inline int GetPoolsResponse_StoragePool::buddy_groups_size() const {
  return _internal_buddy_groups_size();
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::mutable_buddy_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetPoolsResponse.StoragePool.buddy_groups)
  return _internal_mutable_buddy_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* GetPoolsResponse_StoragePool::mutable_buddy_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetPoolsResponse.StoragePool.buddy_groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_buddy_groups();
}
inline const ::beegfs::EntityIdSet& GetPoolsResponse_StoragePool::buddy_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.buddy_groups)
  return _internal_buddy_groups().Get(index);
}
inline ::beegfs::EntityIdSet* GetPoolsResponse_StoragePool::add_buddy_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::beegfs::EntityIdSet* _add = _internal_mutable_buddy_groups()->Add();
  // @@protoc_insertion_point(field_add:management.GetPoolsResponse.StoragePool.buddy_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& GetPoolsResponse_StoragePool::buddy_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetPoolsResponse.StoragePool.buddy_groups)
  return _internal_buddy_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
GetPoolsResponse_StoragePool::_internal_buddy_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buddy_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
GetPoolsResponse_StoragePool::_internal_mutable_buddy_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.buddy_groups_;
}

// optional int64 user_space_limit = 4;
inline bool GetPoolsResponse_StoragePool::has_user_space_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetPoolsResponse_StoragePool::clear_user_space_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_space_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t GetPoolsResponse_StoragePool::user_space_limit() const {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.user_space_limit)
  return _internal_user_space_limit();
}
inline void GetPoolsResponse_StoragePool::set_user_space_limit(::int64_t value) {
  _internal_set_user_space_limit(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.GetPoolsResponse.StoragePool.user_space_limit)
}
inline ::int64_t GetPoolsResponse_StoragePool::_internal_user_space_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_space_limit_;
}
inline void GetPoolsResponse_StoragePool::_internal_set_user_space_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_space_limit_ = value;
}

// optional int64 user_inode_limit = 5;
inline bool GetPoolsResponse_StoragePool::has_user_inode_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetPoolsResponse_StoragePool::clear_user_inode_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_inode_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t GetPoolsResponse_StoragePool::user_inode_limit() const {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.user_inode_limit)
  return _internal_user_inode_limit();
}
inline void GetPoolsResponse_StoragePool::set_user_inode_limit(::int64_t value) {
  _internal_set_user_inode_limit(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.GetPoolsResponse.StoragePool.user_inode_limit)
}
inline ::int64_t GetPoolsResponse_StoragePool::_internal_user_inode_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_inode_limit_;
}
inline void GetPoolsResponse_StoragePool::_internal_set_user_inode_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_inode_limit_ = value;
}

// optional int64 group_space_limit = 6;
inline bool GetPoolsResponse_StoragePool::has_group_space_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GetPoolsResponse_StoragePool::clear_group_space_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_space_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t GetPoolsResponse_StoragePool::group_space_limit() const {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.group_space_limit)
  return _internal_group_space_limit();
}
inline void GetPoolsResponse_StoragePool::set_group_space_limit(::int64_t value) {
  _internal_set_group_space_limit(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.GetPoolsResponse.StoragePool.group_space_limit)
}
inline ::int64_t GetPoolsResponse_StoragePool::_internal_group_space_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_space_limit_;
}
inline void GetPoolsResponse_StoragePool::_internal_set_group_space_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_space_limit_ = value;
}

// optional int64 group_inode_limit = 7;
inline bool GetPoolsResponse_StoragePool::has_group_inode_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GetPoolsResponse_StoragePool::clear_group_inode_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_inode_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t GetPoolsResponse_StoragePool::group_inode_limit() const {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.StoragePool.group_inode_limit)
  return _internal_group_inode_limit();
}
inline void GetPoolsResponse_StoragePool::set_group_inode_limit(::int64_t value) {
  _internal_set_group_inode_limit(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.GetPoolsResponse.StoragePool.group_inode_limit)
}
inline ::int64_t GetPoolsResponse_StoragePool::_internal_group_inode_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_inode_limit_;
}
inline void GetPoolsResponse_StoragePool::_internal_set_group_inode_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_inode_limit_ = value;
}

// -------------------------------------------------------------------

// GetPoolsResponse

// repeated .management.GetPoolsResponse.StoragePool pools = 1;
inline int GetPoolsResponse::_internal_pools_size() const {
  return _internal_pools().size();
}
inline int GetPoolsResponse::pools_size() const {
  return _internal_pools_size();
}
inline void GetPoolsResponse::clear_pools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pools_.Clear();
}
inline ::management::GetPoolsResponse_StoragePool* GetPoolsResponse::mutable_pools(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetPoolsResponse.pools)
  return _internal_mutable_pools()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>* GetPoolsResponse::mutable_pools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetPoolsResponse.pools)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pools();
}
inline const ::management::GetPoolsResponse_StoragePool& GetPoolsResponse::pools(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetPoolsResponse.pools)
  return _internal_pools().Get(index);
}
inline ::management::GetPoolsResponse_StoragePool* GetPoolsResponse::add_pools() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::management::GetPoolsResponse_StoragePool* _add = _internal_mutable_pools()->Add();
  // @@protoc_insertion_point(field_add:management.GetPoolsResponse.pools)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>& GetPoolsResponse::pools() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetPoolsResponse.pools)
  return _internal_pools();
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>&
GetPoolsResponse::_internal_pools() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pools_;
}
inline ::google::protobuf::RepeatedPtrField<::management::GetPoolsResponse_StoragePool>*
GetPoolsResponse::_internal_mutable_pools() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pools_;
}

// -------------------------------------------------------------------

// CreatePoolRequest

// optional .beegfs.NodeType node_type = 1;
inline bool CreatePoolRequest::has_node_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CreatePoolRequest::clear_node_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::beegfs::NodeType CreatePoolRequest::node_type() const {
  // @@protoc_insertion_point(field_get:management.CreatePoolRequest.node_type)
  return _internal_node_type();
}
inline void CreatePoolRequest::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.CreatePoolRequest.node_type)
}
inline ::beegfs::NodeType CreatePoolRequest::_internal_node_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void CreatePoolRequest::_internal_set_node_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = value;
}

// optional uint32 num_id = 2;
inline bool CreatePoolRequest::has_num_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CreatePoolRequest::clear_num_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t CreatePoolRequest::num_id() const {
  // @@protoc_insertion_point(field_get:management.CreatePoolRequest.num_id)
  return _internal_num_id();
}
inline void CreatePoolRequest::set_num_id(::uint32_t value) {
  _internal_set_num_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.CreatePoolRequest.num_id)
}
inline ::uint32_t CreatePoolRequest::_internal_num_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_id_;
}
inline void CreatePoolRequest::_internal_set_num_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = value;
}

// optional string alias = 3;
inline bool CreatePoolRequest::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CreatePoolRequest::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreatePoolRequest::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreatePoolRequest.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreatePoolRequest::set_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:management.CreatePoolRequest.alias)
}
inline std::string* CreatePoolRequest::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:management.CreatePoolRequest.alias)
  return _s;
}
inline const std::string& CreatePoolRequest::_internal_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_.Get();
}
inline void CreatePoolRequest::_internal_set_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* CreatePoolRequest::_internal_mutable_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* CreatePoolRequest::release_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.CreatePoolRequest.alias)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.alias_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alias_.Set("", GetArena());
  }
  return released;
}
inline void CreatePoolRequest::set_allocated_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:management.CreatePoolRequest.alias)
}

// repeated .beegfs.EntityIdSet targets = 4;
inline int CreatePoolRequest::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int CreatePoolRequest::targets_size() const {
  return _internal_targets_size();
}
inline ::beegfs::EntityIdSet* CreatePoolRequest::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.CreatePoolRequest.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* CreatePoolRequest::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.CreatePoolRequest.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::beegfs::EntityIdSet& CreatePoolRequest::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreatePoolRequest.targets)
  return _internal_targets().Get(index);
}
inline ::beegfs::EntityIdSet* CreatePoolRequest::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::beegfs::EntityIdSet* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:management.CreatePoolRequest.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& CreatePoolRequest::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.CreatePoolRequest.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
CreatePoolRequest::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
CreatePoolRequest::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// repeated .beegfs.EntityIdSet buddy_groups = 5;
inline int CreatePoolRequest::_internal_buddy_groups_size() const {
  return _internal_buddy_groups().size();
}
inline int CreatePoolRequest::buddy_groups_size() const {
  return _internal_buddy_groups_size();
}
inline ::beegfs::EntityIdSet* CreatePoolRequest::mutable_buddy_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.CreatePoolRequest.buddy_groups)
  return _internal_mutable_buddy_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* CreatePoolRequest::mutable_buddy_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.CreatePoolRequest.buddy_groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_buddy_groups();
}
inline const ::beegfs::EntityIdSet& CreatePoolRequest::buddy_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreatePoolRequest.buddy_groups)
  return _internal_buddy_groups().Get(index);
}
inline ::beegfs::EntityIdSet* CreatePoolRequest::add_buddy_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::beegfs::EntityIdSet* _add = _internal_mutable_buddy_groups()->Add();
  // @@protoc_insertion_point(field_add:management.CreatePoolRequest.buddy_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& CreatePoolRequest::buddy_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.CreatePoolRequest.buddy_groups)
  return _internal_buddy_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
CreatePoolRequest::_internal_buddy_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buddy_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
CreatePoolRequest::_internal_mutable_buddy_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.buddy_groups_;
}

// -------------------------------------------------------------------

// CreatePoolResponse

// optional .beegfs.EntityIdSet pool = 1;
inline bool CreatePoolResponse::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& CreatePoolResponse::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& CreatePoolResponse::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreatePoolResponse.pool)
  return _internal_pool();
}
inline void CreatePoolResponse::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.CreatePoolResponse.pool)
}
inline ::beegfs::EntityIdSet* CreatePoolResponse::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* CreatePoolResponse::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.CreatePoolResponse.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* CreatePoolResponse::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* CreatePoolResponse::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.CreatePoolResponse.pool)
  return _msg;
}
inline void CreatePoolResponse::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.CreatePoolResponse.pool)
}

// -------------------------------------------------------------------

// AssignPoolRequest

// optional .beegfs.EntityIdSet pool = 1;
inline bool AssignPoolRequest::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& AssignPoolRequest::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& AssignPoolRequest::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.AssignPoolRequest.pool)
  return _internal_pool();
}
inline void AssignPoolRequest::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.AssignPoolRequest.pool)
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.AssignPoolRequest.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.AssignPoolRequest.pool)
  return _msg;
}
inline void AssignPoolRequest::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.AssignPoolRequest.pool)
}

// repeated .beegfs.EntityIdSet targets = 2;
inline int AssignPoolRequest::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int AssignPoolRequest::targets_size() const {
  return _internal_targets_size();
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.AssignPoolRequest.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* AssignPoolRequest::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.AssignPoolRequest.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::beegfs::EntityIdSet& AssignPoolRequest::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.AssignPoolRequest.targets)
  return _internal_targets().Get(index);
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::beegfs::EntityIdSet* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:management.AssignPoolRequest.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& AssignPoolRequest::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.AssignPoolRequest.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
AssignPoolRequest::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
AssignPoolRequest::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// repeated .beegfs.EntityIdSet buddy_groups = 3;
inline int AssignPoolRequest::_internal_buddy_groups_size() const {
  return _internal_buddy_groups().size();
}
inline int AssignPoolRequest::buddy_groups_size() const {
  return _internal_buddy_groups_size();
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::mutable_buddy_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.AssignPoolRequest.buddy_groups)
  return _internal_mutable_buddy_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* AssignPoolRequest::mutable_buddy_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.AssignPoolRequest.buddy_groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_buddy_groups();
}
inline const ::beegfs::EntityIdSet& AssignPoolRequest::buddy_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.AssignPoolRequest.buddy_groups)
  return _internal_buddy_groups().Get(index);
}
inline ::beegfs::EntityIdSet* AssignPoolRequest::add_buddy_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::beegfs::EntityIdSet* _add = _internal_mutable_buddy_groups()->Add();
  // @@protoc_insertion_point(field_add:management.AssignPoolRequest.buddy_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& AssignPoolRequest::buddy_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.AssignPoolRequest.buddy_groups)
  return _internal_buddy_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
AssignPoolRequest::_internal_buddy_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buddy_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
AssignPoolRequest::_internal_mutable_buddy_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.buddy_groups_;
}

// -------------------------------------------------------------------

// AssignPoolResponse

// optional .beegfs.EntityIdSet pool = 1;
inline bool AssignPoolResponse::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& AssignPoolResponse::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& AssignPoolResponse::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.AssignPoolResponse.pool)
  return _internal_pool();
}
inline void AssignPoolResponse::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.AssignPoolResponse.pool)
}
inline ::beegfs::EntityIdSet* AssignPoolResponse::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* AssignPoolResponse::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.AssignPoolResponse.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* AssignPoolResponse::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* AssignPoolResponse::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.AssignPoolResponse.pool)
  return _msg;
}
inline void AssignPoolResponse::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.AssignPoolResponse.pool)
}

// -------------------------------------------------------------------

// DeletePoolRequest

// optional .beegfs.EntityIdSet pool = 1;
inline bool DeletePoolRequest::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeletePoolRequest::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeletePoolRequest::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeletePoolRequest.pool)
  return _internal_pool();
}
inline void DeletePoolRequest::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeletePoolRequest.pool)
}
inline ::beegfs::EntityIdSet* DeletePoolRequest::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeletePoolRequest::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeletePoolRequest.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeletePoolRequest::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* DeletePoolRequest::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.DeletePoolRequest.pool)
  return _msg;
}
inline void DeletePoolRequest::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeletePoolRequest.pool)
}

// optional bool execute = 2;
inline bool DeletePoolRequest::has_execute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeletePoolRequest::clear_execute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeletePoolRequest::execute() const {
  // @@protoc_insertion_point(field_get:management.DeletePoolRequest.execute)
  return _internal_execute();
}
inline void DeletePoolRequest::set_execute(bool value) {
  _internal_set_execute(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.DeletePoolRequest.execute)
}
inline bool DeletePoolRequest::_internal_execute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execute_;
}
inline void DeletePoolRequest::_internal_set_execute(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = value;
}

// -------------------------------------------------------------------

// DeletePoolResponse

// optional .beegfs.EntityIdSet pool = 1;
inline bool DeletePoolResponse::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeletePoolResponse::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeletePoolResponse::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeletePoolResponse.pool)
  return _internal_pool();
}
inline void DeletePoolResponse::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeletePoolResponse.pool)
}
inline ::beegfs::EntityIdSet* DeletePoolResponse::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeletePoolResponse::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeletePoolResponse.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeletePoolResponse::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* DeletePoolResponse::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.DeletePoolResponse.pool)
  return _msg;
}
inline void DeletePoolResponse::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeletePoolResponse.pool)
}

// -------------------------------------------------------------------

// GetBuddyGroupsRequest

// -------------------------------------------------------------------

// GetBuddyGroupsResponse_BuddyGroup

// .beegfs.EntityIdSet id = 1;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.id)
  return _internal_id();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.id)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetBuddyGroupsResponse.BuddyGroup.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:management.GetBuddyGroupsResponse.BuddyGroup.id)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.id)
}

// .beegfs.NodeType node_type = 2;
inline void GetBuddyGroupsResponse_BuddyGroup::clear_node_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType GetBuddyGroupsResponse_BuddyGroup::node_type() const {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.node_type)
  return _internal_node_type();
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:management.GetBuddyGroupsResponse.BuddyGroup.node_type)
}
inline ::beegfs::NodeType GetBuddyGroupsResponse_BuddyGroup::_internal_node_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void GetBuddyGroupsResponse_BuddyGroup::_internal_set_node_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = value;
}

// .beegfs.EntityIdSet primary_target = 3;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_primary_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.primary_target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_primary_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.primary_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::primary_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.primary_target)
  return _internal_primary_target();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_primary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_target_);
  }
  _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.primary_target)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_primary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* released = _impl_.primary_target_;
  _impl_.primary_target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_primary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetBuddyGroupsResponse.BuddyGroup.primary_target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* temp = _impl_.primary_target_;
  _impl_.primary_target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_primary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.primary_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.primary_target_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_primary_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_primary_target();
  // @@protoc_insertion_point(field_mutable:management.GetBuddyGroupsResponse.BuddyGroup.primary_target)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_primary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.primary_target)
}

// .beegfs.EntityIdSet secondary_target = 4;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_secondary_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secondary_target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_secondary_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.secondary_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::secondary_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
  return _internal_secondary_target();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_secondary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_target_);
  }
  _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_secondary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* released = _impl_.secondary_target_;
  _impl_.secondary_target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_secondary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetBuddyGroupsResponse.BuddyGroup.secondary_target)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* temp = _impl_.secondary_target_;
  _impl_.secondary_target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_secondary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondary_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.secondary_target_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_secondary_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_secondary_target();
  // @@protoc_insertion_point(field_mutable:management.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_secondary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
}

// .beegfs.ConsistencyState primary_consistency_state = 5;
inline void GetBuddyGroupsResponse_BuddyGroup::clear_primary_consistency_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_consistency_state_ = 0;
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::primary_consistency_state() const {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.primary_consistency_state)
  return _internal_primary_consistency_state();
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_primary_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_primary_consistency_state(value);
  // @@protoc_insertion_point(field_set:management.GetBuddyGroupsResponse.BuddyGroup.primary_consistency_state)
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::_internal_primary_consistency_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::ConsistencyState>(_impl_.primary_consistency_state_);
}
inline void GetBuddyGroupsResponse_BuddyGroup::_internal_set_primary_consistency_state(::beegfs::ConsistencyState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_consistency_state_ = value;
}

// .beegfs.ConsistencyState secondary_consistency_state = 6;
inline void GetBuddyGroupsResponse_BuddyGroup::clear_secondary_consistency_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_consistency_state_ = 0;
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::secondary_consistency_state() const {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.secondary_consistency_state)
  return _internal_secondary_consistency_state();
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_secondary_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_secondary_consistency_state(value);
  // @@protoc_insertion_point(field_set:management.GetBuddyGroupsResponse.BuddyGroup.secondary_consistency_state)
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::_internal_secondary_consistency_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::ConsistencyState>(_impl_.secondary_consistency_state_);
}
inline void GetBuddyGroupsResponse_BuddyGroup::_internal_set_secondary_consistency_state(::beegfs::ConsistencyState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_consistency_state_ = value;
}

// optional .beegfs.EntityIdSet storage_pool = 7;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_storage_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_storage_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.storage_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::storage_pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
  return _internal_storage_pool();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_pool_);
  }
  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_storage_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::beegfs::EntityIdSet* released = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_storage_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetBuddyGroupsResponse.BuddyGroup.storage_pool)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::beegfs::EntityIdSet* temp = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_storage_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.storage_pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.storage_pool_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_storage_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_storage_pool();
  // @@protoc_insertion_point(field_mutable:management.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
}

// -------------------------------------------------------------------

// GetBuddyGroupsResponse

// repeated .management.GetBuddyGroupsResponse.BuddyGroup buddy_groups = 1;
inline int GetBuddyGroupsResponse::_internal_buddy_groups_size() const {
  return _internal_buddy_groups().size();
}
inline int GetBuddyGroupsResponse::buddy_groups_size() const {
  return _internal_buddy_groups_size();
}
inline void GetBuddyGroupsResponse::clear_buddy_groups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buddy_groups_.Clear();
}
inline ::management::GetBuddyGroupsResponse_BuddyGroup* GetBuddyGroupsResponse::mutable_buddy_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.GetBuddyGroupsResponse.buddy_groups)
  return _internal_mutable_buddy_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>* GetBuddyGroupsResponse::mutable_buddy_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetBuddyGroupsResponse.buddy_groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_buddy_groups();
}
inline const ::management::GetBuddyGroupsResponse_BuddyGroup& GetBuddyGroupsResponse::buddy_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetBuddyGroupsResponse.buddy_groups)
  return _internal_buddy_groups().Get(index);
}
inline ::management::GetBuddyGroupsResponse_BuddyGroup* GetBuddyGroupsResponse::add_buddy_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::management::GetBuddyGroupsResponse_BuddyGroup* _add = _internal_mutable_buddy_groups()->Add();
  // @@protoc_insertion_point(field_add:management.GetBuddyGroupsResponse.buddy_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>& GetBuddyGroupsResponse::buddy_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetBuddyGroupsResponse.buddy_groups)
  return _internal_buddy_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>&
GetBuddyGroupsResponse::_internal_buddy_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buddy_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::management::GetBuddyGroupsResponse_BuddyGroup>*
GetBuddyGroupsResponse::_internal_mutable_buddy_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.buddy_groups_;
}

// -------------------------------------------------------------------

// CreateBuddyGroupRequest

// optional .beegfs.NodeType node_type = 1;
inline bool CreateBuddyGroupRequest::has_node_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CreateBuddyGroupRequest::clear_node_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::beegfs::NodeType CreateBuddyGroupRequest::node_type() const {
  // @@protoc_insertion_point(field_get:management.CreateBuddyGroupRequest.node_type)
  return _internal_node_type();
}
inline void CreateBuddyGroupRequest::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.CreateBuddyGroupRequest.node_type)
}
inline ::beegfs::NodeType CreateBuddyGroupRequest::_internal_node_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void CreateBuddyGroupRequest::_internal_set_node_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_type_ = value;
}

// optional uint32 num_id = 2;
inline bool CreateBuddyGroupRequest::has_num_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CreateBuddyGroupRequest::clear_num_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t CreateBuddyGroupRequest::num_id() const {
  // @@protoc_insertion_point(field_get:management.CreateBuddyGroupRequest.num_id)
  return _internal_num_id();
}
inline void CreateBuddyGroupRequest::set_num_id(::uint32_t value) {
  _internal_set_num_id(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.CreateBuddyGroupRequest.num_id)
}
inline ::uint32_t CreateBuddyGroupRequest::_internal_num_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_id_;
}
inline void CreateBuddyGroupRequest::_internal_set_num_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = value;
}

// optional string alias = 3;
inline bool CreateBuddyGroupRequest::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CreateBuddyGroupRequest::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateBuddyGroupRequest::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreateBuddyGroupRequest.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBuddyGroupRequest::set_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:management.CreateBuddyGroupRequest.alias)
}
inline std::string* CreateBuddyGroupRequest::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:management.CreateBuddyGroupRequest.alias)
  return _s;
}
inline const std::string& CreateBuddyGroupRequest::_internal_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_.Get();
}
inline void CreateBuddyGroupRequest::_internal_set_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* CreateBuddyGroupRequest::_internal_mutable_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* CreateBuddyGroupRequest::release_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.CreateBuddyGroupRequest.alias)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.alias_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alias_.Set("", GetArena());
  }
  return released;
}
inline void CreateBuddyGroupRequest::set_allocated_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:management.CreateBuddyGroupRequest.alias)
}

// optional .beegfs.EntityIdSet primary_target = 4;
inline bool CreateBuddyGroupRequest::has_primary_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.primary_target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& CreateBuddyGroupRequest::_internal_primary_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.primary_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& CreateBuddyGroupRequest::primary_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreateBuddyGroupRequest.primary_target)
  return _internal_primary_target();
}
inline void CreateBuddyGroupRequest::unsafe_arena_set_allocated_primary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_target_);
  }
  _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.CreateBuddyGroupRequest.primary_target)
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::release_primary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* released = _impl_.primary_target_;
  _impl_.primary_target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::unsafe_arena_release_primary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.CreateBuddyGroupRequest.primary_target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* temp = _impl_.primary_target_;
  _impl_.primary_target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::_internal_mutable_primary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.primary_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.primary_target_;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::mutable_primary_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_primary_target();
  // @@protoc_insertion_point(field_mutable:management.CreateBuddyGroupRequest.primary_target)
  return _msg;
}
inline void CreateBuddyGroupRequest::set_allocated_primary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.CreateBuddyGroupRequest.primary_target)
}

// optional .beegfs.EntityIdSet secondary_target = 5;
inline bool CreateBuddyGroupRequest::has_secondary_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secondary_target_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& CreateBuddyGroupRequest::_internal_secondary_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.secondary_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& CreateBuddyGroupRequest::secondary_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreateBuddyGroupRequest.secondary_target)
  return _internal_secondary_target();
}
inline void CreateBuddyGroupRequest::unsafe_arena_set_allocated_secondary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_target_);
  }
  _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.CreateBuddyGroupRequest.secondary_target)
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::release_secondary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* released = _impl_.secondary_target_;
  _impl_.secondary_target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::unsafe_arena_release_secondary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.CreateBuddyGroupRequest.secondary_target)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* temp = _impl_.secondary_target_;
  _impl_.secondary_target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::_internal_mutable_secondary_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondary_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.secondary_target_;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupRequest::mutable_secondary_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_secondary_target();
  // @@protoc_insertion_point(field_mutable:management.CreateBuddyGroupRequest.secondary_target)
  return _msg;
}
inline void CreateBuddyGroupRequest::set_allocated_secondary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.CreateBuddyGroupRequest.secondary_target)
}

// -------------------------------------------------------------------

// CreateBuddyGroupResponse

// optional .beegfs.EntityIdSet group = 1;
inline bool CreateBuddyGroupResponse::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& CreateBuddyGroupResponse::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& CreateBuddyGroupResponse::group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.CreateBuddyGroupResponse.group)
  return _internal_group();
}
inline void CreateBuddyGroupResponse::unsafe_arena_set_allocated_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.CreateBuddyGroupResponse.group)
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupResponse::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.group_;
  _impl_.group_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupResponse::unsafe_arena_release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.CreateBuddyGroupResponse.group)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupResponse::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.group_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.group_;
}
inline ::beegfs::EntityIdSet* CreateBuddyGroupResponse::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:management.CreateBuddyGroupResponse.group)
  return _msg;
}
inline void CreateBuddyGroupResponse::set_allocated_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.CreateBuddyGroupResponse.group)
}

// -------------------------------------------------------------------

// DeleteBuddyGroupRequest

// optional .beegfs.EntityIdSet group = 1;
inline bool DeleteBuddyGroupRequest::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeleteBuddyGroupRequest::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeleteBuddyGroupRequest::group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeleteBuddyGroupRequest.group)
  return _internal_group();
}
inline void DeleteBuddyGroupRequest::unsafe_arena_set_allocated_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeleteBuddyGroupRequest.group)
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupRequest::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.group_;
  _impl_.group_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupRequest::unsafe_arena_release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeleteBuddyGroupRequest.group)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupRequest::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.group_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.group_;
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupRequest::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:management.DeleteBuddyGroupRequest.group)
  return _msg;
}
inline void DeleteBuddyGroupRequest::set_allocated_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeleteBuddyGroupRequest.group)
}

// optional bool execute = 2;
inline bool DeleteBuddyGroupRequest::has_execute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeleteBuddyGroupRequest::clear_execute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeleteBuddyGroupRequest::execute() const {
  // @@protoc_insertion_point(field_get:management.DeleteBuddyGroupRequest.execute)
  return _internal_execute();
}
inline void DeleteBuddyGroupRequest::set_execute(bool value) {
  _internal_set_execute(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.DeleteBuddyGroupRequest.execute)
}
inline bool DeleteBuddyGroupRequest::_internal_execute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execute_;
}
inline void DeleteBuddyGroupRequest::_internal_set_execute(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execute_ = value;
}

// -------------------------------------------------------------------

// DeleteBuddyGroupResponse

// optional .beegfs.EntityIdSet group = 1;
inline bool DeleteBuddyGroupResponse::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& DeleteBuddyGroupResponse::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& DeleteBuddyGroupResponse::group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.DeleteBuddyGroupResponse.group)
  return _internal_group();
}
inline void DeleteBuddyGroupResponse::unsafe_arena_set_allocated_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.DeleteBuddyGroupResponse.group)
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupResponse::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.group_;
  _impl_.group_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupResponse::unsafe_arena_release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.DeleteBuddyGroupResponse.group)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupResponse::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.group_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.group_;
}
inline ::beegfs::EntityIdSet* DeleteBuddyGroupResponse::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:management.DeleteBuddyGroupResponse.group)
  return _msg;
}
inline void DeleteBuddyGroupResponse::set_allocated_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.DeleteBuddyGroupResponse.group)
}

// -------------------------------------------------------------------

// MirrorRootInodeRequest

// -------------------------------------------------------------------

// MirrorRootInodeResponse

// -------------------------------------------------------------------

// StartResyncRequest

// optional .beegfs.EntityIdSet buddy_group = 1;
inline bool StartResyncRequest::has_buddy_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buddy_group_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& StartResyncRequest::_internal_buddy_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.buddy_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& StartResyncRequest::buddy_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.StartResyncRequest.buddy_group)
  return _internal_buddy_group();
}
inline void StartResyncRequest::unsafe_arena_set_allocated_buddy_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.buddy_group_);
  }
  _impl_.buddy_group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.StartResyncRequest.buddy_group)
}
inline ::beegfs::EntityIdSet* StartResyncRequest::release_buddy_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.buddy_group_;
  _impl_.buddy_group_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* StartResyncRequest::unsafe_arena_release_buddy_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.StartResyncRequest.buddy_group)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.buddy_group_;
  _impl_.buddy_group_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* StartResyncRequest::_internal_mutable_buddy_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.buddy_group_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.buddy_group_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.buddy_group_;
}
inline ::beegfs::EntityIdSet* StartResyncRequest::mutable_buddy_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_buddy_group();
  // @@protoc_insertion_point(field_mutable:management.StartResyncRequest.buddy_group)
  return _msg;
}
inline void StartResyncRequest::set_allocated_buddy_group(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.buddy_group_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.buddy_group_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.StartResyncRequest.buddy_group)
}

// optional int64 timestamp = 2;
inline bool StartResyncRequest::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StartResyncRequest::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t StartResyncRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:management.StartResyncRequest.timestamp)
  return _internal_timestamp();
}
inline void StartResyncRequest::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.StartResyncRequest.timestamp)
}
inline ::int64_t StartResyncRequest::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void StartResyncRequest::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// optional bool restart = 3;
inline bool StartResyncRequest::has_restart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StartResyncRequest::clear_restart() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.restart_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool StartResyncRequest::restart() const {
  // @@protoc_insertion_point(field_get:management.StartResyncRequest.restart)
  return _internal_restart();
}
inline void StartResyncRequest::set_restart(bool value) {
  _internal_set_restart(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.StartResyncRequest.restart)
}
inline bool StartResyncRequest::_internal_restart() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.restart_;
}
inline void StartResyncRequest::_internal_set_restart(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.restart_ = value;
}

// -------------------------------------------------------------------

// StartResyncResponse

// -------------------------------------------------------------------

// QuotaInfo

// optional uint32 quota_id = 1;
inline bool QuotaInfo::has_quota_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QuotaInfo::clear_quota_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quota_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t QuotaInfo::quota_id() const {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.quota_id)
  return _internal_quota_id();
}
inline void QuotaInfo::set_quota_id(::uint32_t value) {
  _internal_set_quota_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.QuotaInfo.quota_id)
}
inline ::uint32_t QuotaInfo::_internal_quota_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quota_id_;
}
inline void QuotaInfo::_internal_set_quota_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quota_id_ = value;
}

// .beegfs.QuotaIdType id_type = 2;
inline void QuotaInfo::clear_id_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_type_ = 0;
}
inline ::beegfs::QuotaIdType QuotaInfo::id_type() const {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.id_type)
  return _internal_id_type();
}
inline void QuotaInfo::set_id_type(::beegfs::QuotaIdType value) {
  _internal_set_id_type(value);
  // @@protoc_insertion_point(field_set:management.QuotaInfo.id_type)
}
inline ::beegfs::QuotaIdType QuotaInfo::_internal_id_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::QuotaIdType>(_impl_.id_type_);
}
inline void QuotaInfo::_internal_set_id_type(::beegfs::QuotaIdType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_type_ = value;
}

// optional .beegfs.EntityIdSet pool = 3;
inline bool QuotaInfo::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& QuotaInfo::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& QuotaInfo::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.pool)
  return _internal_pool();
}
inline void QuotaInfo::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.QuotaInfo.pool)
}
inline ::beegfs::EntityIdSet* QuotaInfo::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* QuotaInfo::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.QuotaInfo.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* QuotaInfo::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* QuotaInfo::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.QuotaInfo.pool)
  return _msg;
}
inline void QuotaInfo::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.QuotaInfo.pool)
}

// optional int64 space_limit = 4;
inline bool QuotaInfo::has_space_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QuotaInfo::clear_space_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.space_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t QuotaInfo::space_limit() const {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.space_limit)
  return _internal_space_limit();
}
inline void QuotaInfo::set_space_limit(::int64_t value) {
  _internal_set_space_limit(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.QuotaInfo.space_limit)
}
inline ::int64_t QuotaInfo::_internal_space_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.space_limit_;
}
inline void QuotaInfo::_internal_set_space_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.space_limit_ = value;
}

// optional int64 inode_limit = 5;
inline bool QuotaInfo::has_inode_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QuotaInfo::clear_inode_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inode_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t QuotaInfo::inode_limit() const {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.inode_limit)
  return _internal_inode_limit();
}
inline void QuotaInfo::set_inode_limit(::int64_t value) {
  _internal_set_inode_limit(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.QuotaInfo.inode_limit)
}
inline ::int64_t QuotaInfo::_internal_inode_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inode_limit_;
}
inline void QuotaInfo::_internal_set_inode_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inode_limit_ = value;
}

// optional int64 space_used = 6;
inline bool QuotaInfo::has_space_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QuotaInfo::clear_space_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.space_used_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t QuotaInfo::space_used() const {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.space_used)
  return _internal_space_used();
}
inline void QuotaInfo::set_space_used(::int64_t value) {
  _internal_set_space_used(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.QuotaInfo.space_used)
}
inline ::int64_t QuotaInfo::_internal_space_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.space_used_;
}
inline void QuotaInfo::_internal_set_space_used(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.space_used_ = value;
}

// optional int64 inode_used = 7;
inline bool QuotaInfo::has_inode_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QuotaInfo::clear_inode_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inode_used_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t QuotaInfo::inode_used() const {
  // @@protoc_insertion_point(field_get:management.QuotaInfo.inode_used)
  return _internal_inode_used();
}
inline void QuotaInfo::set_inode_used(::int64_t value) {
  _internal_set_inode_used(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:management.QuotaInfo.inode_used)
}
inline ::int64_t QuotaInfo::_internal_inode_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inode_used_;
}
inline void QuotaInfo::_internal_set_inode_used(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inode_used_ = value;
}

// -------------------------------------------------------------------

// SetDefaultQuotaLimitsRequest

// optional .beegfs.EntityIdSet pool = 1;
inline bool SetDefaultQuotaLimitsRequest::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& SetDefaultQuotaLimitsRequest::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& SetDefaultQuotaLimitsRequest::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.SetDefaultQuotaLimitsRequest.pool)
  return _internal_pool();
}
inline void SetDefaultQuotaLimitsRequest::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.SetDefaultQuotaLimitsRequest.pool)
}
inline ::beegfs::EntityIdSet* SetDefaultQuotaLimitsRequest::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* SetDefaultQuotaLimitsRequest::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.SetDefaultQuotaLimitsRequest.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* SetDefaultQuotaLimitsRequest::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* SetDefaultQuotaLimitsRequest::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.SetDefaultQuotaLimitsRequest.pool)
  return _msg;
}
inline void SetDefaultQuotaLimitsRequest::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.SetDefaultQuotaLimitsRequest.pool)
}

// optional int64 user_space_limit = 2;
inline bool SetDefaultQuotaLimitsRequest::has_user_space_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SetDefaultQuotaLimitsRequest::clear_user_space_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_space_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t SetDefaultQuotaLimitsRequest::user_space_limit() const {
  // @@protoc_insertion_point(field_get:management.SetDefaultQuotaLimitsRequest.user_space_limit)
  return _internal_user_space_limit();
}
inline void SetDefaultQuotaLimitsRequest::set_user_space_limit(::int64_t value) {
  _internal_set_user_space_limit(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.SetDefaultQuotaLimitsRequest.user_space_limit)
}
inline ::int64_t SetDefaultQuotaLimitsRequest::_internal_user_space_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_space_limit_;
}
inline void SetDefaultQuotaLimitsRequest::_internal_set_user_space_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_space_limit_ = value;
}

// optional int64 user_inode_limit = 3;
inline bool SetDefaultQuotaLimitsRequest::has_user_inode_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SetDefaultQuotaLimitsRequest::clear_user_inode_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_inode_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t SetDefaultQuotaLimitsRequest::user_inode_limit() const {
  // @@protoc_insertion_point(field_get:management.SetDefaultQuotaLimitsRequest.user_inode_limit)
  return _internal_user_inode_limit();
}
inline void SetDefaultQuotaLimitsRequest::set_user_inode_limit(::int64_t value) {
  _internal_set_user_inode_limit(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.SetDefaultQuotaLimitsRequest.user_inode_limit)
}
inline ::int64_t SetDefaultQuotaLimitsRequest::_internal_user_inode_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_inode_limit_;
}
inline void SetDefaultQuotaLimitsRequest::_internal_set_user_inode_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_inode_limit_ = value;
}

// optional int64 group_space_limit = 4;
inline bool SetDefaultQuotaLimitsRequest::has_group_space_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SetDefaultQuotaLimitsRequest::clear_group_space_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_space_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t SetDefaultQuotaLimitsRequest::group_space_limit() const {
  // @@protoc_insertion_point(field_get:management.SetDefaultQuotaLimitsRequest.group_space_limit)
  return _internal_group_space_limit();
}
inline void SetDefaultQuotaLimitsRequest::set_group_space_limit(::int64_t value) {
  _internal_set_group_space_limit(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.SetDefaultQuotaLimitsRequest.group_space_limit)
}
inline ::int64_t SetDefaultQuotaLimitsRequest::_internal_group_space_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_space_limit_;
}
inline void SetDefaultQuotaLimitsRequest::_internal_set_group_space_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_space_limit_ = value;
}

// optional int64 group_inode_limit = 5;
inline bool SetDefaultQuotaLimitsRequest::has_group_inode_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SetDefaultQuotaLimitsRequest::clear_group_inode_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_inode_limit_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SetDefaultQuotaLimitsRequest::group_inode_limit() const {
  // @@protoc_insertion_point(field_get:management.SetDefaultQuotaLimitsRequest.group_inode_limit)
  return _internal_group_inode_limit();
}
inline void SetDefaultQuotaLimitsRequest::set_group_inode_limit(::int64_t value) {
  _internal_set_group_inode_limit(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.SetDefaultQuotaLimitsRequest.group_inode_limit)
}
inline ::int64_t SetDefaultQuotaLimitsRequest::_internal_group_inode_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_inode_limit_;
}
inline void SetDefaultQuotaLimitsRequest::_internal_set_group_inode_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_inode_limit_ = value;
}

// -------------------------------------------------------------------

// SetDefaultQuotaLimitsResponse

// -------------------------------------------------------------------

// SetQuotaLimitsRequest

// repeated .management.QuotaInfo limits = 1;
inline int SetQuotaLimitsRequest::_internal_limits_size() const {
  return _internal_limits().size();
}
inline int SetQuotaLimitsRequest::limits_size() const {
  return _internal_limits_size();
}
inline void SetQuotaLimitsRequest::clear_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limits_.Clear();
}
inline ::management::QuotaInfo* SetQuotaLimitsRequest::mutable_limits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:management.SetQuotaLimitsRequest.limits)
  return _internal_mutable_limits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>* SetQuotaLimitsRequest::mutable_limits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.SetQuotaLimitsRequest.limits)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_limits();
}
inline const ::management::QuotaInfo& SetQuotaLimitsRequest::limits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.SetQuotaLimitsRequest.limits)
  return _internal_limits().Get(index);
}
inline ::management::QuotaInfo* SetQuotaLimitsRequest::add_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::management::QuotaInfo* _add = _internal_mutable_limits()->Add();
  // @@protoc_insertion_point(field_add:management.SetQuotaLimitsRequest.limits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>& SetQuotaLimitsRequest::limits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.SetQuotaLimitsRequest.limits)
  return _internal_limits();
}
inline const ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>&
SetQuotaLimitsRequest::_internal_limits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limits_;
}
inline ::google::protobuf::RepeatedPtrField<::management::QuotaInfo>*
SetQuotaLimitsRequest::_internal_mutable_limits() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.limits_;
}

// -------------------------------------------------------------------

// SetQuotaLimitsResponse

// -------------------------------------------------------------------

// GetQuotaLimitsRequest

// optional uint32 user_id_min = 1;
inline bool GetQuotaLimitsRequest::has_user_id_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetQuotaLimitsRequest::clear_user_id_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_min_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t GetQuotaLimitsRequest::user_id_min() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.user_id_min)
  return _internal_user_id_min();
}
inline void GetQuotaLimitsRequest::set_user_id_min(::uint32_t value) {
  _internal_set_user_id_min(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.GetQuotaLimitsRequest.user_id_min)
}
inline ::uint32_t GetQuotaLimitsRequest::_internal_user_id_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_min_;
}
inline void GetQuotaLimitsRequest::_internal_set_user_id_min(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_min_ = value;
}

// optional uint32 user_id_max = 2;
inline bool GetQuotaLimitsRequest::has_user_id_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetQuotaLimitsRequest::clear_user_id_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_max_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t GetQuotaLimitsRequest::user_id_max() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.user_id_max)
  return _internal_user_id_max();
}
inline void GetQuotaLimitsRequest::set_user_id_max(::uint32_t value) {
  _internal_set_user_id_max(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.GetQuotaLimitsRequest.user_id_max)
}
inline ::uint32_t GetQuotaLimitsRequest::_internal_user_id_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_max_;
}
inline void GetQuotaLimitsRequest::_internal_set_user_id_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_max_ = value;
}

// repeated uint32 user_id_list = 3;
inline int GetQuotaLimitsRequest::_internal_user_id_list_size() const {
  return _internal_user_id_list().size();
}
inline int GetQuotaLimitsRequest::user_id_list_size() const {
  return _internal_user_id_list_size();
}
inline void GetQuotaLimitsRequest::clear_user_id_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_list_.Clear();
}
inline ::uint32_t GetQuotaLimitsRequest::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.user_id_list)
  return _internal_user_id_list().Get(index);
}
inline void GetQuotaLimitsRequest::set_user_id_list(int index, ::uint32_t value) {
  _internal_mutable_user_id_list()->Set(index, value);
  // @@protoc_insertion_point(field_set:management.GetQuotaLimitsRequest.user_id_list)
}
inline void GetQuotaLimitsRequest::add_user_id_list(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_user_id_list()->Add(value);
  // @@protoc_insertion_point(field_add:management.GetQuotaLimitsRequest.user_id_list)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& GetQuotaLimitsRequest::user_id_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetQuotaLimitsRequest.user_id_list)
  return _internal_user_id_list();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaLimitsRequest::mutable_user_id_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetQuotaLimitsRequest.user_id_list)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_user_id_list();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
GetQuotaLimitsRequest::_internal_user_id_list() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_list_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaLimitsRequest::_internal_mutable_user_id_list() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.user_id_list_;
}

// optional uint32 group_id_min = 4;
inline bool GetQuotaLimitsRequest::has_group_id_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GetQuotaLimitsRequest::clear_group_id_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_min_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t GetQuotaLimitsRequest::group_id_min() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.group_id_min)
  return _internal_group_id_min();
}
inline void GetQuotaLimitsRequest::set_group_id_min(::uint32_t value) {
  _internal_set_group_id_min(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.GetQuotaLimitsRequest.group_id_min)
}
inline ::uint32_t GetQuotaLimitsRequest::_internal_group_id_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_id_min_;
}
inline void GetQuotaLimitsRequest::_internal_set_group_id_min(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_min_ = value;
}

// optional uint32 group_id_max = 5;
inline bool GetQuotaLimitsRequest::has_group_id_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GetQuotaLimitsRequest::clear_group_id_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_max_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t GetQuotaLimitsRequest::group_id_max() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.group_id_max)
  return _internal_group_id_max();
}
inline void GetQuotaLimitsRequest::set_group_id_max(::uint32_t value) {
  _internal_set_group_id_max(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.GetQuotaLimitsRequest.group_id_max)
}
inline ::uint32_t GetQuotaLimitsRequest::_internal_group_id_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_id_max_;
}
inline void GetQuotaLimitsRequest::_internal_set_group_id_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_max_ = value;
}

// repeated uint32 group_id_list = 6;
inline int GetQuotaLimitsRequest::_internal_group_id_list_size() const {
  return _internal_group_id_list().size();
}
inline int GetQuotaLimitsRequest::group_id_list_size() const {
  return _internal_group_id_list_size();
}
inline void GetQuotaLimitsRequest::clear_group_id_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_list_.Clear();
}
inline ::uint32_t GetQuotaLimitsRequest::group_id_list(int index) const {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.group_id_list)
  return _internal_group_id_list().Get(index);
}
inline void GetQuotaLimitsRequest::set_group_id_list(int index, ::uint32_t value) {
  _internal_mutable_group_id_list()->Set(index, value);
  // @@protoc_insertion_point(field_set:management.GetQuotaLimitsRequest.group_id_list)
}
inline void GetQuotaLimitsRequest::add_group_id_list(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_group_id_list()->Add(value);
  // @@protoc_insertion_point(field_add:management.GetQuotaLimitsRequest.group_id_list)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& GetQuotaLimitsRequest::group_id_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetQuotaLimitsRequest.group_id_list)
  return _internal_group_id_list();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaLimitsRequest::mutable_group_id_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetQuotaLimitsRequest.group_id_list)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_group_id_list();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
GetQuotaLimitsRequest::_internal_group_id_list() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_id_list_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaLimitsRequest::_internal_mutable_group_id_list() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.group_id_list_;
}

// optional .beegfs.EntityIdSet pool = 7;
inline bool GetQuotaLimitsRequest::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetQuotaLimitsRequest::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetQuotaLimitsRequest::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsRequest.pool)
  return _internal_pool();
}
inline void GetQuotaLimitsRequest::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetQuotaLimitsRequest.pool)
}
inline ::beegfs::EntityIdSet* GetQuotaLimitsRequest::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetQuotaLimitsRequest::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetQuotaLimitsRequest.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetQuotaLimitsRequest::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* GetQuotaLimitsRequest::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.GetQuotaLimitsRequest.pool)
  return _msg;
}
inline void GetQuotaLimitsRequest::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetQuotaLimitsRequest.pool)
}

// -------------------------------------------------------------------

// GetQuotaLimitsResponse

// optional .management.QuotaInfo limits = 1;
inline bool GetQuotaLimitsResponse::has_limits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limits_ != nullptr);
  return value;
}
inline void GetQuotaLimitsResponse::clear_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.limits_ != nullptr) _impl_.limits_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::management::QuotaInfo& GetQuotaLimitsResponse::_internal_limits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::management::QuotaInfo* p = _impl_.limits_;
  return p != nullptr ? *p : reinterpret_cast<const ::management::QuotaInfo&>(::management::_QuotaInfo_default_instance_);
}
inline const ::management::QuotaInfo& GetQuotaLimitsResponse::limits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetQuotaLimitsResponse.limits)
  return _internal_limits();
}
inline void GetQuotaLimitsResponse::unsafe_arena_set_allocated_limits(::management::QuotaInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limits_);
  }
  _impl_.limits_ = reinterpret_cast<::management::QuotaInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetQuotaLimitsResponse.limits)
}
inline ::management::QuotaInfo* GetQuotaLimitsResponse::release_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::management::QuotaInfo* released = _impl_.limits_;
  _impl_.limits_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::management::QuotaInfo* GetQuotaLimitsResponse::unsafe_arena_release_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetQuotaLimitsResponse.limits)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::management::QuotaInfo* temp = _impl_.limits_;
  _impl_.limits_ = nullptr;
  return temp;
}
inline ::management::QuotaInfo* GetQuotaLimitsResponse::_internal_mutable_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.limits_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::management::QuotaInfo>(GetArena());
    _impl_.limits_ = reinterpret_cast<::management::QuotaInfo*>(p);
  }
  return _impl_.limits_;
}
inline ::management::QuotaInfo* GetQuotaLimitsResponse::mutable_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::management::QuotaInfo* _msg = _internal_mutable_limits();
  // @@protoc_insertion_point(field_mutable:management.GetQuotaLimitsResponse.limits)
  return _msg;
}
inline void GetQuotaLimitsResponse::set_allocated_limits(::management::QuotaInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.limits_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.limits_ = reinterpret_cast<::management::QuotaInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetQuotaLimitsResponse.limits)
}

// -------------------------------------------------------------------

// GetQuotaUsageRequest

// optional uint32 user_id_min = 1;
inline bool GetQuotaUsageRequest::has_user_id_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetQuotaUsageRequest::clear_user_id_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_min_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t GetQuotaUsageRequest::user_id_min() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.user_id_min)
  return _internal_user_id_min();
}
inline void GetQuotaUsageRequest::set_user_id_min(::uint32_t value) {
  _internal_set_user_id_min(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.user_id_min)
}
inline ::uint32_t GetQuotaUsageRequest::_internal_user_id_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_min_;
}
inline void GetQuotaUsageRequest::_internal_set_user_id_min(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_min_ = value;
}

// optional uint32 user_id_max = 2;
inline bool GetQuotaUsageRequest::has_user_id_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetQuotaUsageRequest::clear_user_id_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_max_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t GetQuotaUsageRequest::user_id_max() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.user_id_max)
  return _internal_user_id_max();
}
inline void GetQuotaUsageRequest::set_user_id_max(::uint32_t value) {
  _internal_set_user_id_max(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.user_id_max)
}
inline ::uint32_t GetQuotaUsageRequest::_internal_user_id_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_max_;
}
inline void GetQuotaUsageRequest::_internal_set_user_id_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_max_ = value;
}

// repeated uint32 user_id_list = 3;
inline int GetQuotaUsageRequest::_internal_user_id_list_size() const {
  return _internal_user_id_list().size();
}
inline int GetQuotaUsageRequest::user_id_list_size() const {
  return _internal_user_id_list_size();
}
inline void GetQuotaUsageRequest::clear_user_id_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_list_.Clear();
}
inline ::uint32_t GetQuotaUsageRequest::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.user_id_list)
  return _internal_user_id_list().Get(index);
}
inline void GetQuotaUsageRequest::set_user_id_list(int index, ::uint32_t value) {
  _internal_mutable_user_id_list()->Set(index, value);
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.user_id_list)
}
inline void GetQuotaUsageRequest::add_user_id_list(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_user_id_list()->Add(value);
  // @@protoc_insertion_point(field_add:management.GetQuotaUsageRequest.user_id_list)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& GetQuotaUsageRequest::user_id_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetQuotaUsageRequest.user_id_list)
  return _internal_user_id_list();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaUsageRequest::mutable_user_id_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetQuotaUsageRequest.user_id_list)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_user_id_list();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
GetQuotaUsageRequest::_internal_user_id_list() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_list_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaUsageRequest::_internal_mutable_user_id_list() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.user_id_list_;
}

// optional uint32 group_id_min = 4;
inline bool GetQuotaUsageRequest::has_group_id_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GetQuotaUsageRequest::clear_group_id_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_min_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t GetQuotaUsageRequest::group_id_min() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.group_id_min)
  return _internal_group_id_min();
}
inline void GetQuotaUsageRequest::set_group_id_min(::uint32_t value) {
  _internal_set_group_id_min(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.group_id_min)
}
inline ::uint32_t GetQuotaUsageRequest::_internal_group_id_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_id_min_;
}
inline void GetQuotaUsageRequest::_internal_set_group_id_min(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_min_ = value;
}

// optional uint32 group_id_max = 5;
inline bool GetQuotaUsageRequest::has_group_id_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GetQuotaUsageRequest::clear_group_id_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_max_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t GetQuotaUsageRequest::group_id_max() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.group_id_max)
  return _internal_group_id_max();
}
inline void GetQuotaUsageRequest::set_group_id_max(::uint32_t value) {
  _internal_set_group_id_max(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.group_id_max)
}
inline ::uint32_t GetQuotaUsageRequest::_internal_group_id_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_id_max_;
}
inline void GetQuotaUsageRequest::_internal_set_group_id_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_max_ = value;
}

// repeated uint32 group_id_list = 6;
inline int GetQuotaUsageRequest::_internal_group_id_list_size() const {
  return _internal_group_id_list().size();
}
inline int GetQuotaUsageRequest::group_id_list_size() const {
  return _internal_group_id_list_size();
}
inline void GetQuotaUsageRequest::clear_group_id_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_id_list_.Clear();
}
inline ::uint32_t GetQuotaUsageRequest::group_id_list(int index) const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.group_id_list)
  return _internal_group_id_list().Get(index);
}
inline void GetQuotaUsageRequest::set_group_id_list(int index, ::uint32_t value) {
  _internal_mutable_group_id_list()->Set(index, value);
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.group_id_list)
}
inline void GetQuotaUsageRequest::add_group_id_list(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_group_id_list()->Add(value);
  // @@protoc_insertion_point(field_add:management.GetQuotaUsageRequest.group_id_list)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& GetQuotaUsageRequest::group_id_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:management.GetQuotaUsageRequest.group_id_list)
  return _internal_group_id_list();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaUsageRequest::mutable_group_id_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:management.GetQuotaUsageRequest.group_id_list)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_group_id_list();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
GetQuotaUsageRequest::_internal_group_id_list() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_id_list_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GetQuotaUsageRequest::_internal_mutable_group_id_list() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.group_id_list_;
}

// optional .beegfs.EntityIdSet pool = 7;
inline bool GetQuotaUsageRequest::has_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pool_ != nullptr);
  return value;
}
inline const ::beegfs::EntityIdSet& GetQuotaUsageRequest::_internal_pool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::beegfs::EntityIdSet* p = _impl_.pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetQuotaUsageRequest::pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.pool)
  return _internal_pool();
}
inline void GetQuotaUsageRequest::unsafe_arena_set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }
  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetQuotaUsageRequest.pool)
}
inline ::beegfs::EntityIdSet* GetQuotaUsageRequest::release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.pool_;
  _impl_.pool_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::beegfs::EntityIdSet* GetQuotaUsageRequest::unsafe_arena_release_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetQuotaUsageRequest.pool)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.pool_;
  _impl_.pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetQuotaUsageRequest::_internal_mutable_pool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.pool_;
}
inline ::beegfs::EntityIdSet* GetQuotaUsageRequest::mutable_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_pool();
  // @@protoc_insertion_point(field_mutable:management.GetQuotaUsageRequest.pool)
  return _msg;
}
inline void GetQuotaUsageRequest::set_allocated_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetQuotaUsageRequest.pool)
}

// optional bool exceeded = 8;
inline bool GetQuotaUsageRequest::has_exceeded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GetQuotaUsageRequest::clear_exceeded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exceeded_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool GetQuotaUsageRequest::exceeded() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageRequest.exceeded)
  return _internal_exceeded();
}
inline void GetQuotaUsageRequest::set_exceeded(bool value) {
  _internal_set_exceeded(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageRequest.exceeded)
}
inline bool GetQuotaUsageRequest::_internal_exceeded() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exceeded_;
}
inline void GetQuotaUsageRequest::_internal_set_exceeded(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exceeded_ = value;
}

// -------------------------------------------------------------------

// GetQuotaUsageResponse

// optional .management.QuotaInfo entry = 1;
inline bool GetQuotaUsageResponse::has_entry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entry_ != nullptr);
  return value;
}
inline void GetQuotaUsageResponse::clear_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entry_ != nullptr) _impl_.entry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::management::QuotaInfo& GetQuotaUsageResponse::_internal_entry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::management::QuotaInfo* p = _impl_.entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::management::QuotaInfo&>(::management::_QuotaInfo_default_instance_);
}
inline const ::management::QuotaInfo& GetQuotaUsageResponse::entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageResponse.entry)
  return _internal_entry();
}
inline void GetQuotaUsageResponse::unsafe_arena_set_allocated_entry(::management::QuotaInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entry_);
  }
  _impl_.entry_ = reinterpret_cast<::management::QuotaInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetQuotaUsageResponse.entry)
}
inline ::management::QuotaInfo* GetQuotaUsageResponse::release_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::management::QuotaInfo* released = _impl_.entry_;
  _impl_.entry_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::management::QuotaInfo* GetQuotaUsageResponse::unsafe_arena_release_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetQuotaUsageResponse.entry)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::management::QuotaInfo* temp = _impl_.entry_;
  _impl_.entry_ = nullptr;
  return temp;
}
inline ::management::QuotaInfo* GetQuotaUsageResponse::_internal_mutable_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entry_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::management::QuotaInfo>(GetArena());
    _impl_.entry_ = reinterpret_cast<::management::QuotaInfo*>(p);
  }
  return _impl_.entry_;
}
inline ::management::QuotaInfo* GetQuotaUsageResponse::mutable_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::management::QuotaInfo* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:management.GetQuotaUsageResponse.entry)
  return _msg;
}
inline void GetQuotaUsageResponse::set_allocated_entry(::management::QuotaInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.entry_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.entry_ = reinterpret_cast<::management::QuotaInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetQuotaUsageResponse.entry)
}

// optional uint64 refresh_period_s = 2;
inline bool GetQuotaUsageResponse::has_refresh_period_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetQuotaUsageResponse::clear_refresh_period_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.refresh_period_s_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t GetQuotaUsageResponse::refresh_period_s() const {
  // @@protoc_insertion_point(field_get:management.GetQuotaUsageResponse.refresh_period_s)
  return _internal_refresh_period_s();
}
inline void GetQuotaUsageResponse::set_refresh_period_s(::uint64_t value) {
  _internal_set_refresh_period_s(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:management.GetQuotaUsageResponse.refresh_period_s)
}
inline ::uint64_t GetQuotaUsageResponse::_internal_refresh_period_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.refresh_period_s_;
}
inline void GetQuotaUsageResponse::_internal_set_refresh_period_s(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.refresh_period_s_ = value;
}

// -------------------------------------------------------------------

// GetLicenseRequest

// optional bool reload = 1;
inline bool GetLicenseRequest::has_reload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetLicenseRequest::clear_reload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reload_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GetLicenseRequest::reload() const {
  // @@protoc_insertion_point(field_get:management.GetLicenseRequest.reload)
  return _internal_reload();
}
inline void GetLicenseRequest::set_reload(bool value) {
  _internal_set_reload(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:management.GetLicenseRequest.reload)
}
inline bool GetLicenseRequest::_internal_reload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reload_;
}
inline void GetLicenseRequest::_internal_set_reload(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reload_ = value;
}

// -------------------------------------------------------------------

// GetLicenseResponse

// optional .license.GetCertDataResult cert_data = 1;
inline bool GetLicenseResponse::has_cert_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cert_data_ != nullptr);
  return value;
}
inline const ::license::GetCertDataResult& GetLicenseResponse::_internal_cert_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::license::GetCertDataResult* p = _impl_.cert_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::license::GetCertDataResult&>(::license::_GetCertDataResult_default_instance_);
}
inline const ::license::GetCertDataResult& GetLicenseResponse::cert_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:management.GetLicenseResponse.cert_data)
  return _internal_cert_data();
}
inline void GetLicenseResponse::unsafe_arena_set_allocated_cert_data(::license::GetCertDataResult* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cert_data_);
  }
  _impl_.cert_data_ = reinterpret_cast<::license::GetCertDataResult*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:management.GetLicenseResponse.cert_data)
}
inline ::license::GetCertDataResult* GetLicenseResponse::release_cert_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::license::GetCertDataResult* released = _impl_.cert_data_;
  _impl_.cert_data_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::license::GetCertDataResult* GetLicenseResponse::unsafe_arena_release_cert_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:management.GetLicenseResponse.cert_data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::license::GetCertDataResult* temp = _impl_.cert_data_;
  _impl_.cert_data_ = nullptr;
  return temp;
}
inline ::license::GetCertDataResult* GetLicenseResponse::_internal_mutable_cert_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cert_data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::license::GetCertDataResult>(GetArena());
    _impl_.cert_data_ = reinterpret_cast<::license::GetCertDataResult*>(p);
  }
  return _impl_.cert_data_;
}
inline ::license::GetCertDataResult* GetLicenseResponse::mutable_cert_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::license::GetCertDataResult* _msg = _internal_mutable_cert_data();
  // @@protoc_insertion_point(field_mutable:management.GetLicenseResponse.cert_data)
  return _msg;
}
inline void GetLicenseResponse::set_allocated_cert_data(::license::GetCertDataResult* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cert_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.cert_data_ = reinterpret_cast<::license::GetCertDataResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:management.GetLicenseResponse.cert_data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace management


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // management_2eproto_2epb_2eh
