// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: beegfs.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_beegfs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_beegfs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_beegfs_2eproto;
namespace beegfs {
class EntityIdSet;
struct EntityIdSetDefaultTypeInternal;
extern EntityIdSetDefaultTypeInternal _EntityIdSet_default_instance_;
class EntityIdVariant;
struct EntityIdVariantDefaultTypeInternal;
extern EntityIdVariantDefaultTypeInternal _EntityIdVariant_default_instance_;
class GetBuddyGroupsRequest;
struct GetBuddyGroupsRequestDefaultTypeInternal;
extern GetBuddyGroupsRequestDefaultTypeInternal _GetBuddyGroupsRequest_default_instance_;
class GetBuddyGroupsResponse;
struct GetBuddyGroupsResponseDefaultTypeInternal;
extern GetBuddyGroupsResponseDefaultTypeInternal _GetBuddyGroupsResponse_default_instance_;
class GetBuddyGroupsResponse_BuddyGroup;
struct GetBuddyGroupsResponse_BuddyGroupDefaultTypeInternal;
extern GetBuddyGroupsResponse_BuddyGroupDefaultTypeInternal _GetBuddyGroupsResponse_BuddyGroup_default_instance_;
class GetNodesRequest;
struct GetNodesRequestDefaultTypeInternal;
extern GetNodesRequestDefaultTypeInternal _GetNodesRequest_default_instance_;
class GetNodesResponse;
struct GetNodesResponseDefaultTypeInternal;
extern GetNodesResponseDefaultTypeInternal _GetNodesResponse_default_instance_;
class GetNodesResponse_Node;
struct GetNodesResponse_NodeDefaultTypeInternal;
extern GetNodesResponse_NodeDefaultTypeInternal _GetNodesResponse_Node_default_instance_;
class GetNodesResponse_Node_Nic;
struct GetNodesResponse_Node_NicDefaultTypeInternal;
extern GetNodesResponse_Node_NicDefaultTypeInternal _GetNodesResponse_Node_Nic_default_instance_;
class GetStoragePoolsRequest;
struct GetStoragePoolsRequestDefaultTypeInternal;
extern GetStoragePoolsRequestDefaultTypeInternal _GetStoragePoolsRequest_default_instance_;
class GetStoragePoolsResponse;
struct GetStoragePoolsResponseDefaultTypeInternal;
extern GetStoragePoolsResponseDefaultTypeInternal _GetStoragePoolsResponse_default_instance_;
class GetStoragePoolsResponse_StoragePool;
struct GetStoragePoolsResponse_StoragePoolDefaultTypeInternal;
extern GetStoragePoolsResponse_StoragePoolDefaultTypeInternal _GetStoragePoolsResponse_StoragePool_default_instance_;
class GetTargetsRequest;
struct GetTargetsRequestDefaultTypeInternal;
extern GetTargetsRequestDefaultTypeInternal _GetTargetsRequest_default_instance_;
class GetTargetsResponse;
struct GetTargetsResponseDefaultTypeInternal;
extern GetTargetsResponseDefaultTypeInternal _GetTargetsResponse_default_instance_;
class GetTargetsResponse_Target;
struct GetTargetsResponse_TargetDefaultTypeInternal;
extern GetTargetsResponse_TargetDefaultTypeInternal _GetTargetsResponse_Target_default_instance_;
class LegacyId;
struct LegacyIdDefaultTypeInternal;
extern LegacyIdDefaultTypeInternal _LegacyId_default_instance_;
class SetAliasRequest;
struct SetAliasRequestDefaultTypeInternal;
extern SetAliasRequestDefaultTypeInternal _SetAliasRequest_default_instance_;
class SetAliasResponse;
struct SetAliasResponseDefaultTypeInternal;
extern SetAliasResponseDefaultTypeInternal _SetAliasResponse_default_instance_;
}  // namespace beegfs
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace beegfs {
enum EntityType : int {
  ENTITY_TYPE_UNSPECIFIED = 0,
  NODE = 1,
  TARGET = 2,
  BUDDY_GROUP = 3,
  STORAGE_POOL = 4,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EntityType_IsValid(int value);
extern const uint32_t EntityType_internal_data_[];
constexpr EntityType EntityType_MIN = static_cast<EntityType>(0);
constexpr EntityType EntityType_MAX = static_cast<EntityType>(4);
constexpr int EntityType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
EntityType_descriptor();
template <typename T>
const std::string& EntityType_Name(T value) {
  static_assert(std::is_same<T, EntityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EntityType_Name().");
  return EntityType_Name(static_cast<EntityType>(value));
}
template <>
inline const std::string& EntityType_Name(EntityType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EntityType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool EntityType_Parse(absl::string_view name, EntityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType>(
      EntityType_descriptor(), name, value);
}
enum NodeType : int {
  NODE_TYPE_UNSPECIFIED = 0,
  CLIENT = 1,
  META = 2,
  STORAGE = 3,
  MANAGEMENT = 4,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeType_IsValid(int value);
extern const uint32_t NodeType_internal_data_[];
constexpr NodeType NodeType_MIN = static_cast<NodeType>(0);
constexpr NodeType NodeType_MAX = static_cast<NodeType>(4);
constexpr int NodeType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
NodeType_descriptor();
template <typename T>
const std::string& NodeType_Name(T value) {
  static_assert(std::is_same<T, NodeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NodeType_Name().");
  return NodeType_Name(static_cast<NodeType>(value));
}
template <>
inline const std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NodeType_Parse(absl::string_view name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
      NodeType_descriptor(), name, value);
}
enum ReachabilityState : int {
  REACHABILITY_STATE_UNSPECIFIED = 0,
  ONLINE = 1,
  POFFLINE = 2,
  OFFLINE = 3,
  ReachabilityState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ReachabilityState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ReachabilityState_IsValid(int value);
extern const uint32_t ReachabilityState_internal_data_[];
constexpr ReachabilityState ReachabilityState_MIN = static_cast<ReachabilityState>(0);
constexpr ReachabilityState ReachabilityState_MAX = static_cast<ReachabilityState>(3);
constexpr int ReachabilityState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ReachabilityState_descriptor();
template <typename T>
const std::string& ReachabilityState_Name(T value) {
  static_assert(std::is_same<T, ReachabilityState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReachabilityState_Name().");
  return ReachabilityState_Name(static_cast<ReachabilityState>(value));
}
template <>
inline const std::string& ReachabilityState_Name(ReachabilityState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ReachabilityState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ReachabilityState_Parse(absl::string_view name, ReachabilityState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReachabilityState>(
      ReachabilityState_descriptor(), name, value);
}
enum ConsistencyState : int {
  CONSISTENCY_STATE_UNSPECIFIED = 0,
  GOOD = 1,
  NEEDS_RESYNC = 2,
  BAD = 3,
  ConsistencyState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ConsistencyState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ConsistencyState_IsValid(int value);
extern const uint32_t ConsistencyState_internal_data_[];
constexpr ConsistencyState ConsistencyState_MIN = static_cast<ConsistencyState>(0);
constexpr ConsistencyState ConsistencyState_MAX = static_cast<ConsistencyState>(3);
constexpr int ConsistencyState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ConsistencyState_descriptor();
template <typename T>
const std::string& ConsistencyState_Name(T value) {
  static_assert(std::is_same<T, ConsistencyState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConsistencyState_Name().");
  return ConsistencyState_Name(static_cast<ConsistencyState>(value));
}
template <>
inline const std::string& ConsistencyState_Name(ConsistencyState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ConsistencyState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ConsistencyState_Parse(absl::string_view name, ConsistencyState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConsistencyState>(
      ConsistencyState_descriptor(), name, value);
}
enum CapacityPool : int {
  CAPACITY_POOL_UNSPECIFIED = 0,
  NORMAL = 1,
  LOW = 2,
  EMERGENCY = 3,
  CapacityPool_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CapacityPool_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CapacityPool_IsValid(int value);
extern const uint32_t CapacityPool_internal_data_[];
constexpr CapacityPool CapacityPool_MIN = static_cast<CapacityPool>(0);
constexpr CapacityPool CapacityPool_MAX = static_cast<CapacityPool>(3);
constexpr int CapacityPool_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CapacityPool_descriptor();
template <typename T>
const std::string& CapacityPool_Name(T value) {
  static_assert(std::is_same<T, CapacityPool>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CapacityPool_Name().");
  return CapacityPool_Name(static_cast<CapacityPool>(value));
}
template <>
inline const std::string& CapacityPool_Name(CapacityPool value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CapacityPool_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CapacityPool_Parse(absl::string_view name, CapacityPool* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CapacityPool>(
      CapacityPool_descriptor(), name, value);
}
enum NicType : int {
  NIC_TYPE_UNSPECIFIED = 0,
  ETHERNET = 1,
  RDMA = 2,
  NicType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NicType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NicType_IsValid(int value);
extern const uint32_t NicType_internal_data_[];
constexpr NicType NicType_MIN = static_cast<NicType>(0);
constexpr NicType NicType_MAX = static_cast<NicType>(2);
constexpr int NicType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NicType_descriptor();
template <typename T>
const std::string& NicType_Name(T value) {
  static_assert(std::is_same<T, NicType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NicType_Name().");
  return NicType_Name(static_cast<NicType>(value));
}
template <>
inline const std::string& NicType_Name(NicType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NicType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NicType_Parse(absl::string_view name, NicType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NicType>(
      NicType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SetAliasResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:beegfs.SetAliasResponse) */ {
 public:
  inline SetAliasResponse() : SetAliasResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetAliasResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetAliasResponse(const SetAliasResponse& from) : SetAliasResponse(nullptr, from) {}
  inline SetAliasResponse(SetAliasResponse&& from) noexcept
      : SetAliasResponse(nullptr, std::move(from)) {}
  inline SetAliasResponse& operator=(const SetAliasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAliasResponse& operator=(SetAliasResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAliasResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAliasResponse* internal_default_instance() {
    return reinterpret_cast<const SetAliasResponse*>(
        &_SetAliasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(SetAliasResponse& a, SetAliasResponse& b) { a.Swap(&b); }
  inline void Swap(SetAliasResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAliasResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAliasResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetAliasResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetAliasResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetAliasResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.SetAliasResponse"; }

 protected:
  explicit SetAliasResponse(::google::protobuf::Arena* arena);
  SetAliasResponse(::google::protobuf::Arena* arena, const SetAliasResponse& from);
  SetAliasResponse(::google::protobuf::Arena* arena, SetAliasResponse&& from) noexcept
      : SetAliasResponse(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:beegfs.SetAliasResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class LegacyId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.LegacyId) */ {
 public:
  inline LegacyId() : LegacyId(nullptr) {}
  ~LegacyId() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LegacyId(
      ::google::protobuf::internal::ConstantInitialized);

  inline LegacyId(const LegacyId& from) : LegacyId(nullptr, from) {}
  inline LegacyId(LegacyId&& from) noexcept
      : LegacyId(nullptr, std::move(from)) {}
  inline LegacyId& operator=(const LegacyId& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegacyId& operator=(LegacyId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegacyId& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegacyId* internal_default_instance() {
    return reinterpret_cast<const LegacyId*>(
        &_LegacyId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(LegacyId& a, LegacyId& b) { a.Swap(&b); }
  inline void Swap(LegacyId* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegacyId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegacyId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LegacyId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LegacyId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LegacyId& from) { LegacyId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LegacyId* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.LegacyId"; }

 protected:
  explicit LegacyId(::google::protobuf::Arena* arena);
  LegacyId(::google::protobuf::Arena* arena, const LegacyId& from);
  LegacyId(::google::protobuf::Arena* arena, LegacyId&& from) noexcept
      : LegacyId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumIdFieldNumber = 1,
    kNodeTypeFieldNumber = 2,
    kEntityTypeFieldNumber = 3,
  };
  // uint32 num_id = 1;
  void clear_num_id() ;
  ::uint32_t num_id() const;
  void set_num_id(::uint32_t value);

  private:
  ::uint32_t _internal_num_id() const;
  void _internal_set_num_id(::uint32_t value);

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // .beegfs.EntityType entity_type = 3;
  void clear_entity_type() ;
  ::beegfs::EntityType entity_type() const;
  void set_entity_type(::beegfs::EntityType value);

  private:
  ::beegfs::EntityType _internal_entity_type() const;
  void _internal_set_entity_type(::beegfs::EntityType value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.LegacyId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t num_id_;
    int node_type_;
    int entity_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetTargetsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:beegfs.GetTargetsRequest) */ {
 public:
  inline GetTargetsRequest() : GetTargetsRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTargetsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTargetsRequest(const GetTargetsRequest& from) : GetTargetsRequest(nullptr, from) {}
  inline GetTargetsRequest(GetTargetsRequest&& from) noexcept
      : GetTargetsRequest(nullptr, std::move(from)) {}
  inline GetTargetsRequest& operator=(const GetTargetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTargetsRequest& operator=(GetTargetsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTargetsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTargetsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTargetsRequest*>(
        &_GetTargetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(GetTargetsRequest& a, GetTargetsRequest& b) { a.Swap(&b); }
  inline void Swap(GetTargetsRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTargetsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTargetsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetTargetsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetTargetsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetTargetsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetTargetsRequest"; }

 protected:
  explicit GetTargetsRequest(::google::protobuf::Arena* arena);
  GetTargetsRequest(::google::protobuf::Arena* arena, const GetTargetsRequest& from);
  GetTargetsRequest(::google::protobuf::Arena* arena, GetTargetsRequest&& from) noexcept
      : GetTargetsRequest(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:beegfs.GetTargetsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetStoragePoolsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:beegfs.GetStoragePoolsRequest) */ {
 public:
  inline GetStoragePoolsRequest() : GetStoragePoolsRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetStoragePoolsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetStoragePoolsRequest(const GetStoragePoolsRequest& from) : GetStoragePoolsRequest(nullptr, from) {}
  inline GetStoragePoolsRequest(GetStoragePoolsRequest&& from) noexcept
      : GetStoragePoolsRequest(nullptr, std::move(from)) {}
  inline GetStoragePoolsRequest& operator=(const GetStoragePoolsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoragePoolsRequest& operator=(GetStoragePoolsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoragePoolsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoragePoolsRequest* internal_default_instance() {
    return reinterpret_cast<const GetStoragePoolsRequest*>(
        &_GetStoragePoolsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(GetStoragePoolsRequest& a, GetStoragePoolsRequest& b) { a.Swap(&b); }
  inline void Swap(GetStoragePoolsRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoragePoolsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoragePoolsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetStoragePoolsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetStoragePoolsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetStoragePoolsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetStoragePoolsRequest"; }

 protected:
  explicit GetStoragePoolsRequest(::google::protobuf::Arena* arena);
  GetStoragePoolsRequest(::google::protobuf::Arena* arena, const GetStoragePoolsRequest& from);
  GetStoragePoolsRequest(::google::protobuf::Arena* arena, GetStoragePoolsRequest&& from) noexcept
      : GetStoragePoolsRequest(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:beegfs.GetStoragePoolsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResponse_Node_Nic final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetNodesResponse.Node.Nic) */ {
 public:
  inline GetNodesResponse_Node_Nic() : GetNodesResponse_Node_Nic(nullptr) {}
  ~GetNodesResponse_Node_Nic() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResponse_Node_Nic(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResponse_Node_Nic(const GetNodesResponse_Node_Nic& from) : GetNodesResponse_Node_Nic(nullptr, from) {}
  inline GetNodesResponse_Node_Nic(GetNodesResponse_Node_Nic&& from) noexcept
      : GetNodesResponse_Node_Nic(nullptr, std::move(from)) {}
  inline GetNodesResponse_Node_Nic& operator=(const GetNodesResponse_Node_Nic& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResponse_Node_Nic& operator=(GetNodesResponse_Node_Nic&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResponse_Node_Nic& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResponse_Node_Nic* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse_Node_Nic*>(
        &_GetNodesResponse_Node_Nic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GetNodesResponse_Node_Nic& a, GetNodesResponse_Node_Nic& b) { a.Swap(&b); }
  inline void Swap(GetNodesResponse_Node_Nic* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResponse_Node_Nic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResponse_Node_Nic* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResponse_Node_Nic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResponse_Node_Nic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResponse_Node_Nic& from) { GetNodesResponse_Node_Nic::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetNodesResponse_Node_Nic* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetNodesResponse.Node.Nic"; }

 protected:
  explicit GetNodesResponse_Node_Nic(::google::protobuf::Arena* arena);
  GetNodesResponse_Node_Nic(::google::protobuf::Arena* arena, const GetNodesResponse_Node_Nic& from);
  GetNodesResponse_Node_Nic(::google::protobuf::Arena* arena, GetNodesResponse_Node_Nic&& from) noexcept
      : GetNodesResponse_Node_Nic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddrFieldNumber = 1,
    kNameFieldNumber = 2,
    kNicTypeFieldNumber = 3,
  };
  // string addr = 1;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .beegfs.NicType nic_type = 3;
  void clear_nic_type() ;
  ::beegfs::NicType nic_type() const;
  void set_nic_type(::beegfs::NicType value);

  private:
  ::beegfs::NicType _internal_nic_type() const;
  void _internal_set_nic_type(::beegfs::NicType value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetNodesResponse.Node.Nic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    int nic_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetNodesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetNodesRequest) */ {
 public:
  inline GetNodesRequest() : GetNodesRequest(nullptr) {}
  ~GetNodesRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesRequest(const GetNodesRequest& from) : GetNodesRequest(nullptr, from) {}
  inline GetNodesRequest(GetNodesRequest&& from) noexcept
      : GetNodesRequest(nullptr, std::move(from)) {}
  inline GetNodesRequest& operator=(const GetNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesRequest& operator=(GetNodesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodesRequest*>(
        &_GetNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GetNodesRequest& a, GetNodesRequest& b) { a.Swap(&b); }
  inline void Swap(GetNodesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesRequest& from) { GetNodesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetNodesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetNodesRequest"; }

 protected:
  explicit GetNodesRequest(::google::protobuf::Arena* arena);
  GetNodesRequest(::google::protobuf::Arena* arena, const GetNodesRequest& from);
  GetNodesRequest(::google::protobuf::Arena* arena, GetNodesRequest&& from) noexcept
      : GetNodesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIncludeNicsFieldNumber = 1,
  };
  // bool include_nics = 1;
  void clear_include_nics() ;
  bool include_nics() const;
  void set_include_nics(bool value);

  private:
  bool _internal_include_nics() const;
  void _internal_set_include_nics(bool value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetNodesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool include_nics_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetBuddyGroupsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:beegfs.GetBuddyGroupsRequest) */ {
 public:
  inline GetBuddyGroupsRequest() : GetBuddyGroupsRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBuddyGroupsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBuddyGroupsRequest(const GetBuddyGroupsRequest& from) : GetBuddyGroupsRequest(nullptr, from) {}
  inline GetBuddyGroupsRequest(GetBuddyGroupsRequest&& from) noexcept
      : GetBuddyGroupsRequest(nullptr, std::move(from)) {}
  inline GetBuddyGroupsRequest& operator=(const GetBuddyGroupsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBuddyGroupsRequest& operator=(GetBuddyGroupsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBuddyGroupsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBuddyGroupsRequest* internal_default_instance() {
    return reinterpret_cast<const GetBuddyGroupsRequest*>(
        &_GetBuddyGroupsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GetBuddyGroupsRequest& a, GetBuddyGroupsRequest& b) { a.Swap(&b); }
  inline void Swap(GetBuddyGroupsRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBuddyGroupsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBuddyGroupsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetBuddyGroupsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBuddyGroupsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBuddyGroupsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetBuddyGroupsRequest"; }

 protected:
  explicit GetBuddyGroupsRequest(::google::protobuf::Arena* arena);
  GetBuddyGroupsRequest(::google::protobuf::Arena* arena, const GetBuddyGroupsRequest& from);
  GetBuddyGroupsRequest(::google::protobuf::Arena* arena, GetBuddyGroupsRequest&& from) noexcept
      : GetBuddyGroupsRequest(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:beegfs.GetBuddyGroupsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class EntityIdVariant final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.EntityIdVariant) */ {
 public:
  inline EntityIdVariant() : EntityIdVariant(nullptr) {}
  ~EntityIdVariant() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityIdVariant(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntityIdVariant(const EntityIdVariant& from) : EntityIdVariant(nullptr, from) {}
  inline EntityIdVariant(EntityIdVariant&& from) noexcept
      : EntityIdVariant(nullptr, std::move(from)) {}
  inline EntityIdVariant& operator=(const EntityIdVariant& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityIdVariant& operator=(EntityIdVariant&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityIdVariant& default_instance() {
    return *internal_default_instance();
  }
  enum VariantCase {
    kUid = 1,
    kLegacyId = 2,
    kAlias = 3,
    VARIANT_NOT_SET = 0,
  };
  static inline const EntityIdVariant* internal_default_instance() {
    return reinterpret_cast<const EntityIdVariant*>(
        &_EntityIdVariant_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(EntityIdVariant& a, EntityIdVariant& b) { a.Swap(&b); }
  inline void Swap(EntityIdVariant* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityIdVariant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityIdVariant* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EntityIdVariant>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityIdVariant& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityIdVariant& from) { EntityIdVariant::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntityIdVariant* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.EntityIdVariant"; }

 protected:
  explicit EntityIdVariant(::google::protobuf::Arena* arena);
  EntityIdVariant(::google::protobuf::Arena* arena, const EntityIdVariant& from);
  EntityIdVariant(::google::protobuf::Arena* arena, EntityIdVariant&& from) noexcept
      : EntityIdVariant(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kLegacyIdFieldNumber = 2,
    kAliasFieldNumber = 3,
  };
  // uint64 uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // .beegfs.LegacyId legacy_id = 2;
  bool has_legacy_id() const;
  private:
  bool _internal_has_legacy_id() const;

  public:
  void clear_legacy_id() ;
  const ::beegfs::LegacyId& legacy_id() const;
  PROTOBUF_NODISCARD ::beegfs::LegacyId* release_legacy_id();
  ::beegfs::LegacyId* mutable_legacy_id();
  void set_allocated_legacy_id(::beegfs::LegacyId* value);
  void unsafe_arena_set_allocated_legacy_id(::beegfs::LegacyId* value);
  ::beegfs::LegacyId* unsafe_arena_release_legacy_id();

  private:
  const ::beegfs::LegacyId& _internal_legacy_id() const;
  ::beegfs::LegacyId* _internal_mutable_legacy_id();

  public:
  // string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:beegfs.EntityIdVariant)
 private:
  class _Internal;
  void set_has_uid();
  void set_has_legacy_id();
  void set_has_alias();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t uid_;
      ::beegfs::LegacyId* legacy_id_;
      ::google::protobuf::internal::ArenaStringPtr alias_;
    } variant_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class EntityIdSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.EntityIdSet) */ {
 public:
  inline EntityIdSet() : EntityIdSet(nullptr) {}
  ~EntityIdSet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityIdSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntityIdSet(const EntityIdSet& from) : EntityIdSet(nullptr, from) {}
  inline EntityIdSet(EntityIdSet&& from) noexcept
      : EntityIdSet(nullptr, std::move(from)) {}
  inline EntityIdSet& operator=(const EntityIdSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityIdSet& operator=(EntityIdSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityIdSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityIdSet* internal_default_instance() {
    return reinterpret_cast<const EntityIdSet*>(
        &_EntityIdSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(EntityIdSet& a, EntityIdSet& b) { a.Swap(&b); }
  inline void Swap(EntityIdSet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityIdSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityIdSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EntityIdSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityIdSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityIdSet& from) { EntityIdSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntityIdSet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.EntityIdSet"; }

 protected:
  explicit EntityIdSet(::google::protobuf::Arena* arena);
  EntityIdSet(::google::protobuf::Arena* arena, const EntityIdSet& from);
  EntityIdSet(::google::protobuf::Arena* arena, EntityIdSet&& from) noexcept
      : EntityIdSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAliasFieldNumber = 2,
    kLegacyIdFieldNumber = 3,
    kUidFieldNumber = 1,
  };
  // string alias = 2;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // .beegfs.LegacyId legacy_id = 3;
  bool has_legacy_id() const;
  void clear_legacy_id() ;
  const ::beegfs::LegacyId& legacy_id() const;
  PROTOBUF_NODISCARD ::beegfs::LegacyId* release_legacy_id();
  ::beegfs::LegacyId* mutable_legacy_id();
  void set_allocated_legacy_id(::beegfs::LegacyId* value);
  void unsafe_arena_set_allocated_legacy_id(::beegfs::LegacyId* value);
  ::beegfs::LegacyId* unsafe_arena_release_legacy_id();

  private:
  const ::beegfs::LegacyId& _internal_legacy_id() const;
  ::beegfs::LegacyId* _internal_mutable_legacy_id();

  public:
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.EntityIdSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::beegfs::LegacyId* legacy_id_;
    ::uint64_t uid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class SetAliasRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.SetAliasRequest) */ {
 public:
  inline SetAliasRequest() : SetAliasRequest(nullptr) {}
  ~SetAliasRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetAliasRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetAliasRequest(const SetAliasRequest& from) : SetAliasRequest(nullptr, from) {}
  inline SetAliasRequest(SetAliasRequest&& from) noexcept
      : SetAliasRequest(nullptr, std::move(from)) {}
  inline SetAliasRequest& operator=(const SetAliasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAliasRequest& operator=(SetAliasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAliasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAliasRequest* internal_default_instance() {
    return reinterpret_cast<const SetAliasRequest*>(
        &_SetAliasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SetAliasRequest& a, SetAliasRequest& b) { a.Swap(&b); }
  inline void Swap(SetAliasRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAliasRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAliasRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SetAliasRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetAliasRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetAliasRequest& from) { SetAliasRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetAliasRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.SetAliasRequest"; }

 protected:
  explicit SetAliasRequest(::google::protobuf::Arena* arena);
  SetAliasRequest(::google::protobuf::Arena* arena, const SetAliasRequest& from);
  SetAliasRequest(::google::protobuf::Arena* arena, SetAliasRequest&& from) noexcept
      : SetAliasRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewAliasFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // string new_alias = 2;
  void clear_new_alias() ;
  const std::string& new_alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_alias(Arg_&& arg, Args_... args);
  std::string* mutable_new_alias();
  PROTOBUF_NODISCARD std::string* release_new_alias();
  void set_allocated_new_alias(std::string* value);

  private:
  const std::string& _internal_new_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_alias(
      const std::string& value);
  std::string* _internal_mutable_new_alias();

  public:
  // .beegfs.EntityIdVariant entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id() ;
  const ::beegfs::EntityIdVariant& entity_id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdVariant* release_entity_id();
  ::beegfs::EntityIdVariant* mutable_entity_id();
  void set_allocated_entity_id(::beegfs::EntityIdVariant* value);
  void unsafe_arena_set_allocated_entity_id(::beegfs::EntityIdVariant* value);
  ::beegfs::EntityIdVariant* unsafe_arena_release_entity_id();

  private:
  const ::beegfs::EntityIdVariant& _internal_entity_id() const;
  ::beegfs::EntityIdVariant* _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:beegfs.SetAliasRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_alias_;
    ::beegfs::EntityIdVariant* entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetTargetsResponse_Target final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetTargetsResponse.Target) */ {
 public:
  inline GetTargetsResponse_Target() : GetTargetsResponse_Target(nullptr) {}
  ~GetTargetsResponse_Target() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTargetsResponse_Target(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTargetsResponse_Target(const GetTargetsResponse_Target& from) : GetTargetsResponse_Target(nullptr, from) {}
  inline GetTargetsResponse_Target(GetTargetsResponse_Target&& from) noexcept
      : GetTargetsResponse_Target(nullptr, std::move(from)) {}
  inline GetTargetsResponse_Target& operator=(const GetTargetsResponse_Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTargetsResponse_Target& operator=(GetTargetsResponse_Target&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTargetsResponse_Target& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTargetsResponse_Target* internal_default_instance() {
    return reinterpret_cast<const GetTargetsResponse_Target*>(
        &_GetTargetsResponse_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetTargetsResponse_Target& a, GetTargetsResponse_Target& b) { a.Swap(&b); }
  inline void Swap(GetTargetsResponse_Target* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTargetsResponse_Target* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTargetsResponse_Target* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetTargetsResponse_Target>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTargetsResponse_Target& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTargetsResponse_Target& from) { GetTargetsResponse_Target::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTargetsResponse_Target* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetTargetsResponse.Target"; }

 protected:
  explicit GetTargetsResponse_Target(::google::protobuf::Arena* arena);
  GetTargetsResponse_Target(::google::protobuf::Arena* arena, const GetTargetsResponse_Target& from);
  GetTargetsResponse_Target(::google::protobuf::Arena* arena, GetTargetsResponse_Target&& from) noexcept
      : GetTargetsResponse_Target(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNodeFieldNumber = 11,
    kStoragePoolFieldNumber = 12,
    kNodeTypeFieldNumber = 2,
    kReachabilityStateFieldNumber = 3,
    kLastContactSFieldNumber = 5,
    kTotalSpaceBytesFieldNumber = 6,
    kFreeSpaceBytesFieldNumber = 7,
    kConsistencyStateFieldNumber = 4,
    kCapPoolFieldNumber = 10,
    kTotalInodesFieldNumber = 8,
    kFreeInodesFieldNumber = 9,
  };
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // .beegfs.EntityIdSet node = 11;
  bool has_node() const;
  void clear_node() ;
  const ::beegfs::EntityIdSet& node() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_node();
  ::beegfs::EntityIdSet* mutable_node();
  void set_allocated_node(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_node();

  private:
  const ::beegfs::EntityIdSet& _internal_node() const;
  ::beegfs::EntityIdSet* _internal_mutable_node();

  public:
  // optional .beegfs.EntityIdSet storage_pool = 12;
  bool has_storage_pool() const;
  void clear_storage_pool() ;
  const ::beegfs::EntityIdSet& storage_pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_storage_pool();
  ::beegfs::EntityIdSet* mutable_storage_pool();
  void set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_storage_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_storage_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_storage_pool();

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // .beegfs.ReachabilityState reachability_state = 3;
  void clear_reachability_state() ;
  ::beegfs::ReachabilityState reachability_state() const;
  void set_reachability_state(::beegfs::ReachabilityState value);

  private:
  ::beegfs::ReachabilityState _internal_reachability_state() const;
  void _internal_set_reachability_state(::beegfs::ReachabilityState value);

  public:
  // optional uint64 last_contact_s = 5;
  bool has_last_contact_s() const;
  void clear_last_contact_s() ;
  ::uint64_t last_contact_s() const;
  void set_last_contact_s(::uint64_t value);

  private:
  ::uint64_t _internal_last_contact_s() const;
  void _internal_set_last_contact_s(::uint64_t value);

  public:
  // optional uint64 total_space_bytes = 6;
  bool has_total_space_bytes() const;
  void clear_total_space_bytes() ;
  ::uint64_t total_space_bytes() const;
  void set_total_space_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_total_space_bytes() const;
  void _internal_set_total_space_bytes(::uint64_t value);

  public:
  // optional uint64 free_space_bytes = 7;
  bool has_free_space_bytes() const;
  void clear_free_space_bytes() ;
  ::uint64_t free_space_bytes() const;
  void set_free_space_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_free_space_bytes() const;
  void _internal_set_free_space_bytes(::uint64_t value);

  public:
  // .beegfs.ConsistencyState consistency_state = 4;
  void clear_consistency_state() ;
  ::beegfs::ConsistencyState consistency_state() const;
  void set_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_consistency_state() const;
  void _internal_set_consistency_state(::beegfs::ConsistencyState value);

  public:
  // .beegfs.CapacityPool cap_pool = 10;
  void clear_cap_pool() ;
  ::beegfs::CapacityPool cap_pool() const;
  void set_cap_pool(::beegfs::CapacityPool value);

  private:
  ::beegfs::CapacityPool _internal_cap_pool() const;
  void _internal_set_cap_pool(::beegfs::CapacityPool value);

  public:
  // optional uint64 total_inodes = 8;
  bool has_total_inodes() const;
  void clear_total_inodes() ;
  ::uint64_t total_inodes() const;
  void set_total_inodes(::uint64_t value);

  private:
  ::uint64_t _internal_total_inodes() const;
  void _internal_set_total_inodes(::uint64_t value);

  public:
  // optional uint64 free_inodes = 9;
  bool has_free_inodes() const;
  void clear_free_inodes() ;
  ::uint64_t free_inodes() const;
  void set_free_inodes(::uint64_t value);

  private:
  ::uint64_t _internal_free_inodes() const;
  void _internal_set_free_inodes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetTargetsResponse.Target)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* id_;
    ::beegfs::EntityIdSet* node_;
    ::beegfs::EntityIdSet* storage_pool_;
    int node_type_;
    int reachability_state_;
    ::uint64_t last_contact_s_;
    ::uint64_t total_space_bytes_;
    ::uint64_t free_space_bytes_;
    int consistency_state_;
    int cap_pool_;
    ::uint64_t total_inodes_;
    ::uint64_t free_inodes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetStoragePoolsResponse_StoragePool final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetStoragePoolsResponse.StoragePool) */ {
 public:
  inline GetStoragePoolsResponse_StoragePool() : GetStoragePoolsResponse_StoragePool(nullptr) {}
  ~GetStoragePoolsResponse_StoragePool() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetStoragePoolsResponse_StoragePool(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetStoragePoolsResponse_StoragePool(const GetStoragePoolsResponse_StoragePool& from) : GetStoragePoolsResponse_StoragePool(nullptr, from) {}
  inline GetStoragePoolsResponse_StoragePool(GetStoragePoolsResponse_StoragePool&& from) noexcept
      : GetStoragePoolsResponse_StoragePool(nullptr, std::move(from)) {}
  inline GetStoragePoolsResponse_StoragePool& operator=(const GetStoragePoolsResponse_StoragePool& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoragePoolsResponse_StoragePool& operator=(GetStoragePoolsResponse_StoragePool&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoragePoolsResponse_StoragePool& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoragePoolsResponse_StoragePool* internal_default_instance() {
    return reinterpret_cast<const GetStoragePoolsResponse_StoragePool*>(
        &_GetStoragePoolsResponse_StoragePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(GetStoragePoolsResponse_StoragePool& a, GetStoragePoolsResponse_StoragePool& b) { a.Swap(&b); }
  inline void Swap(GetStoragePoolsResponse_StoragePool* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoragePoolsResponse_StoragePool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoragePoolsResponse_StoragePool* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetStoragePoolsResponse_StoragePool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetStoragePoolsResponse_StoragePool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetStoragePoolsResponse_StoragePool& from) { GetStoragePoolsResponse_StoragePool::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetStoragePoolsResponse_StoragePool* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetStoragePoolsResponse.StoragePool"; }

 protected:
  explicit GetStoragePoolsResponse_StoragePool(::google::protobuf::Arena* arena);
  GetStoragePoolsResponse_StoragePool(::google::protobuf::Arena* arena, const GetStoragePoolsResponse_StoragePool& from);
  GetStoragePoolsResponse_StoragePool(::google::protobuf::Arena* arena, GetStoragePoolsResponse_StoragePool&& from) noexcept
      : GetStoragePoolsResponse_StoragePool(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 2,
    kBuddyGroupsFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .beegfs.EntityIdSet targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::beegfs::EntityIdSet* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_targets();
  public:
  const ::beegfs::EntityIdSet& targets(int index) const;
  ::beegfs::EntityIdSet* add_targets();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& targets() const;
  // repeated .beegfs.EntityIdSet buddy_groups = 3;
  int buddy_groups_size() const;
  private:
  int _internal_buddy_groups_size() const;

  public:
  void clear_buddy_groups() ;
  ::beegfs::EntityIdSet* mutable_buddy_groups(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* mutable_buddy_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& _internal_buddy_groups() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* _internal_mutable_buddy_groups();
  public:
  const ::beegfs::EntityIdSet& buddy_groups(int index) const;
  ::beegfs::EntityIdSet* add_buddy_groups();
  const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& buddy_groups() const;
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetStoragePoolsResponse.StoragePool)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > targets_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::EntityIdSet > buddy_groups_;
    ::beegfs::EntityIdSet* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResponse_Node final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetNodesResponse.Node) */ {
 public:
  inline GetNodesResponse_Node() : GetNodesResponse_Node(nullptr) {}
  ~GetNodesResponse_Node() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResponse_Node(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResponse_Node(const GetNodesResponse_Node& from) : GetNodesResponse_Node(nullptr, from) {}
  inline GetNodesResponse_Node(GetNodesResponse_Node&& from) noexcept
      : GetNodesResponse_Node(nullptr, std::move(from)) {}
  inline GetNodesResponse_Node& operator=(const GetNodesResponse_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResponse_Node& operator=(GetNodesResponse_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResponse_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResponse_Node* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse_Node*>(
        &_GetNodesResponse_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GetNodesResponse_Node& a, GetNodesResponse_Node& b) { a.Swap(&b); }
  inline void Swap(GetNodesResponse_Node* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResponse_Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResponse_Node* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResponse_Node>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResponse_Node& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResponse_Node& from) { GetNodesResponse_Node::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetNodesResponse_Node* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetNodesResponse.Node"; }

 protected:
  explicit GetNodesResponse_Node(::google::protobuf::Arena* arena);
  GetNodesResponse_Node(::google::protobuf::Arena* arena, const GetNodesResponse_Node& from);
  GetNodesResponse_Node(::google::protobuf::Arena* arena, GetNodesResponse_Node&& from) noexcept
      : GetNodesResponse_Node(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Nic = GetNodesResponse_Node_Nic;

  // accessors -------------------------------------------------------
  enum : int {
    kNicsFieldNumber = 4,
    kIdFieldNumber = 1,
    kNodeTypeFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // repeated .beegfs.GetNodesResponse.Node.Nic nics = 4;
  int nics_size() const;
  private:
  int _internal_nics_size() const;

  public:
  void clear_nics() ;
  ::beegfs::GetNodesResponse_Node_Nic* mutable_nics(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>* mutable_nics();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>& _internal_nics() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>* _internal_mutable_nics();
  public:
  const ::beegfs::GetNodesResponse_Node_Nic& nics(int index) const;
  ::beegfs::GetNodesResponse_Node_Nic* add_nics();
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>& nics() const;
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetNodesResponse.Node)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::GetNodesResponse_Node_Nic > nics_;
    ::beegfs::EntityIdSet* id_;
    int node_type_;
    ::uint32_t port_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetBuddyGroupsResponse_BuddyGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetBuddyGroupsResponse.BuddyGroup) */ {
 public:
  inline GetBuddyGroupsResponse_BuddyGroup() : GetBuddyGroupsResponse_BuddyGroup(nullptr) {}
  ~GetBuddyGroupsResponse_BuddyGroup() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBuddyGroupsResponse_BuddyGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBuddyGroupsResponse_BuddyGroup(const GetBuddyGroupsResponse_BuddyGroup& from) : GetBuddyGroupsResponse_BuddyGroup(nullptr, from) {}
  inline GetBuddyGroupsResponse_BuddyGroup(GetBuddyGroupsResponse_BuddyGroup&& from) noexcept
      : GetBuddyGroupsResponse_BuddyGroup(nullptr, std::move(from)) {}
  inline GetBuddyGroupsResponse_BuddyGroup& operator=(const GetBuddyGroupsResponse_BuddyGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBuddyGroupsResponse_BuddyGroup& operator=(GetBuddyGroupsResponse_BuddyGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBuddyGroupsResponse_BuddyGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBuddyGroupsResponse_BuddyGroup* internal_default_instance() {
    return reinterpret_cast<const GetBuddyGroupsResponse_BuddyGroup*>(
        &_GetBuddyGroupsResponse_BuddyGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(GetBuddyGroupsResponse_BuddyGroup& a, GetBuddyGroupsResponse_BuddyGroup& b) { a.Swap(&b); }
  inline void Swap(GetBuddyGroupsResponse_BuddyGroup* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBuddyGroupsResponse_BuddyGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBuddyGroupsResponse_BuddyGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetBuddyGroupsResponse_BuddyGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBuddyGroupsResponse_BuddyGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBuddyGroupsResponse_BuddyGroup& from) { GetBuddyGroupsResponse_BuddyGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBuddyGroupsResponse_BuddyGroup* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetBuddyGroupsResponse.BuddyGroup"; }

 protected:
  explicit GetBuddyGroupsResponse_BuddyGroup(::google::protobuf::Arena* arena);
  GetBuddyGroupsResponse_BuddyGroup(::google::protobuf::Arena* arena, const GetBuddyGroupsResponse_BuddyGroup& from);
  GetBuddyGroupsResponse_BuddyGroup(::google::protobuf::Arena* arena, GetBuddyGroupsResponse_BuddyGroup&& from) noexcept
      : GetBuddyGroupsResponse_BuddyGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kPrimaryTargetFieldNumber = 3,
    kSecondaryTargetFieldNumber = 4,
    kStoragePoolFieldNumber = 7,
    kNodeTypeFieldNumber = 2,
    kPrimaryConsistencyStateFieldNumber = 5,
    kSecondaryConsistencyStateFieldNumber = 6,
  };
  // .beegfs.EntityIdSet id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::beegfs::EntityIdSet& id() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_id();
  ::beegfs::EntityIdSet* mutable_id();
  void set_allocated_id(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_id();

  private:
  const ::beegfs::EntityIdSet& _internal_id() const;
  ::beegfs::EntityIdSet* _internal_mutable_id();

  public:
  // .beegfs.EntityIdSet primary_target = 3;
  bool has_primary_target() const;
  void clear_primary_target() ;
  const ::beegfs::EntityIdSet& primary_target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_primary_target();
  ::beegfs::EntityIdSet* mutable_primary_target();
  void set_allocated_primary_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_primary_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_primary_target();

  private:
  const ::beegfs::EntityIdSet& _internal_primary_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_primary_target();

  public:
  // .beegfs.EntityIdSet secondary_target = 4;
  bool has_secondary_target() const;
  void clear_secondary_target() ;
  const ::beegfs::EntityIdSet& secondary_target() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_secondary_target();
  ::beegfs::EntityIdSet* mutable_secondary_target();
  void set_allocated_secondary_target(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_secondary_target(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_secondary_target();

  private:
  const ::beegfs::EntityIdSet& _internal_secondary_target() const;
  ::beegfs::EntityIdSet* _internal_mutable_secondary_target();

  public:
  // optional .beegfs.EntityIdSet storage_pool = 7;
  bool has_storage_pool() const;
  void clear_storage_pool() ;
  const ::beegfs::EntityIdSet& storage_pool() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_storage_pool();
  ::beegfs::EntityIdSet* mutable_storage_pool();
  void set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_storage_pool();

  private:
  const ::beegfs::EntityIdSet& _internal_storage_pool() const;
  ::beegfs::EntityIdSet* _internal_mutable_storage_pool();

  public:
  // .beegfs.NodeType node_type = 2;
  void clear_node_type() ;
  ::beegfs::NodeType node_type() const;
  void set_node_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_node_type() const;
  void _internal_set_node_type(::beegfs::NodeType value);

  public:
  // .beegfs.ConsistencyState primary_consistency_state = 5;
  void clear_primary_consistency_state() ;
  ::beegfs::ConsistencyState primary_consistency_state() const;
  void set_primary_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_primary_consistency_state() const;
  void _internal_set_primary_consistency_state(::beegfs::ConsistencyState value);

  public:
  // .beegfs.ConsistencyState secondary_consistency_state = 6;
  void clear_secondary_consistency_state() ;
  ::beegfs::ConsistencyState secondary_consistency_state() const;
  void set_secondary_consistency_state(::beegfs::ConsistencyState value);

  private:
  ::beegfs::ConsistencyState _internal_secondary_consistency_state() const;
  void _internal_set_secondary_consistency_state(::beegfs::ConsistencyState value);

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetBuddyGroupsResponse.BuddyGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::beegfs::EntityIdSet* id_;
    ::beegfs::EntityIdSet* primary_target_;
    ::beegfs::EntityIdSet* secondary_target_;
    ::beegfs::EntityIdSet* storage_pool_;
    int node_type_;
    int primary_consistency_state_;
    int secondary_consistency_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetTargetsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetTargetsResponse) */ {
 public:
  inline GetTargetsResponse() : GetTargetsResponse(nullptr) {}
  ~GetTargetsResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTargetsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTargetsResponse(const GetTargetsResponse& from) : GetTargetsResponse(nullptr, from) {}
  inline GetTargetsResponse(GetTargetsResponse&& from) noexcept
      : GetTargetsResponse(nullptr, std::move(from)) {}
  inline GetTargetsResponse& operator=(const GetTargetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTargetsResponse& operator=(GetTargetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTargetsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTargetsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTargetsResponse*>(
        &_GetTargetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetTargetsResponse& a, GetTargetsResponse& b) { a.Swap(&b); }
  inline void Swap(GetTargetsResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTargetsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTargetsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetTargetsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTargetsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTargetsResponse& from) { GetTargetsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTargetsResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetTargetsResponse"; }

 protected:
  explicit GetTargetsResponse(::google::protobuf::Arena* arena);
  GetTargetsResponse(::google::protobuf::Arena* arena, const GetTargetsResponse& from);
  GetTargetsResponse(::google::protobuf::Arena* arena, GetTargetsResponse&& from) noexcept
      : GetTargetsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Target = GetTargetsResponse_Target;

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .beegfs.GetTargetsResponse.Target targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::beegfs::GetTargetsResponse_Target* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>* _internal_mutable_targets();
  public:
  const ::beegfs::GetTargetsResponse_Target& targets(int index) const;
  ::beegfs::GetTargetsResponse_Target* add_targets();
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>& targets() const;
  // @@protoc_insertion_point(class_scope:beegfs.GetTargetsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::beegfs::GetTargetsResponse_Target > targets_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetStoragePoolsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetStoragePoolsResponse) */ {
 public:
  inline GetStoragePoolsResponse() : GetStoragePoolsResponse(nullptr) {}
  ~GetStoragePoolsResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetStoragePoolsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetStoragePoolsResponse(const GetStoragePoolsResponse& from) : GetStoragePoolsResponse(nullptr, from) {}
  inline GetStoragePoolsResponse(GetStoragePoolsResponse&& from) noexcept
      : GetStoragePoolsResponse(nullptr, std::move(from)) {}
  inline GetStoragePoolsResponse& operator=(const GetStoragePoolsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoragePoolsResponse& operator=(GetStoragePoolsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoragePoolsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoragePoolsResponse* internal_default_instance() {
    return reinterpret_cast<const GetStoragePoolsResponse*>(
        &_GetStoragePoolsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetStoragePoolsResponse& a, GetStoragePoolsResponse& b) { a.Swap(&b); }
  inline void Swap(GetStoragePoolsResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoragePoolsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoragePoolsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetStoragePoolsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetStoragePoolsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetStoragePoolsResponse& from) { GetStoragePoolsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetStoragePoolsResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetStoragePoolsResponse"; }

 protected:
  explicit GetStoragePoolsResponse(::google::protobuf::Arena* arena);
  GetStoragePoolsResponse(::google::protobuf::Arena* arena, const GetStoragePoolsResponse& from);
  GetStoragePoolsResponse(::google::protobuf::Arena* arena, GetStoragePoolsResponse&& from) noexcept
      : GetStoragePoolsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using StoragePool = GetStoragePoolsResponse_StoragePool;

  // accessors -------------------------------------------------------
  enum : int {
    kPoolsFieldNumber = 1,
  };
  // repeated .beegfs.GetStoragePoolsResponse.StoragePool pools = 1;
  int pools_size() const;
  private:
  int _internal_pools_size() const;

  public:
  void clear_pools() ;
  ::beegfs::GetStoragePoolsResponse_StoragePool* mutable_pools(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>* mutable_pools();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>& _internal_pools() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>* _internal_mutable_pools();
  public:
  const ::beegfs::GetStoragePoolsResponse_StoragePool& pools(int index) const;
  ::beegfs::GetStoragePoolsResponse_StoragePool* add_pools();
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>& pools() const;
  // @@protoc_insertion_point(class_scope:beegfs.GetStoragePoolsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::beegfs::GetStoragePoolsResponse_StoragePool > pools_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetNodesResponse) */ {
 public:
  inline GetNodesResponse() : GetNodesResponse(nullptr) {}
  ~GetNodesResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResponse(const GetNodesResponse& from) : GetNodesResponse(nullptr, from) {}
  inline GetNodesResponse(GetNodesResponse&& from) noexcept
      : GetNodesResponse(nullptr, std::move(from)) {}
  inline GetNodesResponse& operator=(const GetNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResponse& operator=(GetNodesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse*>(
        &_GetNodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GetNodesResponse& a, GetNodesResponse& b) { a.Swap(&b); }
  inline void Swap(GetNodesResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResponse& from) { GetNodesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetNodesResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetNodesResponse"; }

 protected:
  explicit GetNodesResponse(::google::protobuf::Arena* arena);
  GetNodesResponse(::google::protobuf::Arena* arena, const GetNodesResponse& from);
  GetNodesResponse(::google::protobuf::Arena* arena, GetNodesResponse&& from) noexcept
      : GetNodesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Node = GetNodesResponse_Node;

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 1,
    kMetaRootNodeFieldNumber = 2,
  };
  // repeated .beegfs.GetNodesResponse.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::beegfs::GetNodesResponse_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>* mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>* _internal_mutable_nodes();
  public:
  const ::beegfs::GetNodesResponse_Node& nodes(int index) const;
  ::beegfs::GetNodesResponse_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>& nodes() const;
  // optional .beegfs.EntityIdSet meta_root_node = 2;
  bool has_meta_root_node() const;
  void clear_meta_root_node() ;
  const ::beegfs::EntityIdSet& meta_root_node() const;
  PROTOBUF_NODISCARD ::beegfs::EntityIdSet* release_meta_root_node();
  ::beegfs::EntityIdSet* mutable_meta_root_node();
  void set_allocated_meta_root_node(::beegfs::EntityIdSet* value);
  void unsafe_arena_set_allocated_meta_root_node(::beegfs::EntityIdSet* value);
  ::beegfs::EntityIdSet* unsafe_arena_release_meta_root_node();

  private:
  const ::beegfs::EntityIdSet& _internal_meta_root_node() const;
  ::beegfs::EntityIdSet* _internal_mutable_meta_root_node();

  public:
  // @@protoc_insertion_point(class_scope:beegfs.GetNodesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::beegfs::GetNodesResponse_Node > nodes_;
    ::beegfs::EntityIdSet* meta_root_node_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};
// -------------------------------------------------------------------

class GetBuddyGroupsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:beegfs.GetBuddyGroupsResponse) */ {
 public:
  inline GetBuddyGroupsResponse() : GetBuddyGroupsResponse(nullptr) {}
  ~GetBuddyGroupsResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBuddyGroupsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBuddyGroupsResponse(const GetBuddyGroupsResponse& from) : GetBuddyGroupsResponse(nullptr, from) {}
  inline GetBuddyGroupsResponse(GetBuddyGroupsResponse&& from) noexcept
      : GetBuddyGroupsResponse(nullptr, std::move(from)) {}
  inline GetBuddyGroupsResponse& operator=(const GetBuddyGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBuddyGroupsResponse& operator=(GetBuddyGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBuddyGroupsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBuddyGroupsResponse* internal_default_instance() {
    return reinterpret_cast<const GetBuddyGroupsResponse*>(
        &_GetBuddyGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(GetBuddyGroupsResponse& a, GetBuddyGroupsResponse& b) { a.Swap(&b); }
  inline void Swap(GetBuddyGroupsResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBuddyGroupsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBuddyGroupsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetBuddyGroupsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBuddyGroupsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBuddyGroupsResponse& from) { GetBuddyGroupsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBuddyGroupsResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "beegfs.GetBuddyGroupsResponse"; }

 protected:
  explicit GetBuddyGroupsResponse(::google::protobuf::Arena* arena);
  GetBuddyGroupsResponse(::google::protobuf::Arena* arena, const GetBuddyGroupsResponse& from);
  GetBuddyGroupsResponse(::google::protobuf::Arena* arena, GetBuddyGroupsResponse&& from) noexcept
      : GetBuddyGroupsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using BuddyGroup = GetBuddyGroupsResponse_BuddyGroup;

  // accessors -------------------------------------------------------
  enum : int {
    kBuddyGroupsFieldNumber = 1,
  };
  // repeated .beegfs.GetBuddyGroupsResponse.BuddyGroup buddy_groups = 1;
  int buddy_groups_size() const;
  private:
  int _internal_buddy_groups_size() const;

  public:
  void clear_buddy_groups() ;
  ::beegfs::GetBuddyGroupsResponse_BuddyGroup* mutable_buddy_groups(int index);
  ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>* mutable_buddy_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>& _internal_buddy_groups() const;
  ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>* _internal_mutable_buddy_groups();
  public:
  const ::beegfs::GetBuddyGroupsResponse_BuddyGroup& buddy_groups(int index) const;
  ::beegfs::GetBuddyGroupsResponse_BuddyGroup* add_buddy_groups();
  const ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>& buddy_groups() const;
  // @@protoc_insertion_point(class_scope:beegfs.GetBuddyGroupsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::beegfs::GetBuddyGroupsResponse_BuddyGroup > buddy_groups_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_beegfs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// LegacyId

// uint32 num_id = 1;
inline void LegacyId::clear_num_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_id_ = 0u;
}
inline ::uint32_t LegacyId::num_id() const {
  // @@protoc_insertion_point(field_get:beegfs.LegacyId.num_id)
  return _internal_num_id();
}
inline void LegacyId::set_num_id(::uint32_t value) {
  _internal_set_num_id(value);
  // @@protoc_insertion_point(field_set:beegfs.LegacyId.num_id)
}
inline ::uint32_t LegacyId::_internal_num_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_id_;
}
inline void LegacyId::_internal_set_num_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_id_ = value;
}

// .beegfs.NodeType node_type = 2;
inline void LegacyId::clear_node_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType LegacyId::node_type() const {
  // @@protoc_insertion_point(field_get:beegfs.LegacyId.node_type)
  return _internal_node_type();
}
inline void LegacyId::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:beegfs.LegacyId.node_type)
}
inline ::beegfs::NodeType LegacyId::_internal_node_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void LegacyId::_internal_set_node_type(::beegfs::NodeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = value;
}

// .beegfs.EntityType entity_type = 3;
inline void LegacyId::clear_entity_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_type_ = 0;
}
inline ::beegfs::EntityType LegacyId::entity_type() const {
  // @@protoc_insertion_point(field_get:beegfs.LegacyId.entity_type)
  return _internal_entity_type();
}
inline void LegacyId::set_entity_type(::beegfs::EntityType value) {
  _internal_set_entity_type(value);
  // @@protoc_insertion_point(field_set:beegfs.LegacyId.entity_type)
}
inline ::beegfs::EntityType LegacyId::_internal_entity_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::EntityType>(_impl_.entity_type_);
}
inline void LegacyId::_internal_set_entity_type(::beegfs::EntityType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_type_ = value;
}

// -------------------------------------------------------------------

// EntityIdSet

// uint64 uid = 1;
inline void EntityIdSet::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t EntityIdSet::uid() const {
  // @@protoc_insertion_point(field_get:beegfs.EntityIdSet.uid)
  return _internal_uid();
}
inline void EntityIdSet::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:beegfs.EntityIdSet.uid)
}
inline ::uint64_t EntityIdSet::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_;
}
inline void EntityIdSet::_internal_set_uid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_ = value;
}

// string alias = 2;
inline void EntityIdSet::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& EntityIdSet::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.EntityIdSet.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityIdSet::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:beegfs.EntityIdSet.alias)
}
inline std::string* EntityIdSet::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:beegfs.EntityIdSet.alias)
  return _s;
}
inline const std::string& EntityIdSet::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void EntityIdSet::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* EntityIdSet::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* EntityIdSet::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.EntityIdSet.alias)
  return _impl_.alias_.Release();
}
inline void EntityIdSet::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.EntityIdSet.alias)
}

// .beegfs.LegacyId legacy_id = 3;
inline bool EntityIdSet::has_legacy_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.legacy_id_ != nullptr);
  return value;
}
inline void EntityIdSet::clear_legacy_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.legacy_id_ != nullptr) _impl_.legacy_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::LegacyId& EntityIdSet::_internal_legacy_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::LegacyId* p = _impl_.legacy_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::LegacyId&>(::beegfs::_LegacyId_default_instance_);
}
inline const ::beegfs::LegacyId& EntityIdSet::legacy_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.EntityIdSet.legacy_id)
  return _internal_legacy_id();
}
inline void EntityIdSet::unsafe_arena_set_allocated_legacy_id(::beegfs::LegacyId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.legacy_id_);
  }
  _impl_.legacy_id_ = reinterpret_cast<::beegfs::LegacyId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.EntityIdSet.legacy_id)
}
inline ::beegfs::LegacyId* EntityIdSet::release_legacy_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::LegacyId* released = _impl_.legacy_id_;
  _impl_.legacy_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::LegacyId* EntityIdSet::unsafe_arena_release_legacy_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.EntityIdSet.legacy_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::LegacyId* temp = _impl_.legacy_id_;
  _impl_.legacy_id_ = nullptr;
  return temp;
}
inline ::beegfs::LegacyId* EntityIdSet::_internal_mutable_legacy_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.legacy_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::LegacyId>(GetArena());
    _impl_.legacy_id_ = reinterpret_cast<::beegfs::LegacyId*>(p);
  }
  return _impl_.legacy_id_;
}
inline ::beegfs::LegacyId* EntityIdSet::mutable_legacy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::LegacyId* _msg = _internal_mutable_legacy_id();
  // @@protoc_insertion_point(field_mutable:beegfs.EntityIdSet.legacy_id)
  return _msg;
}
inline void EntityIdSet::set_allocated_legacy_id(::beegfs::LegacyId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.legacy_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.legacy_id_ = reinterpret_cast<::beegfs::LegacyId*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.EntityIdSet.legacy_id)
}

// -------------------------------------------------------------------

// EntityIdVariant

// uint64 uid = 1;
inline bool EntityIdVariant::has_uid() const {
  return variant_case() == kUid;
}
inline void EntityIdVariant::set_has_uid() {
  _impl_._oneof_case_[0] = kUid;
}
inline void EntityIdVariant::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (variant_case() == kUid) {
    _impl_.variant_.uid_ = ::uint64_t{0u};
    clear_has_variant();
  }
}
inline ::uint64_t EntityIdVariant::uid() const {
  // @@protoc_insertion_point(field_get:beegfs.EntityIdVariant.uid)
  return _internal_uid();
}
inline void EntityIdVariant::set_uid(::uint64_t value) {
  if (variant_case() != kUid) {
    clear_variant();
    set_has_uid();
  }
  _impl_.variant_.uid_ = value;
  // @@protoc_insertion_point(field_set:beegfs.EntityIdVariant.uid)
}
inline ::uint64_t EntityIdVariant::_internal_uid() const {
  if (variant_case() == kUid) {
    return _impl_.variant_.uid_;
  }
  return ::uint64_t{0u};
}

// .beegfs.LegacyId legacy_id = 2;
inline bool EntityIdVariant::has_legacy_id() const {
  return variant_case() == kLegacyId;
}
inline bool EntityIdVariant::_internal_has_legacy_id() const {
  return variant_case() == kLegacyId;
}
inline void EntityIdVariant::set_has_legacy_id() {
  _impl_._oneof_case_[0] = kLegacyId;
}
inline void EntityIdVariant::clear_legacy_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (variant_case() == kLegacyId) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.legacy_id_;
    }
    clear_has_variant();
  }
}
inline ::beegfs::LegacyId* EntityIdVariant::release_legacy_id() {
  // @@protoc_insertion_point(field_release:beegfs.EntityIdVariant.legacy_id)
  if (variant_case() == kLegacyId) {
    clear_has_variant();
    auto* temp = _impl_.variant_.legacy_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.legacy_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::beegfs::LegacyId& EntityIdVariant::_internal_legacy_id() const {
  return variant_case() == kLegacyId ? *_impl_.variant_.legacy_id_ : reinterpret_cast<::beegfs::LegacyId&>(::beegfs::_LegacyId_default_instance_);
}
inline const ::beegfs::LegacyId& EntityIdVariant::legacy_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.EntityIdVariant.legacy_id)
  return _internal_legacy_id();
}
inline ::beegfs::LegacyId* EntityIdVariant::unsafe_arena_release_legacy_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:beegfs.EntityIdVariant.legacy_id)
  if (variant_case() == kLegacyId) {
    clear_has_variant();
    auto* temp = _impl_.variant_.legacy_id_;
    _impl_.variant_.legacy_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityIdVariant::unsafe_arena_set_allocated_legacy_id(::beegfs::LegacyId* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_legacy_id();
    _impl_.variant_.legacy_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.EntityIdVariant.legacy_id)
}
inline ::beegfs::LegacyId* EntityIdVariant::_internal_mutable_legacy_id() {
  if (variant_case() != kLegacyId) {
    clear_variant();
    set_has_legacy_id();
    _impl_.variant_.legacy_id_ =
        ::google::protobuf::Message::DefaultConstruct<::beegfs::LegacyId>(GetArena());
  }
  return _impl_.variant_.legacy_id_;
}
inline ::beegfs::LegacyId* EntityIdVariant::mutable_legacy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::beegfs::LegacyId* _msg = _internal_mutable_legacy_id();
  // @@protoc_insertion_point(field_mutable:beegfs.EntityIdVariant.legacy_id)
  return _msg;
}

// string alias = 3;
inline bool EntityIdVariant::has_alias() const {
  return variant_case() == kAlias;
}
inline void EntityIdVariant::set_has_alias() {
  _impl_._oneof_case_[0] = kAlias;
}
inline void EntityIdVariant::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (variant_case() == kAlias) {
    _impl_.variant_.alias_.Destroy();
    clear_has_variant();
  }
}
inline const std::string& EntityIdVariant::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.EntityIdVariant.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityIdVariant::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (variant_case() != kAlias) {
    clear_variant();

    set_has_alias();
    _impl_.variant_.alias_.InitDefault();
  }
  _impl_.variant_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:beegfs.EntityIdVariant.alias)
}
inline std::string* EntityIdVariant::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:beegfs.EntityIdVariant.alias)
  return _s;
}
inline const std::string& EntityIdVariant::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (variant_case() != kAlias) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.variant_.alias_.Get();
}
inline void EntityIdVariant::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (variant_case() != kAlias) {
    clear_variant();

    set_has_alias();
    _impl_.variant_.alias_.InitDefault();
  }
  _impl_.variant_.alias_.Set(value, GetArena());
}
inline std::string* EntityIdVariant::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (variant_case() != kAlias) {
    clear_variant();

    set_has_alias();
    _impl_.variant_.alias_.InitDefault();
  }
  return _impl_.variant_.alias_.Mutable( GetArena());
}
inline std::string* EntityIdVariant::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.EntityIdVariant.alias)
  if (variant_case() != kAlias) {
    return nullptr;
  }
  clear_has_variant();
  return _impl_.variant_.alias_.Release();
}
inline void EntityIdVariant::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_variant()) {
    clear_variant();
  }
  if (value != nullptr) {
    set_has_alias();
    _impl_.variant_.alias_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:beegfs.EntityIdVariant.alias)
}

inline bool EntityIdVariant::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void EntityIdVariant::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline EntityIdVariant::VariantCase EntityIdVariant::variant_case() const {
  return EntityIdVariant::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetNodesRequest

// bool include_nics = 1;
inline void GetNodesRequest::clear_include_nics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.include_nics_ = false;
}
inline bool GetNodesRequest::include_nics() const {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesRequest.include_nics)
  return _internal_include_nics();
}
inline void GetNodesRequest::set_include_nics(bool value) {
  _internal_set_include_nics(value);
  // @@protoc_insertion_point(field_set:beegfs.GetNodesRequest.include_nics)
}
inline bool GetNodesRequest::_internal_include_nics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.include_nics_;
}
inline void GetNodesRequest::_internal_set_include_nics(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.include_nics_ = value;
}

// -------------------------------------------------------------------

// GetNodesResponse_Node_Nic

// string addr = 1;
inline void GetNodesResponse_Node_Nic::clear_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetNodesResponse_Node_Nic::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.Nic.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetNodesResponse_Node_Nic::set_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:beegfs.GetNodesResponse.Node.Nic.addr)
}
inline std::string* GetNodesResponse_Node_Nic::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:beegfs.GetNodesResponse.Node.Nic.addr)
  return _s;
}
inline const std::string& GetNodesResponse_Node_Nic::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_.Get();
}
inline void GetNodesResponse_Node_Nic::_internal_set_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::_internal_mutable_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::release_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetNodesResponse.Node.Nic.addr)
  return _impl_.addr_.Release();
}
inline void GetNodesResponse_Node_Nic::set_allocated_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.addr_.IsDefault()) {
          _impl_.addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetNodesResponse.Node.Nic.addr)
}

// string name = 2;
inline void GetNodesResponse_Node_Nic::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNodesResponse_Node_Nic::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.Nic.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetNodesResponse_Node_Nic::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:beegfs.GetNodesResponse.Node.Nic.name)
}
inline std::string* GetNodesResponse_Node_Nic::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:beegfs.GetNodesResponse.Node.Nic.name)
  return _s;
}
inline const std::string& GetNodesResponse_Node_Nic::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetNodesResponse_Node_Nic::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetNodesResponse_Node_Nic::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetNodesResponse.Node.Nic.name)
  return _impl_.name_.Release();
}
inline void GetNodesResponse_Node_Nic::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetNodesResponse.Node.Nic.name)
}

// .beegfs.NicType nic_type = 3;
inline void GetNodesResponse_Node_Nic::clear_nic_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nic_type_ = 0;
}
inline ::beegfs::NicType GetNodesResponse_Node_Nic::nic_type() const {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.Nic.nic_type)
  return _internal_nic_type();
}
inline void GetNodesResponse_Node_Nic::set_nic_type(::beegfs::NicType value) {
  _internal_set_nic_type(value);
  // @@protoc_insertion_point(field_set:beegfs.GetNodesResponse.Node.Nic.nic_type)
}
inline ::beegfs::NicType GetNodesResponse_Node_Nic::_internal_nic_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::NicType>(_impl_.nic_type_);
}
inline void GetNodesResponse_Node_Nic::_internal_set_nic_type(::beegfs::NicType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nic_type_ = value;
}

// -------------------------------------------------------------------

// GetNodesResponse_Node

// .beegfs.EntityIdSet id = 1;
inline bool GetNodesResponse_Node::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void GetNodesResponse_Node::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::EntityIdSet& GetNodesResponse_Node::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetNodesResponse_Node::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.id)
  return _internal_id();
}
inline void GetNodesResponse_Node::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetNodesResponse.Node.id)
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetNodesResponse.Node.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetNodesResponse_Node::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:beegfs.GetNodesResponse.Node.id)
  return _msg;
}
inline void GetNodesResponse_Node::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetNodesResponse.Node.id)
}

// .beegfs.NodeType node_type = 2;
inline void GetNodesResponse_Node::clear_node_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType GetNodesResponse_Node::node_type() const {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.node_type)
  return _internal_node_type();
}
inline void GetNodesResponse_Node::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:beegfs.GetNodesResponse.Node.node_type)
}
inline ::beegfs::NodeType GetNodesResponse_Node::_internal_node_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void GetNodesResponse_Node::_internal_set_node_type(::beegfs::NodeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = value;
}

// uint32 port = 3;
inline void GetNodesResponse_Node::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t GetNodesResponse_Node::port() const {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.port)
  return _internal_port();
}
inline void GetNodesResponse_Node::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:beegfs.GetNodesResponse.Node.port)
}
inline ::uint32_t GetNodesResponse_Node::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void GetNodesResponse_Node::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = value;
}

// repeated .beegfs.GetNodesResponse.Node.Nic nics = 4;
inline int GetNodesResponse_Node::_internal_nics_size() const {
  return _internal_nics().size();
}
inline int GetNodesResponse_Node::nics_size() const {
  return _internal_nics_size();
}
inline void GetNodesResponse_Node::clear_nics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nics_.Clear();
}
inline ::beegfs::GetNodesResponse_Node_Nic* GetNodesResponse_Node::mutable_nics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetNodesResponse.Node.nics)
  return _internal_mutable_nics()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>* GetNodesResponse_Node::mutable_nics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetNodesResponse.Node.nics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nics();
}
inline const ::beegfs::GetNodesResponse_Node_Nic& GetNodesResponse_Node::nics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.Node.nics)
  return _internal_nics().Get(index);
}
inline ::beegfs::GetNodesResponse_Node_Nic* GetNodesResponse_Node::add_nics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::GetNodesResponse_Node_Nic* _add = _internal_mutable_nics()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetNodesResponse.Node.nics)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>& GetNodesResponse_Node::nics() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetNodesResponse.Node.nics)
  return _internal_nics();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>&
GetNodesResponse_Node::_internal_nics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nics_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node_Nic>*
GetNodesResponse_Node::_internal_mutable_nics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nics_;
}

// -------------------------------------------------------------------

// GetNodesResponse

// repeated .beegfs.GetNodesResponse.Node nodes = 1;
inline int GetNodesResponse::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int GetNodesResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetNodesResponse::clear_nodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodes_.Clear();
}
inline ::beegfs::GetNodesResponse_Node* GetNodesResponse::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetNodesResponse.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>* GetNodesResponse::mutable_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetNodesResponse.nodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodes();
}
inline const ::beegfs::GetNodesResponse_Node& GetNodesResponse::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.nodes)
  return _internal_nodes().Get(index);
}
inline ::beegfs::GetNodesResponse_Node* GetNodesResponse::add_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::GetNodesResponse_Node* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetNodesResponse.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>& GetNodesResponse::nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetNodesResponse.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>&
GetNodesResponse::_internal_nodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetNodesResponse_Node>*
GetNodesResponse::_internal_mutable_nodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodes_;
}

// optional .beegfs.EntityIdSet meta_root_node = 2;
inline bool GetNodesResponse::has_meta_root_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_root_node_ != nullptr);
  return value;
}
inline void GetNodesResponse::clear_meta_root_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.meta_root_node_ != nullptr) _impl_.meta_root_node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::EntityIdSet& GetNodesResponse::_internal_meta_root_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.meta_root_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetNodesResponse::meta_root_node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetNodesResponse.meta_root_node)
  return _internal_meta_root_node();
}
inline void GetNodesResponse::unsafe_arena_set_allocated_meta_root_node(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_root_node_);
  }
  _impl_.meta_root_node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetNodesResponse.meta_root_node)
}
inline ::beegfs::EntityIdSet* GetNodesResponse::release_meta_root_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.meta_root_node_;
  _impl_.meta_root_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetNodesResponse::unsafe_arena_release_meta_root_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetNodesResponse.meta_root_node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.meta_root_node_;
  _impl_.meta_root_node_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetNodesResponse::_internal_mutable_meta_root_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.meta_root_node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.meta_root_node_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.meta_root_node_;
}
inline ::beegfs::EntityIdSet* GetNodesResponse::mutable_meta_root_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_meta_root_node();
  // @@protoc_insertion_point(field_mutable:beegfs.GetNodesResponse.meta_root_node)
  return _msg;
}
inline void GetNodesResponse::set_allocated_meta_root_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.meta_root_node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.meta_root_node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetNodesResponse.meta_root_node)
}

// -------------------------------------------------------------------

// GetTargetsRequest

// -------------------------------------------------------------------

// GetTargetsResponse_Target

// .beegfs.EntityIdSet id = 1;
inline bool GetTargetsResponse_Target::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void GetTargetsResponse_Target::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.id)
  return _internal_id();
}
inline void GetTargetsResponse_Target::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetTargetsResponse.Target.id)
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetTargetsResponse.Target.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:beegfs.GetTargetsResponse.Target.id)
  return _msg;
}
inline void GetTargetsResponse_Target::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetTargetsResponse.Target.id)
}

// .beegfs.NodeType node_type = 2;
inline void GetTargetsResponse_Target::clear_node_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType GetTargetsResponse_Target::node_type() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.node_type)
  return _internal_node_type();
}
inline void GetTargetsResponse_Target::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.node_type)
}
inline ::beegfs::NodeType GetTargetsResponse_Target::_internal_node_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void GetTargetsResponse_Target::_internal_set_node_type(::beegfs::NodeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = value;
}

// .beegfs.ReachabilityState reachability_state = 3;
inline void GetTargetsResponse_Target::clear_reachability_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reachability_state_ = 0;
}
inline ::beegfs::ReachabilityState GetTargetsResponse_Target::reachability_state() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.reachability_state)
  return _internal_reachability_state();
}
inline void GetTargetsResponse_Target::set_reachability_state(::beegfs::ReachabilityState value) {
  _internal_set_reachability_state(value);
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.reachability_state)
}
inline ::beegfs::ReachabilityState GetTargetsResponse_Target::_internal_reachability_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::ReachabilityState>(_impl_.reachability_state_);
}
inline void GetTargetsResponse_Target::_internal_set_reachability_state(::beegfs::ReachabilityState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reachability_state_ = value;
}

// .beegfs.ConsistencyState consistency_state = 4;
inline void GetTargetsResponse_Target::clear_consistency_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consistency_state_ = 0;
}
inline ::beegfs::ConsistencyState GetTargetsResponse_Target::consistency_state() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.consistency_state)
  return _internal_consistency_state();
}
inline void GetTargetsResponse_Target::set_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_consistency_state(value);
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.consistency_state)
}
inline ::beegfs::ConsistencyState GetTargetsResponse_Target::_internal_consistency_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::ConsistencyState>(_impl_.consistency_state_);
}
inline void GetTargetsResponse_Target::_internal_set_consistency_state(::beegfs::ConsistencyState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consistency_state_ = value;
}

// optional uint64 last_contact_s = 5;
inline bool GetTargetsResponse_Target::has_last_contact_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_last_contact_s() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_contact_s_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t GetTargetsResponse_Target::last_contact_s() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.last_contact_s)
  return _internal_last_contact_s();
}
inline void GetTargetsResponse_Target::set_last_contact_s(::uint64_t value) {
  _internal_set_last_contact_s(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.last_contact_s)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_last_contact_s() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_contact_s_;
}
inline void GetTargetsResponse_Target::_internal_set_last_contact_s(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_contact_s_ = value;
}

// optional uint64 total_space_bytes = 6;
inline bool GetTargetsResponse_Target::has_total_space_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_total_space_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_space_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t GetTargetsResponse_Target::total_space_bytes() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.total_space_bytes)
  return _internal_total_space_bytes();
}
inline void GetTargetsResponse_Target::set_total_space_bytes(::uint64_t value) {
  _internal_set_total_space_bytes(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.total_space_bytes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_total_space_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_space_bytes_;
}
inline void GetTargetsResponse_Target::_internal_set_total_space_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_space_bytes_ = value;
}

// optional uint64 free_space_bytes = 7;
inline bool GetTargetsResponse_Target::has_free_space_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_free_space_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.free_space_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t GetTargetsResponse_Target::free_space_bytes() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.free_space_bytes)
  return _internal_free_space_bytes();
}
inline void GetTargetsResponse_Target::set_free_space_bytes(::uint64_t value) {
  _internal_set_free_space_bytes(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.free_space_bytes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_free_space_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.free_space_bytes_;
}
inline void GetTargetsResponse_Target::_internal_set_free_space_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.free_space_bytes_ = value;
}

// optional uint64 total_inodes = 8;
inline bool GetTargetsResponse_Target::has_total_inodes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_total_inodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_inodes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t GetTargetsResponse_Target::total_inodes() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.total_inodes)
  return _internal_total_inodes();
}
inline void GetTargetsResponse_Target::set_total_inodes(::uint64_t value) {
  _internal_set_total_inodes(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.total_inodes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_total_inodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_inodes_;
}
inline void GetTargetsResponse_Target::_internal_set_total_inodes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_inodes_ = value;
}

// optional uint64 free_inodes = 9;
inline bool GetTargetsResponse_Target::has_free_inodes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GetTargetsResponse_Target::clear_free_inodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.free_inodes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t GetTargetsResponse_Target::free_inodes() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.free_inodes)
  return _internal_free_inodes();
}
inline void GetTargetsResponse_Target::set_free_inodes(::uint64_t value) {
  _internal_set_free_inodes(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.free_inodes)
}
inline ::uint64_t GetTargetsResponse_Target::_internal_free_inodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.free_inodes_;
}
inline void GetTargetsResponse_Target::_internal_set_free_inodes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.free_inodes_ = value;
}

// .beegfs.CapacityPool cap_pool = 10;
inline void GetTargetsResponse_Target::clear_cap_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cap_pool_ = 0;
}
inline ::beegfs::CapacityPool GetTargetsResponse_Target::cap_pool() const {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.cap_pool)
  return _internal_cap_pool();
}
inline void GetTargetsResponse_Target::set_cap_pool(::beegfs::CapacityPool value) {
  _internal_set_cap_pool(value);
  // @@protoc_insertion_point(field_set:beegfs.GetTargetsResponse.Target.cap_pool)
}
inline ::beegfs::CapacityPool GetTargetsResponse_Target::_internal_cap_pool() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::CapacityPool>(_impl_.cap_pool_);
}
inline void GetTargetsResponse_Target::_internal_set_cap_pool(::beegfs::CapacityPool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cap_pool_ = value;
}

// .beegfs.EntityIdSet node = 11;
inline bool GetTargetsResponse_Target::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline void GetTargetsResponse_Target::clear_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.node_ != nullptr) _impl_.node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::_internal_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.node)
  return _internal_node();
}
inline void GetTargetsResponse_Target::unsafe_arena_set_allocated_node(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetTargetsResponse.Target.node)
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::release_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* released = _impl_.node_;
  _impl_.node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::unsafe_arena_release_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetTargetsResponse.Target.node)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::_internal_mutable_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.node_;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:beegfs.GetTargetsResponse.Target.node)
  return _msg;
}
inline void GetTargetsResponse_Target::set_allocated_node(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.node_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetTargetsResponse.Target.node)
}

// optional .beegfs.EntityIdSet storage_pool = 12;
inline bool GetTargetsResponse_Target::has_storage_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_pool_ != nullptr);
  return value;
}
inline void GetTargetsResponse_Target::clear_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.storage_pool_ != nullptr) _impl_.storage_pool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::_internal_storage_pool() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.storage_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetTargetsResponse_Target::storage_pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.Target.storage_pool)
  return _internal_storage_pool();
}
inline void GetTargetsResponse_Target::unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_pool_);
  }
  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetTargetsResponse.Target.storage_pool)
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::release_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* released = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::unsafe_arena_release_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetTargetsResponse.Target.storage_pool)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* temp = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::_internal_mutable_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.storage_pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.storage_pool_;
}
inline ::beegfs::EntityIdSet* GetTargetsResponse_Target::mutable_storage_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_storage_pool();
  // @@protoc_insertion_point(field_mutable:beegfs.GetTargetsResponse.Target.storage_pool)
  return _msg;
}
inline void GetTargetsResponse_Target::set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.storage_pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetTargetsResponse.Target.storage_pool)
}

// -------------------------------------------------------------------

// GetTargetsResponse

// repeated .beegfs.GetTargetsResponse.Target targets = 1;
inline int GetTargetsResponse::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int GetTargetsResponse::targets_size() const {
  return _internal_targets_size();
}
inline void GetTargetsResponse::clear_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targets_.Clear();
}
inline ::beegfs::GetTargetsResponse_Target* GetTargetsResponse::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetTargetsResponse.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>* GetTargetsResponse::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetTargetsResponse.targets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targets();
}
inline const ::beegfs::GetTargetsResponse_Target& GetTargetsResponse::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetTargetsResponse.targets)
  return _internal_targets().Get(index);
}
inline ::beegfs::GetTargetsResponse_Target* GetTargetsResponse::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::GetTargetsResponse_Target* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetTargetsResponse.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>& GetTargetsResponse::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetTargetsResponse.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>&
GetTargetsResponse::_internal_targets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetTargetsResponse_Target>*
GetTargetsResponse::_internal_mutable_targets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// GetBuddyGroupsRequest

// -------------------------------------------------------------------

// GetBuddyGroupsResponse_BuddyGroup

// .beegfs.EntityIdSet id = 1;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void GetBuddyGroupsResponse_BuddyGroup::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.id)
  return _internal_id();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.id)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetBuddyGroupsResponse.BuddyGroup.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:beegfs.GetBuddyGroupsResponse.BuddyGroup.id)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.id)
}

// .beegfs.NodeType node_type = 2;
inline void GetBuddyGroupsResponse_BuddyGroup::clear_node_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = 0;
}
inline ::beegfs::NodeType GetBuddyGroupsResponse_BuddyGroup::node_type() const {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.node_type)
  return _internal_node_type();
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_node_type(::beegfs::NodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:beegfs.GetBuddyGroupsResponse.BuddyGroup.node_type)
}
inline ::beegfs::NodeType GetBuddyGroupsResponse_BuddyGroup::_internal_node_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::NodeType>(_impl_.node_type_);
}
inline void GetBuddyGroupsResponse_BuddyGroup::_internal_set_node_type(::beegfs::NodeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_type_ = value;
}

// .beegfs.EntityIdSet primary_target = 3;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_primary_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.primary_target_ != nullptr);
  return value;
}
inline void GetBuddyGroupsResponse_BuddyGroup::clear_primary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.primary_target_ != nullptr) _impl_.primary_target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_primary_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.primary_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::primary_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_target)
  return _internal_primary_target();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_primary_target(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_target_);
  }
  _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_target)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_primary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* released = _impl_.primary_target_;
  _impl_.primary_target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_primary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::beegfs::EntityIdSet* temp = _impl_.primary_target_;
  _impl_.primary_target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_primary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.primary_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.primary_target_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_primary_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_primary_target();
  // @@protoc_insertion_point(field_mutable:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_target)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_primary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.primary_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.primary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_target)
}

// .beegfs.EntityIdSet secondary_target = 4;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_secondary_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secondary_target_ != nullptr);
  return value;
}
inline void GetBuddyGroupsResponse_BuddyGroup::clear_secondary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.secondary_target_ != nullptr) _impl_.secondary_target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_secondary_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.secondary_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::secondary_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
  return _internal_secondary_target();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_secondary_target(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_target_);
  }
  _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_secondary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* released = _impl_.secondary_target_;
  _impl_.secondary_target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_secondary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_target)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::beegfs::EntityIdSet* temp = _impl_.secondary_target_;
  _impl_.secondary_target_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_secondary_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.secondary_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.secondary_target_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_secondary_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_secondary_target();
  // @@protoc_insertion_point(field_mutable:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_secondary_target(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.secondary_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.secondary_target_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_target)
}

// .beegfs.ConsistencyState primary_consistency_state = 5;
inline void GetBuddyGroupsResponse_BuddyGroup::clear_primary_consistency_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.primary_consistency_state_ = 0;
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::primary_consistency_state() const {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_consistency_state)
  return _internal_primary_consistency_state();
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_primary_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_primary_consistency_state(value);
  // @@protoc_insertion_point(field_set:beegfs.GetBuddyGroupsResponse.BuddyGroup.primary_consistency_state)
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::_internal_primary_consistency_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::ConsistencyState>(_impl_.primary_consistency_state_);
}
inline void GetBuddyGroupsResponse_BuddyGroup::_internal_set_primary_consistency_state(::beegfs::ConsistencyState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.primary_consistency_state_ = value;
}

// .beegfs.ConsistencyState secondary_consistency_state = 6;
inline void GetBuddyGroupsResponse_BuddyGroup::clear_secondary_consistency_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secondary_consistency_state_ = 0;
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::secondary_consistency_state() const {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_consistency_state)
  return _internal_secondary_consistency_state();
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_secondary_consistency_state(::beegfs::ConsistencyState value) {
  _internal_set_secondary_consistency_state(value);
  // @@protoc_insertion_point(field_set:beegfs.GetBuddyGroupsResponse.BuddyGroup.secondary_consistency_state)
}
inline ::beegfs::ConsistencyState GetBuddyGroupsResponse_BuddyGroup::_internal_secondary_consistency_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::beegfs::ConsistencyState>(_impl_.secondary_consistency_state_);
}
inline void GetBuddyGroupsResponse_BuddyGroup::_internal_set_secondary_consistency_state(::beegfs::ConsistencyState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secondary_consistency_state_ = value;
}

// optional .beegfs.EntityIdSet storage_pool = 7;
inline bool GetBuddyGroupsResponse_BuddyGroup::has_storage_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_pool_ != nullptr);
  return value;
}
inline void GetBuddyGroupsResponse_BuddyGroup::clear_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.storage_pool_ != nullptr) _impl_.storage_pool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::_internal_storage_pool() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.storage_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetBuddyGroupsResponse_BuddyGroup::storage_pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
  return _internal_storage_pool();
}
inline void GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_pool_);
  }
  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::release_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::beegfs::EntityIdSet* released = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::unsafe_arena_release_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetBuddyGroupsResponse.BuddyGroup.storage_pool)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::beegfs::EntityIdSet* temp = _impl_.storage_pool_;
  _impl_.storage_pool_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::_internal_mutable_storage_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.storage_pool_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.storage_pool_;
}
inline ::beegfs::EntityIdSet* GetBuddyGroupsResponse_BuddyGroup::mutable_storage_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_storage_pool();
  // @@protoc_insertion_point(field_mutable:beegfs.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
  return _msg;
}
inline void GetBuddyGroupsResponse_BuddyGroup::set_allocated_storage_pool(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.storage_pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.storage_pool_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetBuddyGroupsResponse.BuddyGroup.storage_pool)
}

// -------------------------------------------------------------------

// GetBuddyGroupsResponse

// repeated .beegfs.GetBuddyGroupsResponse.BuddyGroup buddy_groups = 1;
inline int GetBuddyGroupsResponse::_internal_buddy_groups_size() const {
  return _internal_buddy_groups().size();
}
inline int GetBuddyGroupsResponse::buddy_groups_size() const {
  return _internal_buddy_groups_size();
}
inline void GetBuddyGroupsResponse::clear_buddy_groups() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buddy_groups_.Clear();
}
inline ::beegfs::GetBuddyGroupsResponse_BuddyGroup* GetBuddyGroupsResponse::mutable_buddy_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetBuddyGroupsResponse.buddy_groups)
  return _internal_mutable_buddy_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>* GetBuddyGroupsResponse::mutable_buddy_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetBuddyGroupsResponse.buddy_groups)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_buddy_groups();
}
inline const ::beegfs::GetBuddyGroupsResponse_BuddyGroup& GetBuddyGroupsResponse::buddy_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetBuddyGroupsResponse.buddy_groups)
  return _internal_buddy_groups().Get(index);
}
inline ::beegfs::GetBuddyGroupsResponse_BuddyGroup* GetBuddyGroupsResponse::add_buddy_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::GetBuddyGroupsResponse_BuddyGroup* _add = _internal_mutable_buddy_groups()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetBuddyGroupsResponse.buddy_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>& GetBuddyGroupsResponse::buddy_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetBuddyGroupsResponse.buddy_groups)
  return _internal_buddy_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>&
GetBuddyGroupsResponse::_internal_buddy_groups() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buddy_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetBuddyGroupsResponse_BuddyGroup>*
GetBuddyGroupsResponse::_internal_mutable_buddy_groups() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.buddy_groups_;
}

// -------------------------------------------------------------------

// GetStoragePoolsRequest

// -------------------------------------------------------------------

// GetStoragePoolsResponse_StoragePool

// .beegfs.EntityIdSet id = 1;
inline bool GetStoragePoolsResponse_StoragePool::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void GetStoragePoolsResponse_StoragePool::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::EntityIdSet& GetStoragePoolsResponse_StoragePool::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdSet* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdSet&>(::beegfs::_EntityIdSet_default_instance_);
}
inline const ::beegfs::EntityIdSet& GetStoragePoolsResponse_StoragePool::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetStoragePoolsResponse.StoragePool.id)
  return _internal_id();
}
inline void GetStoragePoolsResponse_StoragePool::unsafe_arena_set_allocated_id(::beegfs::EntityIdSet* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.GetStoragePoolsResponse.StoragePool.id)
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.GetStoragePoolsResponse.StoragePool.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdSet* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdSet>(GetArena());
    _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(p);
  }
  return _impl_.id_;
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdSet* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:beegfs.GetStoragePoolsResponse.StoragePool.id)
  return _msg;
}
inline void GetStoragePoolsResponse_StoragePool::set_allocated_id(::beegfs::EntityIdSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::beegfs::EntityIdSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.GetStoragePoolsResponse.StoragePool.id)
}

// repeated .beegfs.EntityIdSet targets = 2;
inline int GetStoragePoolsResponse_StoragePool::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int GetStoragePoolsResponse_StoragePool::targets_size() const {
  return _internal_targets_size();
}
inline void GetStoragePoolsResponse_StoragePool::clear_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targets_.Clear();
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetStoragePoolsResponse.StoragePool.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* GetStoragePoolsResponse_StoragePool::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetStoragePoolsResponse.StoragePool.targets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targets();
}
inline const ::beegfs::EntityIdSet& GetStoragePoolsResponse_StoragePool::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetStoragePoolsResponse.StoragePool.targets)
  return _internal_targets().Get(index);
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::EntityIdSet* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetStoragePoolsResponse.StoragePool.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& GetStoragePoolsResponse_StoragePool::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetStoragePoolsResponse.StoragePool.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
GetStoragePoolsResponse_StoragePool::_internal_targets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
GetStoragePoolsResponse_StoragePool::_internal_mutable_targets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targets_;
}

// repeated .beegfs.EntityIdSet buddy_groups = 3;
inline int GetStoragePoolsResponse_StoragePool::_internal_buddy_groups_size() const {
  return _internal_buddy_groups().size();
}
inline int GetStoragePoolsResponse_StoragePool::buddy_groups_size() const {
  return _internal_buddy_groups_size();
}
inline void GetStoragePoolsResponse_StoragePool::clear_buddy_groups() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buddy_groups_.Clear();
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::mutable_buddy_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetStoragePoolsResponse.StoragePool.buddy_groups)
  return _internal_mutable_buddy_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>* GetStoragePoolsResponse_StoragePool::mutable_buddy_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetStoragePoolsResponse.StoragePool.buddy_groups)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_buddy_groups();
}
inline const ::beegfs::EntityIdSet& GetStoragePoolsResponse_StoragePool::buddy_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetStoragePoolsResponse.StoragePool.buddy_groups)
  return _internal_buddy_groups().Get(index);
}
inline ::beegfs::EntityIdSet* GetStoragePoolsResponse_StoragePool::add_buddy_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::EntityIdSet* _add = _internal_mutable_buddy_groups()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetStoragePoolsResponse.StoragePool.buddy_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>& GetStoragePoolsResponse_StoragePool::buddy_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetStoragePoolsResponse.StoragePool.buddy_groups)
  return _internal_buddy_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>&
GetStoragePoolsResponse_StoragePool::_internal_buddy_groups() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buddy_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::EntityIdSet>*
GetStoragePoolsResponse_StoragePool::_internal_mutable_buddy_groups() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.buddy_groups_;
}

// -------------------------------------------------------------------

// GetStoragePoolsResponse

// repeated .beegfs.GetStoragePoolsResponse.StoragePool pools = 1;
inline int GetStoragePoolsResponse::_internal_pools_size() const {
  return _internal_pools().size();
}
inline int GetStoragePoolsResponse::pools_size() const {
  return _internal_pools_size();
}
inline void GetStoragePoolsResponse::clear_pools() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pools_.Clear();
}
inline ::beegfs::GetStoragePoolsResponse_StoragePool* GetStoragePoolsResponse::mutable_pools(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:beegfs.GetStoragePoolsResponse.pools)
  return _internal_mutable_pools()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>* GetStoragePoolsResponse::mutable_pools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:beegfs.GetStoragePoolsResponse.pools)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_pools();
}
inline const ::beegfs::GetStoragePoolsResponse_StoragePool& GetStoragePoolsResponse::pools(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.GetStoragePoolsResponse.pools)
  return _internal_pools().Get(index);
}
inline ::beegfs::GetStoragePoolsResponse_StoragePool* GetStoragePoolsResponse::add_pools() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::beegfs::GetStoragePoolsResponse_StoragePool* _add = _internal_mutable_pools()->Add();
  // @@protoc_insertion_point(field_add:beegfs.GetStoragePoolsResponse.pools)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>& GetStoragePoolsResponse::pools() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:beegfs.GetStoragePoolsResponse.pools)
  return _internal_pools();
}
inline const ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>&
GetStoragePoolsResponse::_internal_pools() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pools_;
}
inline ::google::protobuf::RepeatedPtrField<::beegfs::GetStoragePoolsResponse_StoragePool>*
GetStoragePoolsResponse::_internal_mutable_pools() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.pools_;
}

// -------------------------------------------------------------------

// SetAliasRequest

// .beegfs.EntityIdVariant entity_id = 1;
inline bool SetAliasRequest::has_entity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_id_ != nullptr);
  return value;
}
inline void SetAliasRequest::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.entity_id_ != nullptr) _impl_.entity_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::beegfs::EntityIdVariant& SetAliasRequest::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::beegfs::EntityIdVariant* p = _impl_.entity_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::beegfs::EntityIdVariant&>(::beegfs::_EntityIdVariant_default_instance_);
}
inline const ::beegfs::EntityIdVariant& SetAliasRequest::entity_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.SetAliasRequest.entity_id)
  return _internal_entity_id();
}
inline void SetAliasRequest::unsafe_arena_set_allocated_entity_id(::beegfs::EntityIdVariant* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_id_);
  }
  _impl_.entity_id_ = reinterpret_cast<::beegfs::EntityIdVariant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:beegfs.SetAliasRequest.entity_id)
}
inline ::beegfs::EntityIdVariant* SetAliasRequest::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdVariant* released = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::beegfs::EntityIdVariant* SetAliasRequest::unsafe_arena_release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.SetAliasRequest.entity_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::beegfs::EntityIdVariant* temp = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
  return temp;
}
inline ::beegfs::EntityIdVariant* SetAliasRequest::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.entity_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::beegfs::EntityIdVariant>(GetArena());
    _impl_.entity_id_ = reinterpret_cast<::beegfs::EntityIdVariant*>(p);
  }
  return _impl_.entity_id_;
}
inline ::beegfs::EntityIdVariant* SetAliasRequest::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::beegfs::EntityIdVariant* _msg = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:beegfs.SetAliasRequest.entity_id)
  return _msg;
}
inline void SetAliasRequest::set_allocated_entity_id(::beegfs::EntityIdVariant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.entity_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.entity_id_ = reinterpret_cast<::beegfs::EntityIdVariant*>(value);
  // @@protoc_insertion_point(field_set_allocated:beegfs.SetAliasRequest.entity_id)
}

// string new_alias = 2;
inline void SetAliasRequest::clear_new_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_alias_.ClearToEmpty();
}
inline const std::string& SetAliasRequest::new_alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:beegfs.SetAliasRequest.new_alias)
  return _internal_new_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetAliasRequest::set_new_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:beegfs.SetAliasRequest.new_alias)
}
inline std::string* SetAliasRequest::mutable_new_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_alias();
  // @@protoc_insertion_point(field_mutable:beegfs.SetAliasRequest.new_alias)
  return _s;
}
inline const std::string& SetAliasRequest::_internal_new_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_alias_.Get();
}
inline void SetAliasRequest::_internal_set_new_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_alias_.Set(value, GetArena());
}
inline std::string* SetAliasRequest::_internal_mutable_new_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.new_alias_.Mutable( GetArena());
}
inline std::string* SetAliasRequest::release_new_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:beegfs.SetAliasRequest.new_alias)
  return _impl_.new_alias_.Release();
}
inline void SetAliasRequest::set_allocated_new_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_alias_.IsDefault()) {
          _impl_.new_alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beegfs.SetAliasRequest.new_alias)
}

// -------------------------------------------------------------------

// SetAliasResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace beegfs


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::beegfs::EntityType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::EntityType>() {
  return ::beegfs::EntityType_descriptor();
}
template <>
struct is_proto_enum<::beegfs::NodeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::NodeType>() {
  return ::beegfs::NodeType_descriptor();
}
template <>
struct is_proto_enum<::beegfs::ReachabilityState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::ReachabilityState>() {
  return ::beegfs::ReachabilityState_descriptor();
}
template <>
struct is_proto_enum<::beegfs::ConsistencyState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::ConsistencyState>() {
  return ::beegfs::ConsistencyState_descriptor();
}
template <>
struct is_proto_enum<::beegfs::CapacityPool> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::CapacityPool>() {
  return ::beegfs::CapacityPool_descriptor();
}
template <>
struct is_proto_enum<::beegfs::NicType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::beegfs::NicType>() {
  return ::beegfs::NicType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_beegfs_2eproto_2epb_2eh
