// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flex.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flex_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flex_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flex_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flex_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flex_2eproto;
namespace flex {
class BeeRemoteNode;
class BeeRemoteNodeDefaultTypeInternal;
extern BeeRemoteNodeDefaultTypeInternal _BeeRemoteNode_default_instance_;
class BulkUpdateWorkRequest;
class BulkUpdateWorkRequestDefaultTypeInternal;
extern BulkUpdateWorkRequestDefaultTypeInternal _BulkUpdateWorkRequest_default_instance_;
class BulkUpdateWorkResponse;
class BulkUpdateWorkResponseDefaultTypeInternal;
extern BulkUpdateWorkResponseDefaultTypeInternal _BulkUpdateWorkResponse_default_instance_;
class HeartbeatRequest;
class HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
class HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class MockJob;
class MockJobDefaultTypeInternal;
extern MockJobDefaultTypeInternal _MockJob_default_instance_;
class NodeStats;
class NodeStatsDefaultTypeInternal;
extern NodeStatsDefaultTypeInternal _NodeStats_default_instance_;
class RemoteStorageTarget;
class RemoteStorageTargetDefaultTypeInternal;
extern RemoteStorageTargetDefaultTypeInternal _RemoteStorageTarget_default_instance_;
class RemoteStorageTarget_Azure;
class RemoteStorageTarget_AzureDefaultTypeInternal;
extern RemoteStorageTarget_AzureDefaultTypeInternal _RemoteStorageTarget_Azure_default_instance_;
class RemoteStorageTarget_POSIX;
class RemoteStorageTarget_POSIXDefaultTypeInternal;
extern RemoteStorageTarget_POSIXDefaultTypeInternal _RemoteStorageTarget_POSIX_default_instance_;
class RemoteStorageTarget_Policies;
class RemoteStorageTarget_PoliciesDefaultTypeInternal;
extern RemoteStorageTarget_PoliciesDefaultTypeInternal _RemoteStorageTarget_Policies_default_instance_;
class RemoteStorageTarget_S3;
class RemoteStorageTarget_S3DefaultTypeInternal;
extern RemoteStorageTarget_S3DefaultTypeInternal _RemoteStorageTarget_S3_default_instance_;
class SubmitWorkRequest;
class SubmitWorkRequestDefaultTypeInternal;
extern SubmitWorkRequestDefaultTypeInternal _SubmitWorkRequest_default_instance_;
class SubmitWorkResponse;
class SubmitWorkResponseDefaultTypeInternal;
extern SubmitWorkResponseDefaultTypeInternal _SubmitWorkResponse_default_instance_;
class SyncJob;
class SyncJobDefaultTypeInternal;
extern SyncJobDefaultTypeInternal _SyncJob_default_instance_;
class UpdateConfigRequest;
class UpdateConfigRequestDefaultTypeInternal;
extern UpdateConfigRequestDefaultTypeInternal _UpdateConfigRequest_default_instance_;
class UpdateConfigResponse;
class UpdateConfigResponseDefaultTypeInternal;
extern UpdateConfigResponseDefaultTypeInternal _UpdateConfigResponse_default_instance_;
class UpdateWorkRequest;
class UpdateWorkRequestDefaultTypeInternal;
extern UpdateWorkRequestDefaultTypeInternal _UpdateWorkRequest_default_instance_;
class UpdateWorkResponse;
class UpdateWorkResponseDefaultTypeInternal;
extern UpdateWorkResponseDefaultTypeInternal _UpdateWorkResponse_default_instance_;
class Work;
class WorkDefaultTypeInternal;
extern WorkDefaultTypeInternal _Work_default_instance_;
class WorkRequest;
class WorkRequestDefaultTypeInternal;
extern WorkRequestDefaultTypeInternal _WorkRequest_default_instance_;
class WorkRequest_Segment;
class WorkRequest_SegmentDefaultTypeInternal;
extern WorkRequest_SegmentDefaultTypeInternal _WorkRequest_Segment_default_instance_;
class Work_Part;
class Work_PartDefaultTypeInternal;
extern Work_PartDefaultTypeInternal _Work_Part_default_instance_;
class Work_Status;
class Work_StatusDefaultTypeInternal;
extern Work_StatusDefaultTypeInternal _Work_Status_default_instance_;
}  // namespace flex
PROTOBUF_NAMESPACE_OPEN
template<> ::flex::BeeRemoteNode* Arena::CreateMaybeMessage<::flex::BeeRemoteNode>(Arena*);
template<> ::flex::BulkUpdateWorkRequest* Arena::CreateMaybeMessage<::flex::BulkUpdateWorkRequest>(Arena*);
template<> ::flex::BulkUpdateWorkResponse* Arena::CreateMaybeMessage<::flex::BulkUpdateWorkResponse>(Arena*);
template<> ::flex::HeartbeatRequest* Arena::CreateMaybeMessage<::flex::HeartbeatRequest>(Arena*);
template<> ::flex::HeartbeatResponse* Arena::CreateMaybeMessage<::flex::HeartbeatResponse>(Arena*);
template<> ::flex::MockJob* Arena::CreateMaybeMessage<::flex::MockJob>(Arena*);
template<> ::flex::NodeStats* Arena::CreateMaybeMessage<::flex::NodeStats>(Arena*);
template<> ::flex::RemoteStorageTarget* Arena::CreateMaybeMessage<::flex::RemoteStorageTarget>(Arena*);
template<> ::flex::RemoteStorageTarget_Azure* Arena::CreateMaybeMessage<::flex::RemoteStorageTarget_Azure>(Arena*);
template<> ::flex::RemoteStorageTarget_POSIX* Arena::CreateMaybeMessage<::flex::RemoteStorageTarget_POSIX>(Arena*);
template<> ::flex::RemoteStorageTarget_Policies* Arena::CreateMaybeMessage<::flex::RemoteStorageTarget_Policies>(Arena*);
template<> ::flex::RemoteStorageTarget_S3* Arena::CreateMaybeMessage<::flex::RemoteStorageTarget_S3>(Arena*);
template<> ::flex::SubmitWorkRequest* Arena::CreateMaybeMessage<::flex::SubmitWorkRequest>(Arena*);
template<> ::flex::SubmitWorkResponse* Arena::CreateMaybeMessage<::flex::SubmitWorkResponse>(Arena*);
template<> ::flex::SyncJob* Arena::CreateMaybeMessage<::flex::SyncJob>(Arena*);
template<> ::flex::UpdateConfigRequest* Arena::CreateMaybeMessage<::flex::UpdateConfigRequest>(Arena*);
template<> ::flex::UpdateConfigResponse* Arena::CreateMaybeMessage<::flex::UpdateConfigResponse>(Arena*);
template<> ::flex::UpdateWorkRequest* Arena::CreateMaybeMessage<::flex::UpdateWorkRequest>(Arena*);
template<> ::flex::UpdateWorkResponse* Arena::CreateMaybeMessage<::flex::UpdateWorkResponse>(Arena*);
template<> ::flex::Work* Arena::CreateMaybeMessage<::flex::Work>(Arena*);
template<> ::flex::WorkRequest* Arena::CreateMaybeMessage<::flex::WorkRequest>(Arena*);
template<> ::flex::WorkRequest_Segment* Arena::CreateMaybeMessage<::flex::WorkRequest_Segment>(Arena*);
template<> ::flex::Work_Part* Arena::CreateMaybeMessage<::flex::Work_Part>(Arena*);
template<> ::flex::Work_Status* Arena::CreateMaybeMessage<::flex::Work_Status>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flex {

enum UpdateWorkRequest_NewState : int {
  UpdateWorkRequest_NewState_UNSPECIFIED = 0,
  UpdateWorkRequest_NewState_CANCELLED = 1,
  UpdateWorkRequest_NewState_UpdateWorkRequest_NewState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UpdateWorkRequest_NewState_UpdateWorkRequest_NewState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UpdateWorkRequest_NewState_IsValid(int value);
constexpr UpdateWorkRequest_NewState UpdateWorkRequest_NewState_NewState_MIN = UpdateWorkRequest_NewState_UNSPECIFIED;
constexpr UpdateWorkRequest_NewState UpdateWorkRequest_NewState_NewState_MAX = UpdateWorkRequest_NewState_CANCELLED;
constexpr int UpdateWorkRequest_NewState_NewState_ARRAYSIZE = UpdateWorkRequest_NewState_NewState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateWorkRequest_NewState_descriptor();
template<typename T>
inline const std::string& UpdateWorkRequest_NewState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateWorkRequest_NewState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateWorkRequest_NewState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateWorkRequest_NewState_descriptor(), enum_t_value);
}
inline bool UpdateWorkRequest_NewState_Parse(
    const std::string& name, UpdateWorkRequest_NewState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateWorkRequest_NewState>(
    UpdateWorkRequest_NewState_descriptor(), name, value);
}
enum BulkUpdateWorkRequest_NewState : int {
  BulkUpdateWorkRequest_NewState_UNSPECIFIED = 0,
  BulkUpdateWorkRequest_NewState_UNCHANGED = 1,
  BulkUpdateWorkRequest_NewState_BulkUpdateWorkRequest_NewState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BulkUpdateWorkRequest_NewState_BulkUpdateWorkRequest_NewState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BulkUpdateWorkRequest_NewState_IsValid(int value);
constexpr BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest_NewState_NewState_MIN = BulkUpdateWorkRequest_NewState_UNSPECIFIED;
constexpr BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest_NewState_NewState_MAX = BulkUpdateWorkRequest_NewState_UNCHANGED;
constexpr int BulkUpdateWorkRequest_NewState_NewState_ARRAYSIZE = BulkUpdateWorkRequest_NewState_NewState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BulkUpdateWorkRequest_NewState_descriptor();
template<typename T>
inline const std::string& BulkUpdateWorkRequest_NewState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BulkUpdateWorkRequest_NewState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BulkUpdateWorkRequest_NewState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BulkUpdateWorkRequest_NewState_descriptor(), enum_t_value);
}
inline bool BulkUpdateWorkRequest_NewState_Parse(
    const std::string& name, BulkUpdateWorkRequest_NewState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BulkUpdateWorkRequest_NewState>(
    BulkUpdateWorkRequest_NewState_descriptor(), name, value);
}
enum SyncJob_Operation : int {
  SyncJob_Operation_UNSPECIFIED = 0,
  SyncJob_Operation_UPLOAD = 1,
  SyncJob_Operation_DOWNLOAD = 2,
  SyncJob_Operation_SyncJob_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SyncJob_Operation_SyncJob_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SyncJob_Operation_IsValid(int value);
constexpr SyncJob_Operation SyncJob_Operation_Operation_MIN = SyncJob_Operation_UNSPECIFIED;
constexpr SyncJob_Operation SyncJob_Operation_Operation_MAX = SyncJob_Operation_DOWNLOAD;
constexpr int SyncJob_Operation_Operation_ARRAYSIZE = SyncJob_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SyncJob_Operation_descriptor();
template<typename T>
inline const std::string& SyncJob_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SyncJob_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SyncJob_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SyncJob_Operation_descriptor(), enum_t_value);
}
inline bool SyncJob_Operation_Parse(
    const std::string& name, SyncJob_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SyncJob_Operation>(
    SyncJob_Operation_descriptor(), name, value);
}
enum Work_State : int {
  Work_State_UNSPECIFIED = 0,
  Work_State_UNKNOWN = 1,
  Work_State_CREATED = 2,
  Work_State_SCHEDULED = 3,
  Work_State_RUNNING = 4,
  Work_State_ERROR = 6,
  Work_State_FAILED = 7,
  Work_State_CANCELLED = 8,
  Work_State_COMPLETED = 9,
  Work_State_Work_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Work_State_Work_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Work_State_IsValid(int value);
constexpr Work_State Work_State_State_MIN = Work_State_UNSPECIFIED;
constexpr Work_State Work_State_State_MAX = Work_State_COMPLETED;
constexpr int Work_State_State_ARRAYSIZE = Work_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Work_State_descriptor();
template<typename T>
inline const std::string& Work_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Work_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Work_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Work_State_descriptor(), enum_t_value);
}
inline bool Work_State_Parse(
    const std::string& name, Work_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Work_State>(
    Work_State_descriptor(), name, value);
}
enum UpdateConfigResponse_Result : int {
  UpdateConfigResponse_Result_UNSPECIFIED = 0,
  UpdateConfigResponse_Result_SUCCESS = 1,
  UpdateConfigResponse_Result_PARTIAL = 2,
  UpdateConfigResponse_Result_FAILURE = 3,
  UpdateConfigResponse_Result_UpdateConfigResponse_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UpdateConfigResponse_Result_UpdateConfigResponse_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UpdateConfigResponse_Result_IsValid(int value);
constexpr UpdateConfigResponse_Result UpdateConfigResponse_Result_Result_MIN = UpdateConfigResponse_Result_UNSPECIFIED;
constexpr UpdateConfigResponse_Result UpdateConfigResponse_Result_Result_MAX = UpdateConfigResponse_Result_FAILURE;
constexpr int UpdateConfigResponse_Result_Result_ARRAYSIZE = UpdateConfigResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateConfigResponse_Result_descriptor();
template<typename T>
inline const std::string& UpdateConfigResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateConfigResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateConfigResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateConfigResponse_Result_descriptor(), enum_t_value);
}
inline bool UpdateConfigResponse_Result_Parse(
    const std::string& name, UpdateConfigResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateConfigResponse_Result>(
    UpdateConfigResponse_Result_descriptor(), name, value);
}
// ===================================================================

class HeartbeatRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {};
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequest* New() const final {
    return CreateMaybeMessage<HeartbeatRequest>(nullptr);
  }

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeStatsFieldNumber = 1,
  };
  // bool include_stats = 1;
  void clear_include_stats();
  bool include_stats() const;
  void set_include_stats(bool value);
  private:
  bool _internal_include_stats() const;
  void _internal_set_include_stats(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flex.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool include_stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {};
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatResponse* New() const final {
    return CreateMaybeMessage<HeartbeatResponse>(nullptr);
  }

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeStatsFieldNumber = 2,
    kIsReadyFieldNumber = 1,
  };
  // .flex.NodeStats node_stats = 2;
  bool has_node_stats() const;
  private:
  bool _internal_has_node_stats() const;
  public:
  void clear_node_stats();
  const ::flex::NodeStats& node_stats() const;
  ::flex::NodeStats* release_node_stats();
  ::flex::NodeStats* mutable_node_stats();
  void set_allocated_node_stats(::flex::NodeStats* node_stats);
  private:
  const ::flex::NodeStats& _internal_node_stats() const;
  ::flex::NodeStats* _internal_mutable_node_stats();
  public:
  void unsafe_arena_set_allocated_node_stats(
      ::flex::NodeStats* node_stats);
  ::flex::NodeStats* unsafe_arena_release_node_stats();

  // bool is_ready = 1;
  void clear_is_ready();
  bool is_ready() const;
  void set_is_ready(bool value);
  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flex.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flex::NodeStats* node_stats_;
  bool is_ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class NodeStats PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.NodeStats) */ {
 public:
  inline NodeStats() : NodeStats(nullptr) {};
  virtual ~NodeStats();

  NodeStats(const NodeStats& from);
  NodeStats(NodeStats&& from) noexcept
    : NodeStats() {
    *this = ::std::move(from);
  }

  inline NodeStats& operator=(const NodeStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStats& operator=(NodeStats&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeStats* internal_default_instance() {
    return reinterpret_cast<const NodeStats*>(
               &_NodeStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeStats& a, NodeStats& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStats* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeStats* New() const final {
    return CreateMaybeMessage<NodeStats>(nullptr);
  }

  NodeStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeStats& from);
  void MergeFrom(const NodeStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.NodeStats";
  }
  protected:
  explicit NodeStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kActiveRequestsFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int64 active_requests = 2;
  void clear_active_requests();
  ::PROTOBUF_NAMESPACE_ID::int64 active_requests() const;
  void set_active_requests(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_active_requests() const;
  void _internal_set_active_requests(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:flex.NodeStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 active_requests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.SubmitWorkRequest) */ {
 public:
  inline SubmitWorkRequest() : SubmitWorkRequest(nullptr) {};
  virtual ~SubmitWorkRequest();

  SubmitWorkRequest(const SubmitWorkRequest& from);
  SubmitWorkRequest(SubmitWorkRequest&& from) noexcept
    : SubmitWorkRequest() {
    *this = ::std::move(from);
  }

  inline SubmitWorkRequest& operator=(const SubmitWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkRequest& operator=(SubmitWorkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmitWorkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitWorkRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkRequest*>(
               &_SubmitWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubmitWorkRequest& a, SubmitWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmitWorkRequest* New() const final {
    return CreateMaybeMessage<SubmitWorkRequest>(nullptr);
  }

  SubmitWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmitWorkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmitWorkRequest& from);
  void MergeFrom(const SubmitWorkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.SubmitWorkRequest";
  }
  protected:
  explicit SubmitWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .flex.WorkRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::flex::WorkRequest& request() const;
  ::flex::WorkRequest* release_request();
  ::flex::WorkRequest* mutable_request();
  void set_allocated_request(::flex::WorkRequest* request);
  private:
  const ::flex::WorkRequest& _internal_request() const;
  ::flex::WorkRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::flex::WorkRequest* request);
  ::flex::WorkRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:flex.SubmitWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flex::WorkRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.SubmitWorkResponse) */ {
 public:
  inline SubmitWorkResponse() : SubmitWorkResponse(nullptr) {};
  virtual ~SubmitWorkResponse();

  SubmitWorkResponse(const SubmitWorkResponse& from);
  SubmitWorkResponse(SubmitWorkResponse&& from) noexcept
    : SubmitWorkResponse() {
    *this = ::std::move(from);
  }

  inline SubmitWorkResponse& operator=(const SubmitWorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkResponse& operator=(SubmitWorkResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmitWorkResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitWorkResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkResponse*>(
               &_SubmitWorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubmitWorkResponse& a, SubmitWorkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmitWorkResponse* New() const final {
    return CreateMaybeMessage<SubmitWorkResponse>(nullptr);
  }

  SubmitWorkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmitWorkResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmitWorkResponse& from);
  void MergeFrom(const SubmitWorkResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.SubmitWorkResponse";
  }
  protected:
  explicit SubmitWorkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkFieldNumber = 1,
  };
  // .flex.Work work = 1;
  bool has_work() const;
  private:
  bool _internal_has_work() const;
  public:
  void clear_work();
  const ::flex::Work& work() const;
  ::flex::Work* release_work();
  ::flex::Work* mutable_work();
  void set_allocated_work(::flex::Work* work);
  private:
  const ::flex::Work& _internal_work() const;
  ::flex::Work* _internal_mutable_work();
  public:
  void unsafe_arena_set_allocated_work(
      ::flex::Work* work);
  ::flex::Work* unsafe_arena_release_work();

  // @@protoc_insertion_point(class_scope:flex.SubmitWorkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flex::Work* work_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateWorkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.UpdateWorkRequest) */ {
 public:
  inline UpdateWorkRequest() : UpdateWorkRequest(nullptr) {};
  virtual ~UpdateWorkRequest();

  UpdateWorkRequest(const UpdateWorkRequest& from);
  UpdateWorkRequest(UpdateWorkRequest&& from) noexcept
    : UpdateWorkRequest() {
    *this = ::std::move(from);
  }

  inline UpdateWorkRequest& operator=(const UpdateWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkRequest& operator=(UpdateWorkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateWorkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateWorkRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkRequest*>(
               &_UpdateWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateWorkRequest& a, UpdateWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateWorkRequest* New() const final {
    return CreateMaybeMessage<UpdateWorkRequest>(nullptr);
  }

  UpdateWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateWorkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateWorkRequest& from);
  void MergeFrom(const UpdateWorkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.UpdateWorkRequest";
  }
  protected:
  explicit UpdateWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UpdateWorkRequest_NewState NewState;
  static constexpr NewState UNSPECIFIED =
    UpdateWorkRequest_NewState_UNSPECIFIED;
  static constexpr NewState CANCELLED =
    UpdateWorkRequest_NewState_CANCELLED;
  static inline bool NewState_IsValid(int value) {
    return UpdateWorkRequest_NewState_IsValid(value);
  }
  static constexpr NewState NewState_MIN =
    UpdateWorkRequest_NewState_NewState_MIN;
  static constexpr NewState NewState_MAX =
    UpdateWorkRequest_NewState_NewState_MAX;
  static constexpr int NewState_ARRAYSIZE =
    UpdateWorkRequest_NewState_NewState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NewState_descriptor() {
    return UpdateWorkRequest_NewState_descriptor();
  }
  template<typename T>
  static inline const std::string& NewState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NewState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NewState_Name.");
    return UpdateWorkRequest_NewState_Name(enum_t_value);
  }
  static inline bool NewState_Parse(const std::string& name,
      NewState* value) {
    return UpdateWorkRequest_NewState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kNewStateFieldNumber = 3,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  void set_job_id(const std::string& value);
  void set_job_id(std::string&& value);
  void set_job_id(const char* value);
  void set_job_id(const char* value, size_t size);
  std::string* mutable_job_id();
  std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_job_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_job_id(
      std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  void set_request_id(const std::string& value);
  void set_request_id(std::string&& value);
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  std::string* mutable_request_id();
  std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_request_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_request_id(
      std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .flex.UpdateWorkRequest.NewState new_state = 3;
  void clear_new_state();
  ::flex::UpdateWorkRequest_NewState new_state() const;
  void set_new_state(::flex::UpdateWorkRequest_NewState value);
  private:
  ::flex::UpdateWorkRequest_NewState _internal_new_state() const;
  void _internal_set_new_state(::flex::UpdateWorkRequest_NewState value);
  public:

  // @@protoc_insertion_point(class_scope:flex.UpdateWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  int new_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateWorkResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.UpdateWorkResponse) */ {
 public:
  inline UpdateWorkResponse() : UpdateWorkResponse(nullptr) {};
  virtual ~UpdateWorkResponse();

  UpdateWorkResponse(const UpdateWorkResponse& from);
  UpdateWorkResponse(UpdateWorkResponse&& from) noexcept
    : UpdateWorkResponse() {
    *this = ::std::move(from);
  }

  inline UpdateWorkResponse& operator=(const UpdateWorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkResponse& operator=(UpdateWorkResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateWorkResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateWorkResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkResponse*>(
               &_UpdateWorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateWorkResponse& a, UpdateWorkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateWorkResponse* New() const final {
    return CreateMaybeMessage<UpdateWorkResponse>(nullptr);
  }

  UpdateWorkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateWorkResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateWorkResponse& from);
  void MergeFrom(const UpdateWorkResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.UpdateWorkResponse";
  }
  protected:
  explicit UpdateWorkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkFieldNumber = 1,
  };
  // .flex.Work work = 1;
  bool has_work() const;
  private:
  bool _internal_has_work() const;
  public:
  void clear_work();
  const ::flex::Work& work() const;
  ::flex::Work* release_work();
  ::flex::Work* mutable_work();
  void set_allocated_work(::flex::Work* work);
  private:
  const ::flex::Work& _internal_work() const;
  ::flex::Work* _internal_mutable_work();
  public:
  void unsafe_arena_set_allocated_work(
      ::flex::Work* work);
  ::flex::Work* unsafe_arena_release_work();

  // @@protoc_insertion_point(class_scope:flex.UpdateWorkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flex::Work* work_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class BulkUpdateWorkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.BulkUpdateWorkRequest) */ {
 public:
  inline BulkUpdateWorkRequest() : BulkUpdateWorkRequest(nullptr) {};
  virtual ~BulkUpdateWorkRequest();

  BulkUpdateWorkRequest(const BulkUpdateWorkRequest& from);
  BulkUpdateWorkRequest(BulkUpdateWorkRequest&& from) noexcept
    : BulkUpdateWorkRequest() {
    *this = ::std::move(from);
  }

  inline BulkUpdateWorkRequest& operator=(const BulkUpdateWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkUpdateWorkRequest& operator=(BulkUpdateWorkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkUpdateWorkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkUpdateWorkRequest* internal_default_instance() {
    return reinterpret_cast<const BulkUpdateWorkRequest*>(
               &_BulkUpdateWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BulkUpdateWorkRequest& a, BulkUpdateWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkUpdateWorkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkUpdateWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkUpdateWorkRequest* New() const final {
    return CreateMaybeMessage<BulkUpdateWorkRequest>(nullptr);
  }

  BulkUpdateWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkUpdateWorkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkUpdateWorkRequest& from);
  void MergeFrom(const BulkUpdateWorkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkUpdateWorkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.BulkUpdateWorkRequest";
  }
  protected:
  explicit BulkUpdateWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BulkUpdateWorkRequest_NewState NewState;
  static constexpr NewState UNSPECIFIED =
    BulkUpdateWorkRequest_NewState_UNSPECIFIED;
  static constexpr NewState UNCHANGED =
    BulkUpdateWorkRequest_NewState_UNCHANGED;
  static inline bool NewState_IsValid(int value) {
    return BulkUpdateWorkRequest_NewState_IsValid(value);
  }
  static constexpr NewState NewState_MIN =
    BulkUpdateWorkRequest_NewState_NewState_MIN;
  static constexpr NewState NewState_MAX =
    BulkUpdateWorkRequest_NewState_NewState_MAX;
  static constexpr int NewState_ARRAYSIZE =
    BulkUpdateWorkRequest_NewState_NewState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NewState_descriptor() {
    return BulkUpdateWorkRequest_NewState_descriptor();
  }
  template<typename T>
  static inline const std::string& NewState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NewState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NewState_Name.");
    return BulkUpdateWorkRequest_NewState_Name(enum_t_value);
  }
  static inline bool NewState_Parse(const std::string& name,
      NewState* value) {
    return BulkUpdateWorkRequest_NewState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNewStateFieldNumber = 1,
  };
  // .flex.BulkUpdateWorkRequest.NewState new_state = 1;
  void clear_new_state();
  ::flex::BulkUpdateWorkRequest_NewState new_state() const;
  void set_new_state(::flex::BulkUpdateWorkRequest_NewState value);
  private:
  ::flex::BulkUpdateWorkRequest_NewState _internal_new_state() const;
  void _internal_set_new_state(::flex::BulkUpdateWorkRequest_NewState value);
  public:

  // @@protoc_insertion_point(class_scope:flex.BulkUpdateWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int new_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class BulkUpdateWorkResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.BulkUpdateWorkResponse) */ {
 public:
  inline BulkUpdateWorkResponse() : BulkUpdateWorkResponse(nullptr) {};
  virtual ~BulkUpdateWorkResponse();

  BulkUpdateWorkResponse(const BulkUpdateWorkResponse& from);
  BulkUpdateWorkResponse(BulkUpdateWorkResponse&& from) noexcept
    : BulkUpdateWorkResponse() {
    *this = ::std::move(from);
  }

  inline BulkUpdateWorkResponse& operator=(const BulkUpdateWorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkUpdateWorkResponse& operator=(BulkUpdateWorkResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkUpdateWorkResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkUpdateWorkResponse* internal_default_instance() {
    return reinterpret_cast<const BulkUpdateWorkResponse*>(
               &_BulkUpdateWorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BulkUpdateWorkResponse& a, BulkUpdateWorkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkUpdateWorkResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkUpdateWorkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkUpdateWorkResponse* New() const final {
    return CreateMaybeMessage<BulkUpdateWorkResponse>(nullptr);
  }

  BulkUpdateWorkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkUpdateWorkResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkUpdateWorkResponse& from);
  void MergeFrom(const BulkUpdateWorkResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkUpdateWorkResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.BulkUpdateWorkResponse";
  }
  protected:
  explicit BulkUpdateWorkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flex.BulkUpdateWorkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class WorkRequest_Segment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.WorkRequest.Segment) */ {
 public:
  inline WorkRequest_Segment() : WorkRequest_Segment(nullptr) {};
  virtual ~WorkRequest_Segment();

  WorkRequest_Segment(const WorkRequest_Segment& from);
  WorkRequest_Segment(WorkRequest_Segment&& from) noexcept
    : WorkRequest_Segment() {
    *this = ::std::move(from);
  }

  inline WorkRequest_Segment& operator=(const WorkRequest_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkRequest_Segment& operator=(WorkRequest_Segment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkRequest_Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkRequest_Segment* internal_default_instance() {
    return reinterpret_cast<const WorkRequest_Segment*>(
               &_WorkRequest_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WorkRequest_Segment& a, WorkRequest_Segment& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkRequest_Segment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkRequest_Segment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkRequest_Segment* New() const final {
    return CreateMaybeMessage<WorkRequest_Segment>(nullptr);
  }

  WorkRequest_Segment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkRequest_Segment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkRequest_Segment& from);
  void MergeFrom(const WorkRequest_Segment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkRequest_Segment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.WorkRequest.Segment";
  }
  protected:
  explicit WorkRequest_Segment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetStartFieldNumber = 1,
    kOffsetStopFieldNumber = 2,
    kPartsStartFieldNumber = 3,
    kPartsStopFieldNumber = 4,
  };
  // int64 offset_start = 1;
  void clear_offset_start();
  ::PROTOBUF_NAMESPACE_ID::int64 offset_start() const;
  void set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset_start() const;
  void _internal_set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 offset_stop = 2;
  void clear_offset_stop();
  ::PROTOBUF_NAMESPACE_ID::int64 offset_stop() const;
  void set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset_stop() const;
  void _internal_set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 parts_start = 3;
  void clear_parts_start();
  ::PROTOBUF_NAMESPACE_ID::int32 parts_start() const;
  void set_parts_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_parts_start() const;
  void _internal_set_parts_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 parts_stop = 4;
  void clear_parts_stop();
  ::PROTOBUF_NAMESPACE_ID::int32 parts_stop() const;
  void set_parts_stop(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_parts_stop() const;
  void _internal_set_parts_stop(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flex.WorkRequest.Segment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_start_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_stop_;
  ::PROTOBUF_NAMESPACE_ID::int32 parts_start_;
  ::PROTOBUF_NAMESPACE_ID::int32 parts_stop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class WorkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.WorkRequest) */ {
 public:
  inline WorkRequest() : WorkRequest(nullptr) {};
  virtual ~WorkRequest();

  WorkRequest(const WorkRequest& from);
  WorkRequest(WorkRequest&& from) noexcept
    : WorkRequest() {
    *this = ::std::move(from);
  }

  inline WorkRequest& operator=(const WorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkRequest& operator=(WorkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkRequest& default_instance();

  enum TypeCase {
    kMock = 10,
    kSync = 11,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkRequest* internal_default_instance() {
    return reinterpret_cast<const WorkRequest*>(
               &_WorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WorkRequest& a, WorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkRequest* New() const final {
    return CreateMaybeMessage<WorkRequest>(nullptr);
  }

  WorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkRequest& from);
  void MergeFrom(const WorkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.WorkRequest";
  }
  protected:
  explicit WorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef WorkRequest_Segment Segment;

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kExternalIdFieldNumber = 3,
    kPathFieldNumber = 4,
    kRemoteStorageTargetFieldNumber = 6,
    kSegmentFieldNumber = 5,
    kMockFieldNumber = 10,
    kSyncFieldNumber = 11,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  void set_job_id(const std::string& value);
  void set_job_id(std::string&& value);
  void set_job_id(const char* value);
  void set_job_id(const char* value, size_t size);
  std::string* mutable_job_id();
  std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_job_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_job_id(
      std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  void set_request_id(const std::string& value);
  void set_request_id(std::string&& value);
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  std::string* mutable_request_id();
  std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_request_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_request_id(
      std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string external_id = 3;
  void clear_external_id();
  const std::string& external_id() const;
  void set_external_id(const std::string& value);
  void set_external_id(std::string&& value);
  void set_external_id(const char* value);
  void set_external_id(const char* value, size_t size);
  std::string* mutable_external_id();
  std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_external_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_external_id(
      std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // string path = 4;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string remote_storage_target = 6;
  void clear_remote_storage_target();
  const std::string& remote_storage_target() const;
  void set_remote_storage_target(const std::string& value);
  void set_remote_storage_target(std::string&& value);
  void set_remote_storage_target(const char* value);
  void set_remote_storage_target(const char* value, size_t size);
  std::string* mutable_remote_storage_target();
  std::string* release_remote_storage_target();
  void set_allocated_remote_storage_target(std::string* remote_storage_target);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_remote_storage_target();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_remote_storage_target(
      std::string* remote_storage_target);
  private:
  const std::string& _internal_remote_storage_target() const;
  void _internal_set_remote_storage_target(const std::string& value);
  std::string* _internal_mutable_remote_storage_target();
  public:

  // .flex.WorkRequest.Segment segment = 5;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  const ::flex::WorkRequest_Segment& segment() const;
  ::flex::WorkRequest_Segment* release_segment();
  ::flex::WorkRequest_Segment* mutable_segment();
  void set_allocated_segment(::flex::WorkRequest_Segment* segment);
  private:
  const ::flex::WorkRequest_Segment& _internal_segment() const;
  ::flex::WorkRequest_Segment* _internal_mutable_segment();
  public:
  void unsafe_arena_set_allocated_segment(
      ::flex::WorkRequest_Segment* segment);
  ::flex::WorkRequest_Segment* unsafe_arena_release_segment();

  // .flex.MockJob mock = 10;
  bool has_mock() const;
  private:
  bool _internal_has_mock() const;
  public:
  void clear_mock();
  const ::flex::MockJob& mock() const;
  ::flex::MockJob* release_mock();
  ::flex::MockJob* mutable_mock();
  void set_allocated_mock(::flex::MockJob* mock);
  private:
  const ::flex::MockJob& _internal_mock() const;
  ::flex::MockJob* _internal_mutable_mock();
  public:
  void unsafe_arena_set_allocated_mock(
      ::flex::MockJob* mock);
  ::flex::MockJob* unsafe_arena_release_mock();

  // .flex.SyncJob sync = 11;
  bool has_sync() const;
  private:
  bool _internal_has_sync() const;
  public:
  void clear_sync();
  const ::flex::SyncJob& sync() const;
  ::flex::SyncJob* release_sync();
  ::flex::SyncJob* mutable_sync();
  void set_allocated_sync(::flex::SyncJob* sync);
  private:
  const ::flex::SyncJob& _internal_sync() const;
  ::flex::SyncJob* _internal_mutable_sync();
  public:
  void unsafe_arena_set_allocated_sync(
      ::flex::SyncJob* sync);
  ::flex::SyncJob* unsafe_arena_release_sync();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:flex.WorkRequest)
 private:
  class _Internal;
  void set_has_mock();
  void set_has_sync();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_storage_target_;
  ::flex::WorkRequest_Segment* segment_;
  union TypeUnion {
    TypeUnion() {}
    ::flex::MockJob* mock_;
    ::flex::SyncJob* sync_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class MockJob PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.MockJob) */ {
 public:
  inline MockJob() : MockJob(nullptr) {};
  virtual ~MockJob();

  MockJob(const MockJob& from);
  MockJob(MockJob&& from) noexcept
    : MockJob() {
    *this = ::std::move(from);
  }

  inline MockJob& operator=(const MockJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline MockJob& operator=(MockJob&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MockJob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MockJob* internal_default_instance() {
    return reinterpret_cast<const MockJob*>(
               &_MockJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MockJob& a, MockJob& b) {
    a.Swap(&b);
  }
  inline void Swap(MockJob* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MockJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MockJob* New() const final {
    return CreateMaybeMessage<MockJob>(nullptr);
  }

  MockJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MockJob>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MockJob& from);
  void MergeFrom(const MockJob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MockJob* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.MockJob";
  }
  protected:
  explicit MockJob(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalIdFieldNumber = 3,
    kFileSizeFieldNumber = 2,
    kNumTestSegmentsFieldNumber = 1,
    kShouldFailFieldNumber = 4,
    kCanRetryFieldNumber = 5,
  };
  // string external_id = 3;
  void clear_external_id();
  const std::string& external_id() const;
  void set_external_id(const std::string& value);
  void set_external_id(std::string&& value);
  void set_external_id(const char* value);
  void set_external_id(const char* value, size_t size);
  std::string* mutable_external_id();
  std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_external_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_external_id(
      std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // int64 file_size = 2;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::int64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 num_test_segments = 1;
  void clear_num_test_segments();
  ::PROTOBUF_NAMESPACE_ID::int32 num_test_segments() const;
  void set_num_test_segments(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_test_segments() const;
  void _internal_set_num_test_segments(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool should_fail = 4;
  void clear_should_fail();
  bool should_fail() const;
  void set_should_fail(bool value);
  private:
  bool _internal_should_fail() const;
  void _internal_set_should_fail(bool value);
  public:

  // bool can_retry = 5;
  void clear_can_retry();
  bool can_retry() const;
  void set_can_retry(bool value);
  private:
  bool _internal_can_retry() const;
  void _internal_set_can_retry(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flex.MockJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 file_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_test_segments_;
  bool should_fail_;
  bool can_retry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class SyncJob PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.SyncJob) */ {
 public:
  inline SyncJob() : SyncJob(nullptr) {};
  virtual ~SyncJob();

  SyncJob(const SyncJob& from);
  SyncJob(SyncJob&& from) noexcept
    : SyncJob() {
    *this = ::std::move(from);
  }

  inline SyncJob& operator=(const SyncJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncJob& operator=(SyncJob&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SyncJob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncJob* internal_default_instance() {
    return reinterpret_cast<const SyncJob*>(
               &_SyncJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SyncJob& a, SyncJob& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncJob* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SyncJob* New() const final {
    return CreateMaybeMessage<SyncJob>(nullptr);
  }

  SyncJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SyncJob>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SyncJob& from);
  void MergeFrom(const SyncJob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncJob* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.SyncJob";
  }
  protected:
  explicit SyncJob(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SyncJob_Operation Operation;
  static constexpr Operation UNSPECIFIED =
    SyncJob_Operation_UNSPECIFIED;
  static constexpr Operation UPLOAD =
    SyncJob_Operation_UPLOAD;
  static constexpr Operation DOWNLOAD =
    SyncJob_Operation_DOWNLOAD;
  static inline bool Operation_IsValid(int value) {
    return SyncJob_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    SyncJob_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    SyncJob_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    SyncJob_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return SyncJob_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return SyncJob_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(const std::string& name,
      Operation* value) {
    return SyncJob_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRemotePathFieldNumber = 3,
    kOperationFieldNumber = 1,
    kOverwriteFieldNumber = 2,
  };
  // string remote_path = 3;
  void clear_remote_path();
  const std::string& remote_path() const;
  void set_remote_path(const std::string& value);
  void set_remote_path(std::string&& value);
  void set_remote_path(const char* value);
  void set_remote_path(const char* value, size_t size);
  std::string* mutable_remote_path();
  std::string* release_remote_path();
  void set_allocated_remote_path(std::string* remote_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_remote_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_remote_path(
      std::string* remote_path);
  private:
  const std::string& _internal_remote_path() const;
  void _internal_set_remote_path(const std::string& value);
  std::string* _internal_mutable_remote_path();
  public:

  // .flex.SyncJob.Operation operation = 1;
  void clear_operation();
  ::flex::SyncJob_Operation operation() const;
  void set_operation(::flex::SyncJob_Operation value);
  private:
  ::flex::SyncJob_Operation _internal_operation() const;
  void _internal_set_operation(::flex::SyncJob_Operation value);
  public:

  // bool overwrite = 2;
  void clear_overwrite();
  bool overwrite() const;
  void set_overwrite(bool value);
  private:
  bool _internal_overwrite() const;
  void _internal_set_overwrite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flex.SyncJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_path_;
  int operation_;
  bool overwrite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class Work_Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.Work.Status) */ {
 public:
  inline Work_Status() : Work_Status(nullptr) {};
  virtual ~Work_Status();

  Work_Status(const Work_Status& from);
  Work_Status(Work_Status&& from) noexcept
    : Work_Status() {
    *this = ::std::move(from);
  }

  inline Work_Status& operator=(const Work_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Work_Status& operator=(Work_Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Work_Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Work_Status* internal_default_instance() {
    return reinterpret_cast<const Work_Status*>(
               &_Work_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Work_Status& a, Work_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Work_Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Work_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Work_Status* New() const final {
    return CreateMaybeMessage<Work_Status>(nullptr);
  }

  Work_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Work_Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Work_Status& from);
  void MergeFrom(const Work_Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Work_Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.Work.Status";
  }
  protected:
  explicit Work_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .flex.Work.State state = 1;
  void clear_state();
  ::flex::Work_State state() const;
  void set_state(::flex::Work_State value);
  private:
  ::flex::Work_State _internal_state() const;
  void _internal_set_state(::flex::Work_State value);
  public:

  // @@protoc_insertion_point(class_scope:flex.Work.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class Work_Part PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.Work.Part) */ {
 public:
  inline Work_Part() : Work_Part(nullptr) {};
  virtual ~Work_Part();

  Work_Part(const Work_Part& from);
  Work_Part(Work_Part&& from) noexcept
    : Work_Part() {
    *this = ::std::move(from);
  }

  inline Work_Part& operator=(const Work_Part& from) {
    CopyFrom(from);
    return *this;
  }
  inline Work_Part& operator=(Work_Part&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Work_Part& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Work_Part* internal_default_instance() {
    return reinterpret_cast<const Work_Part*>(
               &_Work_Part_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Work_Part& a, Work_Part& b) {
    a.Swap(&b);
  }
  inline void Swap(Work_Part* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Work_Part* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Work_Part* New() const final {
    return CreateMaybeMessage<Work_Part>(nullptr);
  }

  Work_Part* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Work_Part>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Work_Part& from);
  void MergeFrom(const Work_Part& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Work_Part* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.Work.Part";
  }
  protected:
  explicit Work_Part(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityTagFieldNumber = 4,
    kChecksumSha256FieldNumber = 5,
    kOffsetStartFieldNumber = 2,
    kOffsetStopFieldNumber = 3,
    kPartNumberFieldNumber = 1,
    kCompletedFieldNumber = 6,
  };
  // string entity_tag = 4;
  void clear_entity_tag();
  const std::string& entity_tag() const;
  void set_entity_tag(const std::string& value);
  void set_entity_tag(std::string&& value);
  void set_entity_tag(const char* value);
  void set_entity_tag(const char* value, size_t size);
  std::string* mutable_entity_tag();
  std::string* release_entity_tag();
  void set_allocated_entity_tag(std::string* entity_tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_entity_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_entity_tag(
      std::string* entity_tag);
  private:
  const std::string& _internal_entity_tag() const;
  void _internal_set_entity_tag(const std::string& value);
  std::string* _internal_mutable_entity_tag();
  public:

  // string checksum_sha256 = 5;
  void clear_checksum_sha256();
  const std::string& checksum_sha256() const;
  void set_checksum_sha256(const std::string& value);
  void set_checksum_sha256(std::string&& value);
  void set_checksum_sha256(const char* value);
  void set_checksum_sha256(const char* value, size_t size);
  std::string* mutable_checksum_sha256();
  std::string* release_checksum_sha256();
  void set_allocated_checksum_sha256(std::string* checksum_sha256);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_checksum_sha256();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_checksum_sha256(
      std::string* checksum_sha256);
  private:
  const std::string& _internal_checksum_sha256() const;
  void _internal_set_checksum_sha256(const std::string& value);
  std::string* _internal_mutable_checksum_sha256();
  public:

  // int64 offset_start = 2;
  void clear_offset_start();
  ::PROTOBUF_NAMESPACE_ID::int64 offset_start() const;
  void set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset_start() const;
  void _internal_set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 offset_stop = 3;
  void clear_offset_stop();
  ::PROTOBUF_NAMESPACE_ID::int64 offset_stop() const;
  void set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset_stop() const;
  void _internal_set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 part_number = 1;
  void clear_part_number();
  ::PROTOBUF_NAMESPACE_ID::int32 part_number() const;
  void set_part_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_part_number() const;
  void _internal_set_part_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool completed = 6;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flex.Work.Part)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checksum_sha256_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_start_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_stop_;
  ::PROTOBUF_NAMESPACE_ID::int32 part_number_;
  bool completed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class Work PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.Work) */ {
 public:
  inline Work() : Work(nullptr) {};
  virtual ~Work();

  Work(const Work& from);
  Work(Work&& from) noexcept
    : Work() {
    *this = ::std::move(from);
  }

  inline Work& operator=(const Work& from) {
    CopyFrom(from);
    return *this;
  }
  inline Work& operator=(Work&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Work& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Work* internal_default_instance() {
    return reinterpret_cast<const Work*>(
               &_Work_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Work& a, Work& b) {
    a.Swap(&b);
  }
  inline void Swap(Work* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Work* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Work* New() const final {
    return CreateMaybeMessage<Work>(nullptr);
  }

  Work* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Work>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Work& from);
  void MergeFrom(const Work& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Work* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.Work";
  }
  protected:
  explicit Work(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Work_Status Status;
  typedef Work_Part Part;

  typedef Work_State State;
  static constexpr State UNSPECIFIED =
    Work_State_UNSPECIFIED;
  static constexpr State UNKNOWN =
    Work_State_UNKNOWN;
  static constexpr State CREATED =
    Work_State_CREATED;
  static constexpr State SCHEDULED =
    Work_State_SCHEDULED;
  static constexpr State RUNNING =
    Work_State_RUNNING;
  static constexpr State ERROR =
    Work_State_ERROR;
  static constexpr State FAILED =
    Work_State_FAILED;
  static constexpr State CANCELLED =
    Work_State_CANCELLED;
  static constexpr State COMPLETED =
    Work_State_COMPLETED;
  static inline bool State_IsValid(int value) {
    return Work_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Work_State_State_MIN;
  static constexpr State State_MAX =
    Work_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Work_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Work_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Work_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return Work_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 5,
    kPathFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kRequestIdFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // repeated .flex.Work.Part parts = 5;
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::flex::Work_Part* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::Work_Part >*
      mutable_parts();
  private:
  const ::flex::Work_Part& _internal_parts(int index) const;
  ::flex::Work_Part* _internal_add_parts();
  public:
  const ::flex::Work_Part& parts(int index) const;
  ::flex::Work_Part* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::Work_Part >&
      parts() const;

  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string job_id = 2;
  void clear_job_id();
  const std::string& job_id() const;
  void set_job_id(const std::string& value);
  void set_job_id(std::string&& value);
  void set_job_id(const char* value);
  void set_job_id(const char* value, size_t size);
  std::string* mutable_job_id();
  std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_job_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_job_id(
      std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string request_id = 3;
  void clear_request_id();
  const std::string& request_id() const;
  void set_request_id(const std::string& value);
  void set_request_id(std::string&& value);
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  std::string* mutable_request_id();
  std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_request_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_request_id(
      std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .flex.Work.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::flex::Work_Status& status() const;
  ::flex::Work_Status* release_status();
  ::flex::Work_Status* mutable_status();
  void set_allocated_status(::flex::Work_Status* status);
  private:
  const ::flex::Work_Status& _internal_status() const;
  ::flex::Work_Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::flex::Work_Status* status);
  ::flex::Work_Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:flex.Work)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::Work_Part > parts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::flex::Work_Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateConfigRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.UpdateConfigRequest) */ {
 public:
  inline UpdateConfigRequest() : UpdateConfigRequest(nullptr) {};
  virtual ~UpdateConfigRequest();

  UpdateConfigRequest(const UpdateConfigRequest& from);
  UpdateConfigRequest(UpdateConfigRequest&& from) noexcept
    : UpdateConfigRequest() {
    *this = ::std::move(from);
  }

  inline UpdateConfigRequest& operator=(const UpdateConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConfigRequest& operator=(UpdateConfigRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateConfigRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateConfigRequest*>(
               &_UpdateConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateConfigRequest& a, UpdateConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConfigRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateConfigRequest* New() const final {
    return CreateMaybeMessage<UpdateConfigRequest>(nullptr);
  }

  UpdateConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateConfigRequest& from);
  void MergeFrom(const UpdateConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.UpdateConfigRequest";
  }
  protected:
  explicit UpdateConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRstsFieldNumber = 2,
    kBeeRemoteFieldNumber = 1,
  };
  // repeated .flex.RemoteStorageTarget rsts = 2;
  int rsts_size() const;
  private:
  int _internal_rsts_size() const;
  public:
  void clear_rsts();
  ::flex::RemoteStorageTarget* mutable_rsts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::RemoteStorageTarget >*
      mutable_rsts();
  private:
  const ::flex::RemoteStorageTarget& _internal_rsts(int index) const;
  ::flex::RemoteStorageTarget* _internal_add_rsts();
  public:
  const ::flex::RemoteStorageTarget& rsts(int index) const;
  ::flex::RemoteStorageTarget* add_rsts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::RemoteStorageTarget >&
      rsts() const;

  // .flex.BeeRemoteNode bee_remote = 1;
  bool has_bee_remote() const;
  private:
  bool _internal_has_bee_remote() const;
  public:
  void clear_bee_remote();
  const ::flex::BeeRemoteNode& bee_remote() const;
  ::flex::BeeRemoteNode* release_bee_remote();
  ::flex::BeeRemoteNode* mutable_bee_remote();
  void set_allocated_bee_remote(::flex::BeeRemoteNode* bee_remote);
  private:
  const ::flex::BeeRemoteNode& _internal_bee_remote() const;
  ::flex::BeeRemoteNode* _internal_mutable_bee_remote();
  public:
  void unsafe_arena_set_allocated_bee_remote(
      ::flex::BeeRemoteNode* bee_remote);
  ::flex::BeeRemoteNode* unsafe_arena_release_bee_remote();

  // @@protoc_insertion_point(class_scope:flex.UpdateConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::RemoteStorageTarget > rsts_;
  ::flex::BeeRemoteNode* bee_remote_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateConfigResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.UpdateConfigResponse) */ {
 public:
  inline UpdateConfigResponse() : UpdateConfigResponse(nullptr) {};
  virtual ~UpdateConfigResponse();

  UpdateConfigResponse(const UpdateConfigResponse& from);
  UpdateConfigResponse(UpdateConfigResponse&& from) noexcept
    : UpdateConfigResponse() {
    *this = ::std::move(from);
  }

  inline UpdateConfigResponse& operator=(const UpdateConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConfigResponse& operator=(UpdateConfigResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateConfigResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateConfigResponse*>(
               &_UpdateConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateConfigResponse& a, UpdateConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConfigResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateConfigResponse* New() const final {
    return CreateMaybeMessage<UpdateConfigResponse>(nullptr);
  }

  UpdateConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateConfigResponse& from);
  void MergeFrom(const UpdateConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.UpdateConfigResponse";
  }
  protected:
  explicit UpdateConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UpdateConfigResponse_Result Result;
  static constexpr Result UNSPECIFIED =
    UpdateConfigResponse_Result_UNSPECIFIED;
  static constexpr Result SUCCESS =
    UpdateConfigResponse_Result_SUCCESS;
  static constexpr Result PARTIAL =
    UpdateConfigResponse_Result_PARTIAL;
  static constexpr Result FAILURE =
    UpdateConfigResponse_Result_FAILURE;
  static inline bool Result_IsValid(int value) {
    return UpdateConfigResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    UpdateConfigResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    UpdateConfigResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    UpdateConfigResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return UpdateConfigResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return UpdateConfigResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(const std::string& name,
      Result* value) {
    return UpdateConfigResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .flex.UpdateConfigResponse.Result result = 1;
  void clear_result();
  ::flex::UpdateConfigResponse_Result result() const;
  void set_result(::flex::UpdateConfigResponse_Result value);
  private:
  ::flex::UpdateConfigResponse_Result _internal_result() const;
  void _internal_set_result(::flex::UpdateConfigResponse_Result value);
  public:

  // @@protoc_insertion_point(class_scope:flex.UpdateConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class BeeRemoteNode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.BeeRemoteNode) */ {
 public:
  inline BeeRemoteNode() : BeeRemoteNode(nullptr) {};
  virtual ~BeeRemoteNode();

  BeeRemoteNode(const BeeRemoteNode& from);
  BeeRemoteNode(BeeRemoteNode&& from) noexcept
    : BeeRemoteNode() {
    *this = ::std::move(from);
  }

  inline BeeRemoteNode& operator=(const BeeRemoteNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeeRemoteNode& operator=(BeeRemoteNode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BeeRemoteNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BeeRemoteNode* internal_default_instance() {
    return reinterpret_cast<const BeeRemoteNode*>(
               &_BeeRemoteNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BeeRemoteNode& a, BeeRemoteNode& b) {
    a.Swap(&b);
  }
  inline void Swap(BeeRemoteNode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeeRemoteNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BeeRemoteNode* New() const final {
    return CreateMaybeMessage<BeeRemoteNode>(nullptr);
  }

  BeeRemoteNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BeeRemoteNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BeeRemoteNode& from);
  void MergeFrom(const BeeRemoteNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeeRemoteNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.BeeRemoteNode";
  }
  protected:
  explicit BeeRemoteNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_address(
      std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:flex.BeeRemoteNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_Policies PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.Policies) */ {
 public:
  inline RemoteStorageTarget_Policies() : RemoteStorageTarget_Policies(nullptr) {};
  virtual ~RemoteStorageTarget_Policies();

  RemoteStorageTarget_Policies(const RemoteStorageTarget_Policies& from);
  RemoteStorageTarget_Policies(RemoteStorageTarget_Policies&& from) noexcept
    : RemoteStorageTarget_Policies() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_Policies& operator=(const RemoteStorageTarget_Policies& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_Policies& operator=(RemoteStorageTarget_Policies&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_Policies& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_Policies* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_Policies*>(
               &_RemoteStorageTarget_Policies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RemoteStorageTarget_Policies& a, RemoteStorageTarget_Policies& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_Policies* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_Policies* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_Policies* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_Policies>(nullptr);
  }

  RemoteStorageTarget_Policies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_Policies>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_Policies& from);
  void MergeFrom(const RemoteStorageTarget_Policies& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_Policies* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.RemoteStorageTarget.Policies";
  }
  protected:
  explicit RemoteStorageTarget_Policies(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFastStartMaxSizeFieldNumber = 1,
  };
  // int64 fast_start_max_size = 1;
  void clear_fast_start_max_size();
  ::PROTOBUF_NAMESPACE_ID::int64 fast_start_max_size() const;
  void set_fast_start_max_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_fast_start_max_size() const;
  void _internal_set_fast_start_max_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.Policies)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 fast_start_max_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_S3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.S3) */ {
 public:
  inline RemoteStorageTarget_S3() : RemoteStorageTarget_S3(nullptr) {};
  virtual ~RemoteStorageTarget_S3();

  RemoteStorageTarget_S3(const RemoteStorageTarget_S3& from);
  RemoteStorageTarget_S3(RemoteStorageTarget_S3&& from) noexcept
    : RemoteStorageTarget_S3() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_S3& operator=(const RemoteStorageTarget_S3& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_S3& operator=(RemoteStorageTarget_S3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_S3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_S3* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_S3*>(
               &_RemoteStorageTarget_S3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RemoteStorageTarget_S3& a, RemoteStorageTarget_S3& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_S3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_S3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_S3* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_S3>(nullptr);
  }

  RemoteStorageTarget_S3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_S3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_S3& from);
  void MergeFrom(const RemoteStorageTarget_S3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_S3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.RemoteStorageTarget.S3";
  }
  protected:
  explicit RemoteStorageTarget_S3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointUrlFieldNumber = 1,
    kPartitionIdFieldNumber = 2,
    kRegionFieldNumber = 3,
    kBucketFieldNumber = 4,
    kAccessKeyFieldNumber = 5,
    kSecretKeyFieldNumber = 6,
  };
  // string endpoint_url = 1;
  void clear_endpoint_url();
  const std::string& endpoint_url() const;
  void set_endpoint_url(const std::string& value);
  void set_endpoint_url(std::string&& value);
  void set_endpoint_url(const char* value);
  void set_endpoint_url(const char* value, size_t size);
  std::string* mutable_endpoint_url();
  std::string* release_endpoint_url();
  void set_allocated_endpoint_url(std::string* endpoint_url);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_endpoint_url();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_endpoint_url(
      std::string* endpoint_url);
  private:
  const std::string& _internal_endpoint_url() const;
  void _internal_set_endpoint_url(const std::string& value);
  std::string* _internal_mutable_endpoint_url();
  public:

  // string partition_id = 2;
  void clear_partition_id();
  const std::string& partition_id() const;
  void set_partition_id(const std::string& value);
  void set_partition_id(std::string&& value);
  void set_partition_id(const char* value);
  void set_partition_id(const char* value, size_t size);
  std::string* mutable_partition_id();
  std::string* release_partition_id();
  void set_allocated_partition_id(std::string* partition_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_partition_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_partition_id(
      std::string* partition_id);
  private:
  const std::string& _internal_partition_id() const;
  void _internal_set_partition_id(const std::string& value);
  std::string* _internal_mutable_partition_id();
  public:

  // string region = 3;
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_region();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_region(
      std::string* region);
  private:
  const std::string& _internal_region() const;
  void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string bucket = 4;
  void clear_bucket();
  const std::string& bucket() const;
  void set_bucket(const std::string& value);
  void set_bucket(std::string&& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  std::string* mutable_bucket();
  std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_bucket();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_bucket(
      std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // string access_key = 5;
  void clear_access_key();
  const std::string& access_key() const;
  void set_access_key(const std::string& value);
  void set_access_key(std::string&& value);
  void set_access_key(const char* value);
  void set_access_key(const char* value, size_t size);
  std::string* mutable_access_key();
  std::string* release_access_key();
  void set_allocated_access_key(std::string* access_key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_access_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_access_key(
      std::string* access_key);
  private:
  const std::string& _internal_access_key() const;
  void _internal_set_access_key(const std::string& value);
  std::string* _internal_mutable_access_key();
  public:

  // string secret_key = 6;
  void clear_secret_key();
  const std::string& secret_key() const;
  void set_secret_key(const std::string& value);
  void set_secret_key(std::string&& value);
  void set_secret_key(const char* value);
  void set_secret_key(const char* value, size_t size);
  std::string* mutable_secret_key();
  std::string* release_secret_key();
  void set_allocated_secret_key(std::string* secret_key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_secret_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_secret_key(
      std::string* secret_key);
  private:
  const std::string& _internal_secret_key() const;
  void _internal_set_secret_key(const std::string& value);
  std::string* _internal_mutable_secret_key();
  public:

  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.S3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_Azure PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.Azure) */ {
 public:
  inline RemoteStorageTarget_Azure() : RemoteStorageTarget_Azure(nullptr) {};
  virtual ~RemoteStorageTarget_Azure();

  RemoteStorageTarget_Azure(const RemoteStorageTarget_Azure& from);
  RemoteStorageTarget_Azure(RemoteStorageTarget_Azure&& from) noexcept
    : RemoteStorageTarget_Azure() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_Azure& operator=(const RemoteStorageTarget_Azure& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_Azure& operator=(RemoteStorageTarget_Azure&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_Azure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_Azure* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_Azure*>(
               &_RemoteStorageTarget_Azure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RemoteStorageTarget_Azure& a, RemoteStorageTarget_Azure& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_Azure* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_Azure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_Azure* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_Azure>(nullptr);
  }

  RemoteStorageTarget_Azure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_Azure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_Azure& from);
  void MergeFrom(const RemoteStorageTarget_Azure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_Azure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.RemoteStorageTarget.Azure";
  }
  protected:
  explicit RemoteStorageTarget_Azure(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kS3FieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_account();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_account(
      std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // .flex.RemoteStorageTarget.S3 s3 = 1;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::flex::RemoteStorageTarget_S3& s3() const;
  ::flex::RemoteStorageTarget_S3* release_s3();
  ::flex::RemoteStorageTarget_S3* mutable_s3();
  void set_allocated_s3(::flex::RemoteStorageTarget_S3* s3);
  private:
  const ::flex::RemoteStorageTarget_S3& _internal_s3() const;
  ::flex::RemoteStorageTarget_S3* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::flex::RemoteStorageTarget_S3* s3);
  ::flex::RemoteStorageTarget_S3* unsafe_arena_release_s3();

  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.Azure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::flex::RemoteStorageTarget_S3* s3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_POSIX PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.POSIX) */ {
 public:
  inline RemoteStorageTarget_POSIX() : RemoteStorageTarget_POSIX(nullptr) {};
  virtual ~RemoteStorageTarget_POSIX();

  RemoteStorageTarget_POSIX(const RemoteStorageTarget_POSIX& from);
  RemoteStorageTarget_POSIX(RemoteStorageTarget_POSIX&& from) noexcept
    : RemoteStorageTarget_POSIX() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget_POSIX& operator=(const RemoteStorageTarget_POSIX& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_POSIX& operator=(RemoteStorageTarget_POSIX&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget_POSIX& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget_POSIX* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_POSIX*>(
               &_RemoteStorageTarget_POSIX_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RemoteStorageTarget_POSIX& a, RemoteStorageTarget_POSIX& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget_POSIX* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_POSIX* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget_POSIX* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget_POSIX>(nullptr);
  }

  RemoteStorageTarget_POSIX* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget_POSIX>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget_POSIX& from);
  void MergeFrom(const RemoteStorageTarget_POSIX& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget_POSIX* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.RemoteStorageTarget.POSIX";
  }
  protected:
  explicit RemoteStorageTarget_POSIX(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.POSIX)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget) */ {
 public:
  inline RemoteStorageTarget() : RemoteStorageTarget(nullptr) {};
  virtual ~RemoteStorageTarget();

  RemoteStorageTarget(const RemoteStorageTarget& from);
  RemoteStorageTarget(RemoteStorageTarget&& from) noexcept
    : RemoteStorageTarget() {
    *this = ::std::move(from);
  }

  inline RemoteStorageTarget& operator=(const RemoteStorageTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget& operator=(RemoteStorageTarget&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteStorageTarget& default_instance();

  enum TypeCase {
    kS3 = 4,
    kPosix = 5,
    kAzure = 6,
    kMock = 7,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteStorageTarget* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget*>(
               &_RemoteStorageTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RemoteStorageTarget& a, RemoteStorageTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteStorageTarget* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteStorageTarget* New() const final {
    return CreateMaybeMessage<RemoteStorageTarget>(nullptr);
  }

  RemoteStorageTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteStorageTarget>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteStorageTarget& from);
  void MergeFrom(const RemoteStorageTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteStorageTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flex.RemoteStorageTarget";
  }
  protected:
  explicit RemoteStorageTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flex_2eproto);
    return ::descriptor_table_flex_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RemoteStorageTarget_Policies Policies;
  typedef RemoteStorageTarget_S3 S3;
  typedef RemoteStorageTarget_Azure Azure;
  typedef RemoteStorageTarget_POSIX POSIX;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPoliciesFieldNumber = 3,
    kS3FieldNumber = 4,
    kPosixFieldNumber = 5,
    kAzureFieldNumber = 6,
    kMockFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flex.RemoteStorageTarget.Policies policies = 3;
  bool has_policies() const;
  private:
  bool _internal_has_policies() const;
  public:
  void clear_policies();
  const ::flex::RemoteStorageTarget_Policies& policies() const;
  ::flex::RemoteStorageTarget_Policies* release_policies();
  ::flex::RemoteStorageTarget_Policies* mutable_policies();
  void set_allocated_policies(::flex::RemoteStorageTarget_Policies* policies);
  private:
  const ::flex::RemoteStorageTarget_Policies& _internal_policies() const;
  ::flex::RemoteStorageTarget_Policies* _internal_mutable_policies();
  public:
  void unsafe_arena_set_allocated_policies(
      ::flex::RemoteStorageTarget_Policies* policies);
  ::flex::RemoteStorageTarget_Policies* unsafe_arena_release_policies();

  // .flex.RemoteStorageTarget.S3 s3 = 4;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::flex::RemoteStorageTarget_S3& s3() const;
  ::flex::RemoteStorageTarget_S3* release_s3();
  ::flex::RemoteStorageTarget_S3* mutable_s3();
  void set_allocated_s3(::flex::RemoteStorageTarget_S3* s3);
  private:
  const ::flex::RemoteStorageTarget_S3& _internal_s3() const;
  ::flex::RemoteStorageTarget_S3* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::flex::RemoteStorageTarget_S3* s3);
  ::flex::RemoteStorageTarget_S3* unsafe_arena_release_s3();

  // .flex.RemoteStorageTarget.POSIX posix = 5;
  bool has_posix() const;
  private:
  bool _internal_has_posix() const;
  public:
  void clear_posix();
  const ::flex::RemoteStorageTarget_POSIX& posix() const;
  ::flex::RemoteStorageTarget_POSIX* release_posix();
  ::flex::RemoteStorageTarget_POSIX* mutable_posix();
  void set_allocated_posix(::flex::RemoteStorageTarget_POSIX* posix);
  private:
  const ::flex::RemoteStorageTarget_POSIX& _internal_posix() const;
  ::flex::RemoteStorageTarget_POSIX* _internal_mutable_posix();
  public:
  void unsafe_arena_set_allocated_posix(
      ::flex::RemoteStorageTarget_POSIX* posix);
  ::flex::RemoteStorageTarget_POSIX* unsafe_arena_release_posix();

  // .flex.RemoteStorageTarget.Azure azure = 6;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::flex::RemoteStorageTarget_Azure& azure() const;
  ::flex::RemoteStorageTarget_Azure* release_azure();
  ::flex::RemoteStorageTarget_Azure* mutable_azure();
  void set_allocated_azure(::flex::RemoteStorageTarget_Azure* azure);
  private:
  const ::flex::RemoteStorageTarget_Azure& _internal_azure() const;
  ::flex::RemoteStorageTarget_Azure* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::flex::RemoteStorageTarget_Azure* azure);
  ::flex::RemoteStorageTarget_Azure* unsafe_arena_release_azure();

  // string mock = 7;
  private:
  bool _internal_has_mock() const;
  public:
  void clear_mock();
  const std::string& mock() const;
  void set_mock(const std::string& value);
  void set_mock(std::string&& value);
  void set_mock(const char* value);
  void set_mock(const char* value, size_t size);
  std::string* mutable_mock();
  std::string* release_mock();
  void set_allocated_mock(std::string* mock);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mock();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mock(
      std::string* mock);
  private:
  const std::string& _internal_mock() const;
  void _internal_set_mock(const std::string& value);
  std::string* _internal_mutable_mock();
  public:

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_posix();
  void set_has_azure();
  void set_has_mock();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flex::RemoteStorageTarget_Policies* policies_;
  union TypeUnion {
    TypeUnion() {}
    ::flex::RemoteStorageTarget_S3* s3_;
    ::flex::RemoteStorageTarget_POSIX* posix_;
    ::flex::RemoteStorageTarget_Azure* azure_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mock_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flex_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatRequest

// bool include_stats = 1;
inline void HeartbeatRequest::clear_include_stats() {
  include_stats_ = false;
}
inline bool HeartbeatRequest::_internal_include_stats() const {
  return include_stats_;
}
inline bool HeartbeatRequest::include_stats() const {
  // @@protoc_insertion_point(field_get:flex.HeartbeatRequest.include_stats)
  return _internal_include_stats();
}
inline void HeartbeatRequest::_internal_set_include_stats(bool value) {
  
  include_stats_ = value;
}
inline void HeartbeatRequest::set_include_stats(bool value) {
  _internal_set_include_stats(value);
  // @@protoc_insertion_point(field_set:flex.HeartbeatRequest.include_stats)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// bool is_ready = 1;
inline void HeartbeatResponse::clear_is_ready() {
  is_ready_ = false;
}
inline bool HeartbeatResponse::_internal_is_ready() const {
  return is_ready_;
}
inline bool HeartbeatResponse::is_ready() const {
  // @@protoc_insertion_point(field_get:flex.HeartbeatResponse.is_ready)
  return _internal_is_ready();
}
inline void HeartbeatResponse::_internal_set_is_ready(bool value) {
  
  is_ready_ = value;
}
inline void HeartbeatResponse::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  // @@protoc_insertion_point(field_set:flex.HeartbeatResponse.is_ready)
}

// .flex.NodeStats node_stats = 2;
inline bool HeartbeatResponse::_internal_has_node_stats() const {
  return this != internal_default_instance() && node_stats_ != nullptr;
}
inline bool HeartbeatResponse::has_node_stats() const {
  return _internal_has_node_stats();
}
inline void HeartbeatResponse::clear_node_stats() {
  if (GetArena() == nullptr && node_stats_ != nullptr) {
    delete node_stats_;
  }
  node_stats_ = nullptr;
}
inline const ::flex::NodeStats& HeartbeatResponse::_internal_node_stats() const {
  const ::flex::NodeStats* p = node_stats_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::NodeStats*>(
      &::flex::_NodeStats_default_instance_);
}
inline const ::flex::NodeStats& HeartbeatResponse::node_stats() const {
  // @@protoc_insertion_point(field_get:flex.HeartbeatResponse.node_stats)
  return _internal_node_stats();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_node_stats(
    ::flex::NodeStats* node_stats) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_stats_);
  }
  node_stats_ = node_stats;
  if (node_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.HeartbeatResponse.node_stats)
}
inline ::flex::NodeStats* HeartbeatResponse::release_node_stats() {
  auto temp = unsafe_arena_release_node_stats();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::NodeStats* HeartbeatResponse::unsafe_arena_release_node_stats() {
  // @@protoc_insertion_point(field_release:flex.HeartbeatResponse.node_stats)
  
  ::flex::NodeStats* temp = node_stats_;
  node_stats_ = nullptr;
  return temp;
}
inline ::flex::NodeStats* HeartbeatResponse::_internal_mutable_node_stats() {
  
  if (node_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::NodeStats>(GetArena());
    node_stats_ = p;
  }
  return node_stats_;
}
inline ::flex::NodeStats* HeartbeatResponse::mutable_node_stats() {
  // @@protoc_insertion_point(field_mutable:flex.HeartbeatResponse.node_stats)
  return _internal_mutable_node_stats();
}
inline void HeartbeatResponse::set_allocated_node_stats(::flex::NodeStats* node_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete node_stats_;
  }
  if (node_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(node_stats);
    if (message_arena != submessage_arena) {
      node_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_stats, submessage_arena);
    }
    
  } else {
    
  }
  node_stats_ = node_stats;
  // @@protoc_insertion_point(field_set_allocated:flex.HeartbeatResponse.node_stats)
}

// -------------------------------------------------------------------

// NodeStats

// .google.protobuf.Timestamp timestamp = 1;
inline bool NodeStats::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool NodeStats::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& NodeStats::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& NodeStats::timestamp() const {
  // @@protoc_insertion_point(field_get:flex.NodeStats.timestamp)
  return _internal_timestamp();
}
inline void NodeStats::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.NodeStats.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* NodeStats::release_timestamp() {
  auto temp = unsafe_arena_release_timestamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* NodeStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:flex.NodeStats.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* NodeStats::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* NodeStats::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:flex.NodeStats.timestamp)
  return _internal_mutable_timestamp();
}
inline void NodeStats::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:flex.NodeStats.timestamp)
}

// int64 active_requests = 2;
inline void NodeStats::clear_active_requests() {
  active_requests_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeStats::_internal_active_requests() const {
  return active_requests_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeStats::active_requests() const {
  // @@protoc_insertion_point(field_get:flex.NodeStats.active_requests)
  return _internal_active_requests();
}
inline void NodeStats::_internal_set_active_requests(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  active_requests_ = value;
}
inline void NodeStats::set_active_requests(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_active_requests(value);
  // @@protoc_insertion_point(field_set:flex.NodeStats.active_requests)
}

// -------------------------------------------------------------------

// SubmitWorkRequest

// .flex.WorkRequest request = 1;
inline bool SubmitWorkRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool SubmitWorkRequest::has_request() const {
  return _internal_has_request();
}
inline void SubmitWorkRequest::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::flex::WorkRequest& SubmitWorkRequest::_internal_request() const {
  const ::flex::WorkRequest* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::WorkRequest*>(
      &::flex::_WorkRequest_default_instance_);
}
inline const ::flex::WorkRequest& SubmitWorkRequest::request() const {
  // @@protoc_insertion_point(field_get:flex.SubmitWorkRequest.request)
  return _internal_request();
}
inline void SubmitWorkRequest::unsafe_arena_set_allocated_request(
    ::flex::WorkRequest* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.SubmitWorkRequest.request)
}
inline ::flex::WorkRequest* SubmitWorkRequest::release_request() {
  auto temp = unsafe_arena_release_request();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::WorkRequest* SubmitWorkRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:flex.SubmitWorkRequest.request)
  
  ::flex::WorkRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::flex::WorkRequest* SubmitWorkRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::WorkRequest>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::flex::WorkRequest* SubmitWorkRequest::mutable_request() {
  // @@protoc_insertion_point(field_mutable:flex.SubmitWorkRequest.request)
  return _internal_mutable_request();
}
inline void SubmitWorkRequest::set_allocated_request(::flex::WorkRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:flex.SubmitWorkRequest.request)
}

// -------------------------------------------------------------------

// SubmitWorkResponse

// .flex.Work work = 1;
inline bool SubmitWorkResponse::_internal_has_work() const {
  return this != internal_default_instance() && work_ != nullptr;
}
inline bool SubmitWorkResponse::has_work() const {
  return _internal_has_work();
}
inline void SubmitWorkResponse::clear_work() {
  if (GetArena() == nullptr && work_ != nullptr) {
    delete work_;
  }
  work_ = nullptr;
}
inline const ::flex::Work& SubmitWorkResponse::_internal_work() const {
  const ::flex::Work* p = work_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::Work*>(
      &::flex::_Work_default_instance_);
}
inline const ::flex::Work& SubmitWorkResponse::work() const {
  // @@protoc_insertion_point(field_get:flex.SubmitWorkResponse.work)
  return _internal_work();
}
inline void SubmitWorkResponse::unsafe_arena_set_allocated_work(
    ::flex::Work* work) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(work_);
  }
  work_ = work;
  if (work) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.SubmitWorkResponse.work)
}
inline ::flex::Work* SubmitWorkResponse::release_work() {
  auto temp = unsafe_arena_release_work();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::Work* SubmitWorkResponse::unsafe_arena_release_work() {
  // @@protoc_insertion_point(field_release:flex.SubmitWorkResponse.work)
  
  ::flex::Work* temp = work_;
  work_ = nullptr;
  return temp;
}
inline ::flex::Work* SubmitWorkResponse::_internal_mutable_work() {
  
  if (work_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::Work>(GetArena());
    work_ = p;
  }
  return work_;
}
inline ::flex::Work* SubmitWorkResponse::mutable_work() {
  // @@protoc_insertion_point(field_mutable:flex.SubmitWorkResponse.work)
  return _internal_mutable_work();
}
inline void SubmitWorkResponse::set_allocated_work(::flex::Work* work) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete work_;
  }
  if (work) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(work);
    if (message_arena != submessage_arena) {
      work = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, work, submessage_arena);
    }
    
  } else {
    
  }
  work_ = work;
  // @@protoc_insertion_point(field_set_allocated:flex.SubmitWorkResponse.work)
}

// -------------------------------------------------------------------

// UpdateWorkRequest

// string job_id = 1;
inline void UpdateWorkRequest::clear_job_id() {
  job_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateWorkRequest::job_id() const {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkRequest.job_id)
  return _internal_job_id();
}
inline void UpdateWorkRequest::set_job_id(const std::string& value) {
  _internal_set_job_id(value);
  // @@protoc_insertion_point(field_set:flex.UpdateWorkRequest.job_id)
}
inline std::string* UpdateWorkRequest::mutable_job_id() {
  // @@protoc_insertion_point(field_mutable:flex.UpdateWorkRequest.job_id)
  return _internal_mutable_job_id();
}
inline const std::string& UpdateWorkRequest::_internal_job_id() const {
  return job_id_.Get();
}
inline void UpdateWorkRequest::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateWorkRequest::set_job_id(std::string&& value) {
  
  job_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.UpdateWorkRequest.job_id)
}
inline void UpdateWorkRequest::set_job_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.UpdateWorkRequest.job_id)
}
inline void UpdateWorkRequest::set_job_id(const char* value,
    size_t size) {
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.UpdateWorkRequest.job_id)
}
inline std::string* UpdateWorkRequest::_internal_mutable_job_id() {
  
  return job_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateWorkRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:flex.UpdateWorkRequest.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateWorkRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateWorkRequest.job_id)
}
inline std::string* UpdateWorkRequest::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.UpdateWorkRequest.job_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return job_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdateWorkRequest::unsafe_arena_set_allocated_job_id(
    std::string* job_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      job_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateWorkRequest.job_id)
}

// string request_id = 2;
inline void UpdateWorkRequest::clear_request_id() {
  request_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateWorkRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkRequest.request_id)
  return _internal_request_id();
}
inline void UpdateWorkRequest::set_request_id(const std::string& value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:flex.UpdateWorkRequest.request_id)
}
inline std::string* UpdateWorkRequest::mutable_request_id() {
  // @@protoc_insertion_point(field_mutable:flex.UpdateWorkRequest.request_id)
  return _internal_mutable_request_id();
}
inline const std::string& UpdateWorkRequest::_internal_request_id() const {
  return request_id_.Get();
}
inline void UpdateWorkRequest::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateWorkRequest::set_request_id(std::string&& value) {
  
  request_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.UpdateWorkRequest.request_id)
}
inline void UpdateWorkRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.UpdateWorkRequest.request_id)
}
inline void UpdateWorkRequest::set_request_id(const char* value,
    size_t size) {
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.UpdateWorkRequest.request_id)
}
inline std::string* UpdateWorkRequest::_internal_mutable_request_id() {
  
  return request_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateWorkRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flex.UpdateWorkRequest.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateWorkRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateWorkRequest.request_id)
}
inline std::string* UpdateWorkRequest::unsafe_arena_release_request_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.UpdateWorkRequest.request_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return request_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdateWorkRequest::unsafe_arena_set_allocated_request_id(
    std::string* request_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      request_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateWorkRequest.request_id)
}

// .flex.UpdateWorkRequest.NewState new_state = 3;
inline void UpdateWorkRequest::clear_new_state() {
  new_state_ = 0;
}
inline ::flex::UpdateWorkRequest_NewState UpdateWorkRequest::_internal_new_state() const {
  return static_cast< ::flex::UpdateWorkRequest_NewState >(new_state_);
}
inline ::flex::UpdateWorkRequest_NewState UpdateWorkRequest::new_state() const {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkRequest.new_state)
  return _internal_new_state();
}
inline void UpdateWorkRequest::_internal_set_new_state(::flex::UpdateWorkRequest_NewState value) {
  
  new_state_ = value;
}
inline void UpdateWorkRequest::set_new_state(::flex::UpdateWorkRequest_NewState value) {
  _internal_set_new_state(value);
  // @@protoc_insertion_point(field_set:flex.UpdateWorkRequest.new_state)
}

// -------------------------------------------------------------------

// UpdateWorkResponse

// .flex.Work work = 1;
inline bool UpdateWorkResponse::_internal_has_work() const {
  return this != internal_default_instance() && work_ != nullptr;
}
inline bool UpdateWorkResponse::has_work() const {
  return _internal_has_work();
}
inline void UpdateWorkResponse::clear_work() {
  if (GetArena() == nullptr && work_ != nullptr) {
    delete work_;
  }
  work_ = nullptr;
}
inline const ::flex::Work& UpdateWorkResponse::_internal_work() const {
  const ::flex::Work* p = work_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::Work*>(
      &::flex::_Work_default_instance_);
}
inline const ::flex::Work& UpdateWorkResponse::work() const {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkResponse.work)
  return _internal_work();
}
inline void UpdateWorkResponse::unsafe_arena_set_allocated_work(
    ::flex::Work* work) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(work_);
  }
  work_ = work;
  if (work) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateWorkResponse.work)
}
inline ::flex::Work* UpdateWorkResponse::release_work() {
  auto temp = unsafe_arena_release_work();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::Work* UpdateWorkResponse::unsafe_arena_release_work() {
  // @@protoc_insertion_point(field_release:flex.UpdateWorkResponse.work)
  
  ::flex::Work* temp = work_;
  work_ = nullptr;
  return temp;
}
inline ::flex::Work* UpdateWorkResponse::_internal_mutable_work() {
  
  if (work_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::Work>(GetArena());
    work_ = p;
  }
  return work_;
}
inline ::flex::Work* UpdateWorkResponse::mutable_work() {
  // @@protoc_insertion_point(field_mutable:flex.UpdateWorkResponse.work)
  return _internal_mutable_work();
}
inline void UpdateWorkResponse::set_allocated_work(::flex::Work* work) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete work_;
  }
  if (work) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(work);
    if (message_arena != submessage_arena) {
      work = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, work, submessage_arena);
    }
    
  } else {
    
  }
  work_ = work;
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateWorkResponse.work)
}

// -------------------------------------------------------------------

// BulkUpdateWorkRequest

// .flex.BulkUpdateWorkRequest.NewState new_state = 1;
inline void BulkUpdateWorkRequest::clear_new_state() {
  new_state_ = 0;
}
inline ::flex::BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest::_internal_new_state() const {
  return static_cast< ::flex::BulkUpdateWorkRequest_NewState >(new_state_);
}
inline ::flex::BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest::new_state() const {
  // @@protoc_insertion_point(field_get:flex.BulkUpdateWorkRequest.new_state)
  return _internal_new_state();
}
inline void BulkUpdateWorkRequest::_internal_set_new_state(::flex::BulkUpdateWorkRequest_NewState value) {
  
  new_state_ = value;
}
inline void BulkUpdateWorkRequest::set_new_state(::flex::BulkUpdateWorkRequest_NewState value) {
  _internal_set_new_state(value);
  // @@protoc_insertion_point(field_set:flex.BulkUpdateWorkRequest.new_state)
}

// -------------------------------------------------------------------

// BulkUpdateWorkResponse

// bool success = 1;
inline void BulkUpdateWorkResponse::clear_success() {
  success_ = false;
}
inline bool BulkUpdateWorkResponse::_internal_success() const {
  return success_;
}
inline bool BulkUpdateWorkResponse::success() const {
  // @@protoc_insertion_point(field_get:flex.BulkUpdateWorkResponse.success)
  return _internal_success();
}
inline void BulkUpdateWorkResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void BulkUpdateWorkResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:flex.BulkUpdateWorkResponse.success)
}

// string message = 2;
inline void BulkUpdateWorkResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BulkUpdateWorkResponse::message() const {
  // @@protoc_insertion_point(field_get:flex.BulkUpdateWorkResponse.message)
  return _internal_message();
}
inline void BulkUpdateWorkResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:flex.BulkUpdateWorkResponse.message)
}
inline std::string* BulkUpdateWorkResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:flex.BulkUpdateWorkResponse.message)
  return _internal_mutable_message();
}
inline const std::string& BulkUpdateWorkResponse::_internal_message() const {
  return message_.Get();
}
inline void BulkUpdateWorkResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BulkUpdateWorkResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.BulkUpdateWorkResponse.message)
}
inline void BulkUpdateWorkResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.BulkUpdateWorkResponse.message)
}
inline void BulkUpdateWorkResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.BulkUpdateWorkResponse.message)
}
inline std::string* BulkUpdateWorkResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BulkUpdateWorkResponse::release_message() {
  // @@protoc_insertion_point(field_release:flex.BulkUpdateWorkResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BulkUpdateWorkResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.BulkUpdateWorkResponse.message)
}
inline std::string* BulkUpdateWorkResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.BulkUpdateWorkResponse.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BulkUpdateWorkResponse::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.BulkUpdateWorkResponse.message)
}

// -------------------------------------------------------------------

// WorkRequest_Segment

// int64 offset_start = 1;
inline void WorkRequest_Segment::clear_offset_start() {
  offset_start_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WorkRequest_Segment::_internal_offset_start() const {
  return offset_start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WorkRequest_Segment::offset_start() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.offset_start)
  return _internal_offset_start();
}
inline void WorkRequest_Segment::_internal_set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_start_ = value;
}
inline void WorkRequest_Segment::set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset_start(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.offset_start)
}

// int64 offset_stop = 2;
inline void WorkRequest_Segment::clear_offset_stop() {
  offset_stop_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WorkRequest_Segment::_internal_offset_stop() const {
  return offset_stop_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WorkRequest_Segment::offset_stop() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.offset_stop)
  return _internal_offset_stop();
}
inline void WorkRequest_Segment::_internal_set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_stop_ = value;
}
inline void WorkRequest_Segment::set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset_stop(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.offset_stop)
}

// int32 parts_start = 3;
inline void WorkRequest_Segment::clear_parts_start() {
  parts_start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkRequest_Segment::_internal_parts_start() const {
  return parts_start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkRequest_Segment::parts_start() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.parts_start)
  return _internal_parts_start();
}
inline void WorkRequest_Segment::_internal_set_parts_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  parts_start_ = value;
}
inline void WorkRequest_Segment::set_parts_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_parts_start(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.parts_start)
}

// int32 parts_stop = 4;
inline void WorkRequest_Segment::clear_parts_stop() {
  parts_stop_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkRequest_Segment::_internal_parts_stop() const {
  return parts_stop_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkRequest_Segment::parts_stop() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.parts_stop)
  return _internal_parts_stop();
}
inline void WorkRequest_Segment::_internal_set_parts_stop(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  parts_stop_ = value;
}
inline void WorkRequest_Segment::set_parts_stop(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_parts_stop(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.parts_stop)
}

// -------------------------------------------------------------------

// WorkRequest

// string job_id = 1;
inline void WorkRequest::clear_job_id() {
  job_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkRequest::job_id() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.job_id)
  return _internal_job_id();
}
inline void WorkRequest::set_job_id(const std::string& value) {
  _internal_set_job_id(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.job_id)
}
inline std::string* WorkRequest::mutable_job_id() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.job_id)
  return _internal_mutable_job_id();
}
inline const std::string& WorkRequest::_internal_job_id() const {
  return job_id_.Get();
}
inline void WorkRequest::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkRequest::set_job_id(std::string&& value) {
  
  job_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.WorkRequest.job_id)
}
inline void WorkRequest::set_job_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.WorkRequest.job_id)
}
inline void WorkRequest::set_job_id(const char* value,
    size_t size) {
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.WorkRequest.job_id)
}
inline std::string* WorkRequest::_internal_mutable_job_id() {
  
  return job_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.job_id)
}
inline std::string* WorkRequest::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.job_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return job_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkRequest::unsafe_arena_set_allocated_job_id(
    std::string* job_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      job_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.job_id)
}

// string request_id = 2;
inline void WorkRequest::clear_request_id() {
  request_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkRequest::request_id() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.request_id)
  return _internal_request_id();
}
inline void WorkRequest::set_request_id(const std::string& value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.request_id)
}
inline std::string* WorkRequest::mutable_request_id() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.request_id)
  return _internal_mutable_request_id();
}
inline const std::string& WorkRequest::_internal_request_id() const {
  return request_id_.Get();
}
inline void WorkRequest::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkRequest::set_request_id(std::string&& value) {
  
  request_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.WorkRequest.request_id)
}
inline void WorkRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.WorkRequest.request_id)
}
inline void WorkRequest::set_request_id(const char* value,
    size_t size) {
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.WorkRequest.request_id)
}
inline std::string* WorkRequest::_internal_mutable_request_id() {
  
  return request_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.request_id)
}
inline std::string* WorkRequest::unsafe_arena_release_request_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.request_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return request_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkRequest::unsafe_arena_set_allocated_request_id(
    std::string* request_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      request_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.request_id)
}

// string external_id = 3;
inline void WorkRequest::clear_external_id() {
  external_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkRequest::external_id() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.external_id)
  return _internal_external_id();
}
inline void WorkRequest::set_external_id(const std::string& value) {
  _internal_set_external_id(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.external_id)
}
inline std::string* WorkRequest::mutable_external_id() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.external_id)
  return _internal_mutable_external_id();
}
inline const std::string& WorkRequest::_internal_external_id() const {
  return external_id_.Get();
}
inline void WorkRequest::_internal_set_external_id(const std::string& value) {
  
  external_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkRequest::set_external_id(std::string&& value) {
  
  external_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.WorkRequest.external_id)
}
inline void WorkRequest::set_external_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  external_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.WorkRequest.external_id)
}
inline void WorkRequest::set_external_id(const char* value,
    size_t size) {
  
  external_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.WorkRequest.external_id)
}
inline std::string* WorkRequest::_internal_mutable_external_id() {
  
  return external_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkRequest::release_external_id() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.external_id)
  return external_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkRequest::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    
  } else {
    
  }
  external_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.external_id)
}
inline std::string* WorkRequest::unsafe_arena_release_external_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.external_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return external_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkRequest::unsafe_arena_set_allocated_external_id(
    std::string* external_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (external_id != nullptr) {
    
  } else {
    
  }
  external_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      external_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.external_id)
}

// string path = 4;
inline void WorkRequest::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkRequest::path() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.path)
  return _internal_path();
}
inline void WorkRequest::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.path)
}
inline std::string* WorkRequest::mutable_path() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.path)
  return _internal_mutable_path();
}
inline const std::string& WorkRequest::_internal_path() const {
  return path_.Get();
}
inline void WorkRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkRequest::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.WorkRequest.path)
}
inline void WorkRequest::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.WorkRequest.path)
}
inline void WorkRequest::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.WorkRequest.path)
}
inline std::string* WorkRequest::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkRequest::release_path() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.path)
}
inline std::string* WorkRequest::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkRequest::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.path)
}

// .flex.WorkRequest.Segment segment = 5;
inline bool WorkRequest::_internal_has_segment() const {
  return this != internal_default_instance() && segment_ != nullptr;
}
inline bool WorkRequest::has_segment() const {
  return _internal_has_segment();
}
inline void WorkRequest::clear_segment() {
  if (GetArena() == nullptr && segment_ != nullptr) {
    delete segment_;
  }
  segment_ = nullptr;
}
inline const ::flex::WorkRequest_Segment& WorkRequest::_internal_segment() const {
  const ::flex::WorkRequest_Segment* p = segment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::WorkRequest_Segment*>(
      &::flex::_WorkRequest_Segment_default_instance_);
}
inline const ::flex::WorkRequest_Segment& WorkRequest::segment() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.segment)
  return _internal_segment();
}
inline void WorkRequest::unsafe_arena_set_allocated_segment(
    ::flex::WorkRequest_Segment* segment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segment_);
  }
  segment_ = segment;
  if (segment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.segment)
}
inline ::flex::WorkRequest_Segment* WorkRequest::release_segment() {
  auto temp = unsafe_arena_release_segment();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::WorkRequest_Segment* WorkRequest::unsafe_arena_release_segment() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.segment)
  
  ::flex::WorkRequest_Segment* temp = segment_;
  segment_ = nullptr;
  return temp;
}
inline ::flex::WorkRequest_Segment* WorkRequest::_internal_mutable_segment() {
  
  if (segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::WorkRequest_Segment>(GetArena());
    segment_ = p;
  }
  return segment_;
}
inline ::flex::WorkRequest_Segment* WorkRequest::mutable_segment() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.segment)
  return _internal_mutable_segment();
}
inline void WorkRequest::set_allocated_segment(::flex::WorkRequest_Segment* segment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete segment_;
  }
  if (segment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(segment);
    if (message_arena != submessage_arena) {
      segment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segment, submessage_arena);
    }
    
  } else {
    
  }
  segment_ = segment;
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.segment)
}

// string remote_storage_target = 6;
inline void WorkRequest::clear_remote_storage_target() {
  remote_storage_target_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WorkRequest::remote_storage_target() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.remote_storage_target)
  return _internal_remote_storage_target();
}
inline void WorkRequest::set_remote_storage_target(const std::string& value) {
  _internal_set_remote_storage_target(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.remote_storage_target)
}
inline std::string* WorkRequest::mutable_remote_storage_target() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.remote_storage_target)
  return _internal_mutable_remote_storage_target();
}
inline const std::string& WorkRequest::_internal_remote_storage_target() const {
  return remote_storage_target_.Get();
}
inline void WorkRequest::_internal_set_remote_storage_target(const std::string& value) {
  
  remote_storage_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkRequest::set_remote_storage_target(std::string&& value) {
  
  remote_storage_target_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.WorkRequest.remote_storage_target)
}
inline void WorkRequest::set_remote_storage_target(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  remote_storage_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.WorkRequest.remote_storage_target)
}
inline void WorkRequest::set_remote_storage_target(const char* value,
    size_t size) {
  
  remote_storage_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.WorkRequest.remote_storage_target)
}
inline std::string* WorkRequest::_internal_mutable_remote_storage_target() {
  
  return remote_storage_target_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkRequest::release_remote_storage_target() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.remote_storage_target)
  return remote_storage_target_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkRequest::set_allocated_remote_storage_target(std::string* remote_storage_target) {
  if (remote_storage_target != nullptr) {
    
  } else {
    
  }
  remote_storage_target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_storage_target,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.remote_storage_target)
}
inline std::string* WorkRequest::unsafe_arena_release_remote_storage_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.remote_storage_target)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return remote_storage_target_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void WorkRequest::unsafe_arena_set_allocated_remote_storage_target(
    std::string* remote_storage_target) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (remote_storage_target != nullptr) {
    
  } else {
    
  }
  remote_storage_target_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      remote_storage_target, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.remote_storage_target)
}

// .flex.MockJob mock = 10;
inline bool WorkRequest::_internal_has_mock() const {
  return Type_case() == kMock;
}
inline bool WorkRequest::has_mock() const {
  return _internal_has_mock();
}
inline void WorkRequest::set_has_mock() {
  _oneof_case_[0] = kMock;
}
inline void WorkRequest::clear_mock() {
  if (_internal_has_mock()) {
    if (GetArena() == nullptr) {
      delete Type_.mock_;
    }
    clear_has_Type();
  }
}
inline ::flex::MockJob* WorkRequest::release_mock() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.mock)
  if (_internal_has_mock()) {
    clear_has_Type();
      ::flex::MockJob* temp = Type_.mock_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.mock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::MockJob& WorkRequest::_internal_mock() const {
  return _internal_has_mock()
      ? *Type_.mock_
      : *reinterpret_cast< ::flex::MockJob*>(&::flex::_MockJob_default_instance_);
}
inline const ::flex::MockJob& WorkRequest::mock() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.mock)
  return _internal_mock();
}
inline ::flex::MockJob* WorkRequest::unsafe_arena_release_mock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.mock)
  if (_internal_has_mock()) {
    clear_has_Type();
    ::flex::MockJob* temp = Type_.mock_;
    Type_.mock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkRequest::unsafe_arena_set_allocated_mock(::flex::MockJob* mock) {
  clear_Type();
  if (mock) {
    set_has_mock();
    Type_.mock_ = mock;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.mock)
}
inline ::flex::MockJob* WorkRequest::_internal_mutable_mock() {
  if (!_internal_has_mock()) {
    clear_Type();
    set_has_mock();
    Type_.mock_ = CreateMaybeMessage< ::flex::MockJob >(GetArena());
  }
  return Type_.mock_;
}
inline ::flex::MockJob* WorkRequest::mutable_mock() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.mock)
  return _internal_mutable_mock();
}

// .flex.SyncJob sync = 11;
inline bool WorkRequest::_internal_has_sync() const {
  return Type_case() == kSync;
}
inline bool WorkRequest::has_sync() const {
  return _internal_has_sync();
}
inline void WorkRequest::set_has_sync() {
  _oneof_case_[0] = kSync;
}
inline void WorkRequest::clear_sync() {
  if (_internal_has_sync()) {
    if (GetArena() == nullptr) {
      delete Type_.sync_;
    }
    clear_has_Type();
  }
}
inline ::flex::SyncJob* WorkRequest::release_sync() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.sync)
  if (_internal_has_sync()) {
    clear_has_Type();
      ::flex::SyncJob* temp = Type_.sync_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::SyncJob& WorkRequest::_internal_sync() const {
  return _internal_has_sync()
      ? *Type_.sync_
      : *reinterpret_cast< ::flex::SyncJob*>(&::flex::_SyncJob_default_instance_);
}
inline const ::flex::SyncJob& WorkRequest::sync() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.sync)
  return _internal_sync();
}
inline ::flex::SyncJob* WorkRequest::unsafe_arena_release_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.sync)
  if (_internal_has_sync()) {
    clear_has_Type();
    ::flex::SyncJob* temp = Type_.sync_;
    Type_.sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkRequest::unsafe_arena_set_allocated_sync(::flex::SyncJob* sync) {
  clear_Type();
  if (sync) {
    set_has_sync();
    Type_.sync_ = sync;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.sync)
}
inline ::flex::SyncJob* WorkRequest::_internal_mutable_sync() {
  if (!_internal_has_sync()) {
    clear_Type();
    set_has_sync();
    Type_.sync_ = CreateMaybeMessage< ::flex::SyncJob >(GetArena());
  }
  return Type_.sync_;
}
inline ::flex::SyncJob* WorkRequest::mutable_sync() {
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.sync)
  return _internal_mutable_sync();
}

inline bool WorkRequest::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void WorkRequest::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline WorkRequest::TypeCase WorkRequest::Type_case() const {
  return WorkRequest::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MockJob

// int32 num_test_segments = 1;
inline void MockJob::clear_num_test_segments() {
  num_test_segments_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MockJob::_internal_num_test_segments() const {
  return num_test_segments_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MockJob::num_test_segments() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.num_test_segments)
  return _internal_num_test_segments();
}
inline void MockJob::_internal_set_num_test_segments(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_test_segments_ = value;
}
inline void MockJob::set_num_test_segments(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_test_segments(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.num_test_segments)
}

// int64 file_size = 2;
inline void MockJob::clear_file_size() {
  file_size_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MockJob::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MockJob::file_size() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.file_size)
  return _internal_file_size();
}
inline void MockJob::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  file_size_ = value;
}
inline void MockJob::set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.file_size)
}

// string external_id = 3;
inline void MockJob::clear_external_id() {
  external_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MockJob::external_id() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.external_id)
  return _internal_external_id();
}
inline void MockJob::set_external_id(const std::string& value) {
  _internal_set_external_id(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.external_id)
}
inline std::string* MockJob::mutable_external_id() {
  // @@protoc_insertion_point(field_mutable:flex.MockJob.external_id)
  return _internal_mutable_external_id();
}
inline const std::string& MockJob::_internal_external_id() const {
  return external_id_.Get();
}
inline void MockJob::_internal_set_external_id(const std::string& value) {
  
  external_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MockJob::set_external_id(std::string&& value) {
  
  external_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.MockJob.external_id)
}
inline void MockJob::set_external_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  external_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.MockJob.external_id)
}
inline void MockJob::set_external_id(const char* value,
    size_t size) {
  
  external_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.MockJob.external_id)
}
inline std::string* MockJob::_internal_mutable_external_id() {
  
  return external_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MockJob::release_external_id() {
  // @@protoc_insertion_point(field_release:flex.MockJob.external_id)
  return external_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MockJob::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    
  } else {
    
  }
  external_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.MockJob.external_id)
}
inline std::string* MockJob::unsafe_arena_release_external_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.MockJob.external_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return external_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MockJob::unsafe_arena_set_allocated_external_id(
    std::string* external_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (external_id != nullptr) {
    
  } else {
    
  }
  external_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      external_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.MockJob.external_id)
}

// bool should_fail = 4;
inline void MockJob::clear_should_fail() {
  should_fail_ = false;
}
inline bool MockJob::_internal_should_fail() const {
  return should_fail_;
}
inline bool MockJob::should_fail() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.should_fail)
  return _internal_should_fail();
}
inline void MockJob::_internal_set_should_fail(bool value) {
  
  should_fail_ = value;
}
inline void MockJob::set_should_fail(bool value) {
  _internal_set_should_fail(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.should_fail)
}

// bool can_retry = 5;
inline void MockJob::clear_can_retry() {
  can_retry_ = false;
}
inline bool MockJob::_internal_can_retry() const {
  return can_retry_;
}
inline bool MockJob::can_retry() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.can_retry)
  return _internal_can_retry();
}
inline void MockJob::_internal_set_can_retry(bool value) {
  
  can_retry_ = value;
}
inline void MockJob::set_can_retry(bool value) {
  _internal_set_can_retry(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.can_retry)
}

// -------------------------------------------------------------------

// SyncJob

// .flex.SyncJob.Operation operation = 1;
inline void SyncJob::clear_operation() {
  operation_ = 0;
}
inline ::flex::SyncJob_Operation SyncJob::_internal_operation() const {
  return static_cast< ::flex::SyncJob_Operation >(operation_);
}
inline ::flex::SyncJob_Operation SyncJob::operation() const {
  // @@protoc_insertion_point(field_get:flex.SyncJob.operation)
  return _internal_operation();
}
inline void SyncJob::_internal_set_operation(::flex::SyncJob_Operation value) {
  
  operation_ = value;
}
inline void SyncJob::set_operation(::flex::SyncJob_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:flex.SyncJob.operation)
}

// bool overwrite = 2;
inline void SyncJob::clear_overwrite() {
  overwrite_ = false;
}
inline bool SyncJob::_internal_overwrite() const {
  return overwrite_;
}
inline bool SyncJob::overwrite() const {
  // @@protoc_insertion_point(field_get:flex.SyncJob.overwrite)
  return _internal_overwrite();
}
inline void SyncJob::_internal_set_overwrite(bool value) {
  
  overwrite_ = value;
}
inline void SyncJob::set_overwrite(bool value) {
  _internal_set_overwrite(value);
  // @@protoc_insertion_point(field_set:flex.SyncJob.overwrite)
}

// string remote_path = 3;
inline void SyncJob::clear_remote_path() {
  remote_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SyncJob::remote_path() const {
  // @@protoc_insertion_point(field_get:flex.SyncJob.remote_path)
  return _internal_remote_path();
}
inline void SyncJob::set_remote_path(const std::string& value) {
  _internal_set_remote_path(value);
  // @@protoc_insertion_point(field_set:flex.SyncJob.remote_path)
}
inline std::string* SyncJob::mutable_remote_path() {
  // @@protoc_insertion_point(field_mutable:flex.SyncJob.remote_path)
  return _internal_mutable_remote_path();
}
inline const std::string& SyncJob::_internal_remote_path() const {
  return remote_path_.Get();
}
inline void SyncJob::_internal_set_remote_path(const std::string& value) {
  
  remote_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SyncJob::set_remote_path(std::string&& value) {
  
  remote_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.SyncJob.remote_path)
}
inline void SyncJob::set_remote_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  remote_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.SyncJob.remote_path)
}
inline void SyncJob::set_remote_path(const char* value,
    size_t size) {
  
  remote_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.SyncJob.remote_path)
}
inline std::string* SyncJob::_internal_mutable_remote_path() {
  
  return remote_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SyncJob::release_remote_path() {
  // @@protoc_insertion_point(field_release:flex.SyncJob.remote_path)
  return remote_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SyncJob::set_allocated_remote_path(std::string* remote_path) {
  if (remote_path != nullptr) {
    
  } else {
    
  }
  remote_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.SyncJob.remote_path)
}
inline std::string* SyncJob::unsafe_arena_release_remote_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.SyncJob.remote_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return remote_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SyncJob::unsafe_arena_set_allocated_remote_path(
    std::string* remote_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (remote_path != nullptr) {
    
  } else {
    
  }
  remote_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      remote_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.SyncJob.remote_path)
}

// -------------------------------------------------------------------

// Work_Status

// .flex.Work.State state = 1;
inline void Work_Status::clear_state() {
  state_ = 0;
}
inline ::flex::Work_State Work_Status::_internal_state() const {
  return static_cast< ::flex::Work_State >(state_);
}
inline ::flex::Work_State Work_Status::state() const {
  // @@protoc_insertion_point(field_get:flex.Work.Status.state)
  return _internal_state();
}
inline void Work_Status::_internal_set_state(::flex::Work_State value) {
  
  state_ = value;
}
inline void Work_Status::set_state(::flex::Work_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:flex.Work.Status.state)
}

// string message = 2;
inline void Work_Status::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Work_Status::message() const {
  // @@protoc_insertion_point(field_get:flex.Work.Status.message)
  return _internal_message();
}
inline void Work_Status::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:flex.Work.Status.message)
}
inline std::string* Work_Status::mutable_message() {
  // @@protoc_insertion_point(field_mutable:flex.Work.Status.message)
  return _internal_mutable_message();
}
inline const std::string& Work_Status::_internal_message() const {
  return message_.Get();
}
inline void Work_Status::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Work_Status::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.Work.Status.message)
}
inline void Work_Status::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.Work.Status.message)
}
inline void Work_Status::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.Work.Status.message)
}
inline std::string* Work_Status::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Work_Status::release_message() {
  // @@protoc_insertion_point(field_release:flex.Work.Status.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Work_Status::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.Work.Status.message)
}
inline std::string* Work_Status::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.Work.Status.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Work_Status::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.Status.message)
}

// -------------------------------------------------------------------

// Work_Part

// int32 part_number = 1;
inline void Work_Part::clear_part_number() {
  part_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Work_Part::_internal_part_number() const {
  return part_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Work_Part::part_number() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.part_number)
  return _internal_part_number();
}
inline void Work_Part::_internal_set_part_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  part_number_ = value;
}
inline void Work_Part::set_part_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_part_number(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.part_number)
}

// int64 offset_start = 2;
inline void Work_Part::clear_offset_start() {
  offset_start_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Work_Part::_internal_offset_start() const {
  return offset_start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Work_Part::offset_start() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.offset_start)
  return _internal_offset_start();
}
inline void Work_Part::_internal_set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_start_ = value;
}
inline void Work_Part::set_offset_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset_start(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.offset_start)
}

// int64 offset_stop = 3;
inline void Work_Part::clear_offset_stop() {
  offset_stop_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Work_Part::_internal_offset_stop() const {
  return offset_stop_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Work_Part::offset_stop() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.offset_stop)
  return _internal_offset_stop();
}
inline void Work_Part::_internal_set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_stop_ = value;
}
inline void Work_Part::set_offset_stop(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset_stop(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.offset_stop)
}

// string entity_tag = 4;
inline void Work_Part::clear_entity_tag() {
  entity_tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Work_Part::entity_tag() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.entity_tag)
  return _internal_entity_tag();
}
inline void Work_Part::set_entity_tag(const std::string& value) {
  _internal_set_entity_tag(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.entity_tag)
}
inline std::string* Work_Part::mutable_entity_tag() {
  // @@protoc_insertion_point(field_mutable:flex.Work.Part.entity_tag)
  return _internal_mutable_entity_tag();
}
inline const std::string& Work_Part::_internal_entity_tag() const {
  return entity_tag_.Get();
}
inline void Work_Part::_internal_set_entity_tag(const std::string& value) {
  
  entity_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Work_Part::set_entity_tag(std::string&& value) {
  
  entity_tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.Work.Part.entity_tag)
}
inline void Work_Part::set_entity_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.Work.Part.entity_tag)
}
inline void Work_Part::set_entity_tag(const char* value,
    size_t size) {
  
  entity_tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.Work.Part.entity_tag)
}
inline std::string* Work_Part::_internal_mutable_entity_tag() {
  
  return entity_tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Work_Part::release_entity_tag() {
  // @@protoc_insertion_point(field_release:flex.Work.Part.entity_tag)
  return entity_tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Work_Part::set_allocated_entity_tag(std::string* entity_tag) {
  if (entity_tag != nullptr) {
    
  } else {
    
  }
  entity_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.Work.Part.entity_tag)
}
inline std::string* Work_Part::unsafe_arena_release_entity_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.Work.Part.entity_tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return entity_tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Work_Part::unsafe_arena_set_allocated_entity_tag(
    std::string* entity_tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (entity_tag != nullptr) {
    
  } else {
    
  }
  entity_tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      entity_tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.Part.entity_tag)
}

// string checksum_sha256 = 5;
inline void Work_Part::clear_checksum_sha256() {
  checksum_sha256_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Work_Part::checksum_sha256() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.checksum_sha256)
  return _internal_checksum_sha256();
}
inline void Work_Part::set_checksum_sha256(const std::string& value) {
  _internal_set_checksum_sha256(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.checksum_sha256)
}
inline std::string* Work_Part::mutable_checksum_sha256() {
  // @@protoc_insertion_point(field_mutable:flex.Work.Part.checksum_sha256)
  return _internal_mutable_checksum_sha256();
}
inline const std::string& Work_Part::_internal_checksum_sha256() const {
  return checksum_sha256_.Get();
}
inline void Work_Part::_internal_set_checksum_sha256(const std::string& value) {
  
  checksum_sha256_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Work_Part::set_checksum_sha256(std::string&& value) {
  
  checksum_sha256_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.Work.Part.checksum_sha256)
}
inline void Work_Part::set_checksum_sha256(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  checksum_sha256_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.Work.Part.checksum_sha256)
}
inline void Work_Part::set_checksum_sha256(const char* value,
    size_t size) {
  
  checksum_sha256_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.Work.Part.checksum_sha256)
}
inline std::string* Work_Part::_internal_mutable_checksum_sha256() {
  
  return checksum_sha256_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Work_Part::release_checksum_sha256() {
  // @@protoc_insertion_point(field_release:flex.Work.Part.checksum_sha256)
  return checksum_sha256_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Work_Part::set_allocated_checksum_sha256(std::string* checksum_sha256) {
  if (checksum_sha256 != nullptr) {
    
  } else {
    
  }
  checksum_sha256_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), checksum_sha256,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.Work.Part.checksum_sha256)
}
inline std::string* Work_Part::unsafe_arena_release_checksum_sha256() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.Work.Part.checksum_sha256)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return checksum_sha256_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Work_Part::unsafe_arena_set_allocated_checksum_sha256(
    std::string* checksum_sha256) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (checksum_sha256 != nullptr) {
    
  } else {
    
  }
  checksum_sha256_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      checksum_sha256, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.Part.checksum_sha256)
}

// bool completed = 6;
inline void Work_Part::clear_completed() {
  completed_ = false;
}
inline bool Work_Part::_internal_completed() const {
  return completed_;
}
inline bool Work_Part::completed() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.completed)
  return _internal_completed();
}
inline void Work_Part::_internal_set_completed(bool value) {
  
  completed_ = value;
}
inline void Work_Part::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.completed)
}

// -------------------------------------------------------------------

// Work

// string path = 1;
inline void Work::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Work::path() const {
  // @@protoc_insertion_point(field_get:flex.Work.path)
  return _internal_path();
}
inline void Work::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:flex.Work.path)
}
inline std::string* Work::mutable_path() {
  // @@protoc_insertion_point(field_mutable:flex.Work.path)
  return _internal_mutable_path();
}
inline const std::string& Work::_internal_path() const {
  return path_.Get();
}
inline void Work::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Work::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.Work.path)
}
inline void Work::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.Work.path)
}
inline void Work::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.Work.path)
}
inline std::string* Work::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Work::release_path() {
  // @@protoc_insertion_point(field_release:flex.Work.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Work::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.Work.path)
}
inline std::string* Work::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.Work.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Work::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.path)
}

// string job_id = 2;
inline void Work::clear_job_id() {
  job_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Work::job_id() const {
  // @@protoc_insertion_point(field_get:flex.Work.job_id)
  return _internal_job_id();
}
inline void Work::set_job_id(const std::string& value) {
  _internal_set_job_id(value);
  // @@protoc_insertion_point(field_set:flex.Work.job_id)
}
inline std::string* Work::mutable_job_id() {
  // @@protoc_insertion_point(field_mutable:flex.Work.job_id)
  return _internal_mutable_job_id();
}
inline const std::string& Work::_internal_job_id() const {
  return job_id_.Get();
}
inline void Work::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Work::set_job_id(std::string&& value) {
  
  job_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.Work.job_id)
}
inline void Work::set_job_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.Work.job_id)
}
inline void Work::set_job_id(const char* value,
    size_t size) {
  
  job_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.Work.job_id)
}
inline std::string* Work::_internal_mutable_job_id() {
  
  return job_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Work::release_job_id() {
  // @@protoc_insertion_point(field_release:flex.Work.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Work::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.Work.job_id)
}
inline std::string* Work::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.Work.job_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return job_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Work::unsafe_arena_set_allocated_job_id(
    std::string* job_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      job_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.job_id)
}

// string request_id = 3;
inline void Work::clear_request_id() {
  request_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Work::request_id() const {
  // @@protoc_insertion_point(field_get:flex.Work.request_id)
  return _internal_request_id();
}
inline void Work::set_request_id(const std::string& value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:flex.Work.request_id)
}
inline std::string* Work::mutable_request_id() {
  // @@protoc_insertion_point(field_mutable:flex.Work.request_id)
  return _internal_mutable_request_id();
}
inline const std::string& Work::_internal_request_id() const {
  return request_id_.Get();
}
inline void Work::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Work::set_request_id(std::string&& value) {
  
  request_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.Work.request_id)
}
inline void Work::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.Work.request_id)
}
inline void Work::set_request_id(const char* value,
    size_t size) {
  
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.Work.request_id)
}
inline std::string* Work::_internal_mutable_request_id() {
  
  return request_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Work::release_request_id() {
  // @@protoc_insertion_point(field_release:flex.Work.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Work::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.Work.request_id)
}
inline std::string* Work::unsafe_arena_release_request_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.Work.request_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return request_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Work::unsafe_arena_set_allocated_request_id(
    std::string* request_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      request_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.request_id)
}

// .flex.Work.Status status = 4;
inline bool Work::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Work::has_status() const {
  return _internal_has_status();
}
inline void Work::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::flex::Work_Status& Work::_internal_status() const {
  const ::flex::Work_Status* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::Work_Status*>(
      &::flex::_Work_Status_default_instance_);
}
inline const ::flex::Work_Status& Work::status() const {
  // @@protoc_insertion_point(field_get:flex.Work.status)
  return _internal_status();
}
inline void Work::unsafe_arena_set_allocated_status(
    ::flex::Work_Status* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.status)
}
inline ::flex::Work_Status* Work::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::Work_Status* Work::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:flex.Work.status)
  
  ::flex::Work_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::flex::Work_Status* Work::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::Work_Status>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::flex::Work_Status* Work::mutable_status() {
  // @@protoc_insertion_point(field_mutable:flex.Work.status)
  return _internal_mutable_status();
}
inline void Work::set_allocated_status(::flex::Work_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:flex.Work.status)
}

// repeated .flex.Work.Part parts = 5;
inline int Work::_internal_parts_size() const {
  return parts_.size();
}
inline int Work::parts_size() const {
  return _internal_parts_size();
}
inline void Work::clear_parts() {
  parts_.Clear();
}
inline ::flex::Work_Part* Work::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:flex.Work.parts)
  return parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::Work_Part >*
Work::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:flex.Work.parts)
  return &parts_;
}
inline const ::flex::Work_Part& Work::_internal_parts(int index) const {
  return parts_.Get(index);
}
inline const ::flex::Work_Part& Work::parts(int index) const {
  // @@protoc_insertion_point(field_get:flex.Work.parts)
  return _internal_parts(index);
}
inline ::flex::Work_Part* Work::_internal_add_parts() {
  return parts_.Add();
}
inline ::flex::Work_Part* Work::add_parts() {
  // @@protoc_insertion_point(field_add:flex.Work.parts)
  return _internal_add_parts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::Work_Part >&
Work::parts() const {
  // @@protoc_insertion_point(field_list:flex.Work.parts)
  return parts_;
}

// -------------------------------------------------------------------

// UpdateConfigRequest

// .flex.BeeRemoteNode bee_remote = 1;
inline bool UpdateConfigRequest::_internal_has_bee_remote() const {
  return this != internal_default_instance() && bee_remote_ != nullptr;
}
inline bool UpdateConfigRequest::has_bee_remote() const {
  return _internal_has_bee_remote();
}
inline void UpdateConfigRequest::clear_bee_remote() {
  if (GetArena() == nullptr && bee_remote_ != nullptr) {
    delete bee_remote_;
  }
  bee_remote_ = nullptr;
}
inline const ::flex::BeeRemoteNode& UpdateConfigRequest::_internal_bee_remote() const {
  const ::flex::BeeRemoteNode* p = bee_remote_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::BeeRemoteNode*>(
      &::flex::_BeeRemoteNode_default_instance_);
}
inline const ::flex::BeeRemoteNode& UpdateConfigRequest::bee_remote() const {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigRequest.bee_remote)
  return _internal_bee_remote();
}
inline void UpdateConfigRequest::unsafe_arena_set_allocated_bee_remote(
    ::flex::BeeRemoteNode* bee_remote) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bee_remote_);
  }
  bee_remote_ = bee_remote;
  if (bee_remote) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateConfigRequest.bee_remote)
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::release_bee_remote() {
  auto temp = unsafe_arena_release_bee_remote();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::unsafe_arena_release_bee_remote() {
  // @@protoc_insertion_point(field_release:flex.UpdateConfigRequest.bee_remote)
  
  ::flex::BeeRemoteNode* temp = bee_remote_;
  bee_remote_ = nullptr;
  return temp;
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::_internal_mutable_bee_remote() {
  
  if (bee_remote_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::BeeRemoteNode>(GetArena());
    bee_remote_ = p;
  }
  return bee_remote_;
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::mutable_bee_remote() {
  // @@protoc_insertion_point(field_mutable:flex.UpdateConfigRequest.bee_remote)
  return _internal_mutable_bee_remote();
}
inline void UpdateConfigRequest::set_allocated_bee_remote(::flex::BeeRemoteNode* bee_remote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bee_remote_;
  }
  if (bee_remote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bee_remote);
    if (message_arena != submessage_arena) {
      bee_remote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bee_remote, submessage_arena);
    }
    
  } else {
    
  }
  bee_remote_ = bee_remote;
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateConfigRequest.bee_remote)
}

// repeated .flex.RemoteStorageTarget rsts = 2;
inline int UpdateConfigRequest::_internal_rsts_size() const {
  return rsts_.size();
}
inline int UpdateConfigRequest::rsts_size() const {
  return _internal_rsts_size();
}
inline void UpdateConfigRequest::clear_rsts() {
  rsts_.Clear();
}
inline ::flex::RemoteStorageTarget* UpdateConfigRequest::mutable_rsts(int index) {
  // @@protoc_insertion_point(field_mutable:flex.UpdateConfigRequest.rsts)
  return rsts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::RemoteStorageTarget >*
UpdateConfigRequest::mutable_rsts() {
  // @@protoc_insertion_point(field_mutable_list:flex.UpdateConfigRequest.rsts)
  return &rsts_;
}
inline const ::flex::RemoteStorageTarget& UpdateConfigRequest::_internal_rsts(int index) const {
  return rsts_.Get(index);
}
inline const ::flex::RemoteStorageTarget& UpdateConfigRequest::rsts(int index) const {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigRequest.rsts)
  return _internal_rsts(index);
}
inline ::flex::RemoteStorageTarget* UpdateConfigRequest::_internal_add_rsts() {
  return rsts_.Add();
}
inline ::flex::RemoteStorageTarget* UpdateConfigRequest::add_rsts() {
  // @@protoc_insertion_point(field_add:flex.UpdateConfigRequest.rsts)
  return _internal_add_rsts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flex::RemoteStorageTarget >&
UpdateConfigRequest::rsts() const {
  // @@protoc_insertion_point(field_list:flex.UpdateConfigRequest.rsts)
  return rsts_;
}

// -------------------------------------------------------------------

// UpdateConfigResponse

// .flex.UpdateConfigResponse.Result result = 1;
inline void UpdateConfigResponse::clear_result() {
  result_ = 0;
}
inline ::flex::UpdateConfigResponse_Result UpdateConfigResponse::_internal_result() const {
  return static_cast< ::flex::UpdateConfigResponse_Result >(result_);
}
inline ::flex::UpdateConfigResponse_Result UpdateConfigResponse::result() const {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigResponse.result)
  return _internal_result();
}
inline void UpdateConfigResponse::_internal_set_result(::flex::UpdateConfigResponse_Result value) {
  
  result_ = value;
}
inline void UpdateConfigResponse::set_result(::flex::UpdateConfigResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:flex.UpdateConfigResponse.result)
}

// string message = 2;
inline void UpdateConfigResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateConfigResponse::message() const {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigResponse.message)
  return _internal_message();
}
inline void UpdateConfigResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:flex.UpdateConfigResponse.message)
}
inline std::string* UpdateConfigResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:flex.UpdateConfigResponse.message)
  return _internal_mutable_message();
}
inline const std::string& UpdateConfigResponse::_internal_message() const {
  return message_.Get();
}
inline void UpdateConfigResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateConfigResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.UpdateConfigResponse.message)
}
inline void UpdateConfigResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.UpdateConfigResponse.message)
}
inline void UpdateConfigResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.UpdateConfigResponse.message)
}
inline std::string* UpdateConfigResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateConfigResponse::release_message() {
  // @@protoc_insertion_point(field_release:flex.UpdateConfigResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateConfigResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateConfigResponse.message)
}
inline std::string* UpdateConfigResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.UpdateConfigResponse.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdateConfigResponse::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateConfigResponse.message)
}

// -------------------------------------------------------------------

// BeeRemoteNode

// string id = 1;
inline void BeeRemoteNode::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BeeRemoteNode::id() const {
  // @@protoc_insertion_point(field_get:flex.BeeRemoteNode.id)
  return _internal_id();
}
inline void BeeRemoteNode::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:flex.BeeRemoteNode.id)
}
inline std::string* BeeRemoteNode::mutable_id() {
  // @@protoc_insertion_point(field_mutable:flex.BeeRemoteNode.id)
  return _internal_mutable_id();
}
inline const std::string& BeeRemoteNode::_internal_id() const {
  return id_.Get();
}
inline void BeeRemoteNode::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BeeRemoteNode::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.BeeRemoteNode.id)
}
inline void BeeRemoteNode::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.BeeRemoteNode.id)
}
inline void BeeRemoteNode::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.BeeRemoteNode.id)
}
inline std::string* BeeRemoteNode::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BeeRemoteNode::release_id() {
  // @@protoc_insertion_point(field_release:flex.BeeRemoteNode.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BeeRemoteNode::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.BeeRemoteNode.id)
}
inline std::string* BeeRemoteNode::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.BeeRemoteNode.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BeeRemoteNode::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.BeeRemoteNode.id)
}

// string address = 2;
inline void BeeRemoteNode::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BeeRemoteNode::address() const {
  // @@protoc_insertion_point(field_get:flex.BeeRemoteNode.address)
  return _internal_address();
}
inline void BeeRemoteNode::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:flex.BeeRemoteNode.address)
}
inline std::string* BeeRemoteNode::mutable_address() {
  // @@protoc_insertion_point(field_mutable:flex.BeeRemoteNode.address)
  return _internal_mutable_address();
}
inline const std::string& BeeRemoteNode::_internal_address() const {
  return address_.Get();
}
inline void BeeRemoteNode::_internal_set_address(const std::string& value) {
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BeeRemoteNode::set_address(std::string&& value) {
  
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.BeeRemoteNode.address)
}
inline void BeeRemoteNode::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.BeeRemoteNode.address)
}
inline void BeeRemoteNode::set_address(const char* value,
    size_t size) {
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.BeeRemoteNode.address)
}
inline std::string* BeeRemoteNode::_internal_mutable_address() {
  
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BeeRemoteNode::release_address() {
  // @@protoc_insertion_point(field_release:flex.BeeRemoteNode.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BeeRemoteNode::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.BeeRemoteNode.address)
}
inline std::string* BeeRemoteNode::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.BeeRemoteNode.address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BeeRemoteNode::unsafe_arena_set_allocated_address(
    std::string* address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (address != nullptr) {
    
  } else {
    
  }
  address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.BeeRemoteNode.address)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_Policies

// int64 fast_start_max_size = 1;
inline void RemoteStorageTarget_Policies::clear_fast_start_max_size() {
  fast_start_max_size_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteStorageTarget_Policies::_internal_fast_start_max_size() const {
  return fast_start_max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteStorageTarget_Policies::fast_start_max_size() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.Policies.fast_start_max_size)
  return _internal_fast_start_max_size();
}
inline void RemoteStorageTarget_Policies::_internal_set_fast_start_max_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  fast_start_max_size_ = value;
}
inline void RemoteStorageTarget_Policies::set_fast_start_max_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_fast_start_max_size(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.Policies.fast_start_max_size)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_S3

// string endpoint_url = 1;
inline void RemoteStorageTarget_S3::clear_endpoint_url() {
  endpoint_url_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::endpoint_url() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.endpoint_url)
  return _internal_endpoint_url();
}
inline void RemoteStorageTarget_S3::set_endpoint_url(const std::string& value) {
  _internal_set_endpoint_url(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.endpoint_url)
}
inline std::string* RemoteStorageTarget_S3::mutable_endpoint_url() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.endpoint_url)
  return _internal_mutable_endpoint_url();
}
inline const std::string& RemoteStorageTarget_S3::_internal_endpoint_url() const {
  return endpoint_url_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_endpoint_url(const std::string& value) {
  
  endpoint_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_endpoint_url(std::string&& value) {
  
  endpoint_url_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.S3.endpoint_url)
}
inline void RemoteStorageTarget_S3::set_endpoint_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  endpoint_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.S3.endpoint_url)
}
inline void RemoteStorageTarget_S3::set_endpoint_url(const char* value,
    size_t size) {
  
  endpoint_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.S3.endpoint_url)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_endpoint_url() {
  
  return endpoint_url_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_endpoint_url() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.endpoint_url)
  return endpoint_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_endpoint_url(std::string* endpoint_url) {
  if (endpoint_url != nullptr) {
    
  } else {
    
  }
  endpoint_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.endpoint_url)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_endpoint_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.S3.endpoint_url)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return endpoint_url_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_endpoint_url(
    std::string* endpoint_url) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (endpoint_url != nullptr) {
    
  } else {
    
  }
  endpoint_url_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      endpoint_url, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.S3.endpoint_url)
}

// string partition_id = 2;
inline void RemoteStorageTarget_S3::clear_partition_id() {
  partition_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::partition_id() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.partition_id)
  return _internal_partition_id();
}
inline void RemoteStorageTarget_S3::set_partition_id(const std::string& value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.partition_id)
}
inline std::string* RemoteStorageTarget_S3::mutable_partition_id() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.partition_id)
  return _internal_mutable_partition_id();
}
inline const std::string& RemoteStorageTarget_S3::_internal_partition_id() const {
  return partition_id_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_partition_id(const std::string& value) {
  
  partition_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_partition_id(std::string&& value) {
  
  partition_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.S3.partition_id)
}
inline void RemoteStorageTarget_S3::set_partition_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partition_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.S3.partition_id)
}
inline void RemoteStorageTarget_S3::set_partition_id(const char* value,
    size_t size) {
  
  partition_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.S3.partition_id)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_partition_id() {
  
  return partition_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_partition_id() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.partition_id)
  return partition_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_partition_id(std::string* partition_id) {
  if (partition_id != nullptr) {
    
  } else {
    
  }
  partition_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.partition_id)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_partition_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.S3.partition_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return partition_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_partition_id(
    std::string* partition_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (partition_id != nullptr) {
    
  } else {
    
  }
  partition_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      partition_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.S3.partition_id)
}

// string region = 3;
inline void RemoteStorageTarget_S3::clear_region() {
  region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::region() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.region)
  return _internal_region();
}
inline void RemoteStorageTarget_S3::set_region(const std::string& value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::mutable_region() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.region)
  return _internal_mutable_region();
}
inline const std::string& RemoteStorageTarget_S3::_internal_region() const {
  return region_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_region(const std::string& value) {
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_region(std::string&& value) {
  
  region_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.S3.region)
}
inline void RemoteStorageTarget_S3::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.S3.region)
}
inline void RemoteStorageTarget_S3::set_region(const char* value,
    size_t size) {
  
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_region() {
  
  return region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_region() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.S3.region)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return region_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_region(
    std::string* region) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (region != nullptr) {
    
  } else {
    
  }
  region_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      region, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.S3.region)
}

// string bucket = 4;
inline void RemoteStorageTarget_S3::clear_bucket() {
  bucket_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::bucket() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.bucket)
  return _internal_bucket();
}
inline void RemoteStorageTarget_S3::set_bucket(const std::string& value) {
  _internal_set_bucket(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.bucket)
  return _internal_mutable_bucket();
}
inline const std::string& RemoteStorageTarget_S3::_internal_bucket() const {
  return bucket_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_bucket(const std::string& value) {
  
  bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_bucket(std::string&& value) {
  
  bucket_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.S3.bucket)
}
inline void RemoteStorageTarget_S3::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.S3.bucket)
}
inline void RemoteStorageTarget_S3::set_bucket(const char* value,
    size_t size) {
  
  bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_bucket() {
  
  return bucket_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_bucket() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.bucket)
  return bucket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bucket,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_bucket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.S3.bucket)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return bucket_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_bucket(
    std::string* bucket) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      bucket, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.S3.bucket)
}

// string access_key = 5;
inline void RemoteStorageTarget_S3::clear_access_key() {
  access_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::access_key() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.access_key)
  return _internal_access_key();
}
inline void RemoteStorageTarget_S3::set_access_key(const std::string& value) {
  _internal_set_access_key(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::mutable_access_key() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.access_key)
  return _internal_mutable_access_key();
}
inline const std::string& RemoteStorageTarget_S3::_internal_access_key() const {
  return access_key_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_access_key(const std::string& value) {
  
  access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_access_key(std::string&& value) {
  
  access_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.S3.access_key)
}
inline void RemoteStorageTarget_S3::set_access_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.S3.access_key)
}
inline void RemoteStorageTarget_S3::set_access_key(const char* value,
    size_t size) {
  
  access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_access_key() {
  
  return access_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_access_key() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.access_key)
  return access_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_access_key(std::string* access_key) {
  if (access_key != nullptr) {
    
  } else {
    
  }
  access_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_access_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.S3.access_key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return access_key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_access_key(
    std::string* access_key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (access_key != nullptr) {
    
  } else {
    
  }
  access_key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      access_key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.S3.access_key)
}

// string secret_key = 6;
inline void RemoteStorageTarget_S3::clear_secret_key() {
  secret_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_S3::secret_key() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.secret_key)
  return _internal_secret_key();
}
inline void RemoteStorageTarget_S3::set_secret_key(const std::string& value) {
  _internal_set_secret_key(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::mutable_secret_key() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.secret_key)
  return _internal_mutable_secret_key();
}
inline const std::string& RemoteStorageTarget_S3::_internal_secret_key() const {
  return secret_key_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_secret_key(const std::string& value) {
  
  secret_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_S3::set_secret_key(std::string&& value) {
  
  secret_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.S3.secret_key)
}
inline void RemoteStorageTarget_S3::set_secret_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  secret_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.S3.secret_key)
}
inline void RemoteStorageTarget_S3::set_secret_key(const char* value,
    size_t size) {
  
  secret_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_secret_key() {
  
  return secret_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_secret_key() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.secret_key)
  return secret_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_S3::set_allocated_secret_key(std::string* secret_key) {
  if (secret_key != nullptr) {
    
  } else {
    
  }
  secret_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::unsafe_arena_release_secret_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.S3.secret_key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return secret_key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_S3::unsafe_arena_set_allocated_secret_key(
    std::string* secret_key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (secret_key != nullptr) {
    
  } else {
    
  }
  secret_key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      secret_key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.S3.secret_key)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_Azure

// .flex.RemoteStorageTarget.S3 s3 = 1;
inline bool RemoteStorageTarget_Azure::_internal_has_s3() const {
  return this != internal_default_instance() && s3_ != nullptr;
}
inline bool RemoteStorageTarget_Azure::has_s3() const {
  return _internal_has_s3();
}
inline void RemoteStorageTarget_Azure::clear_s3() {
  if (GetArena() == nullptr && s3_ != nullptr) {
    delete s3_;
  }
  s3_ = nullptr;
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget_Azure::_internal_s3() const {
  const ::flex::RemoteStorageTarget_S3* p = s3_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::RemoteStorageTarget_S3*>(
      &::flex::_RemoteStorageTarget_S3_default_instance_);
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget_Azure::s3() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.Azure.s3)
  return _internal_s3();
}
inline void RemoteStorageTarget_Azure::unsafe_arena_set_allocated_s3(
    ::flex::RemoteStorageTarget_S3* s3) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s3_);
  }
  s3_ = s3;
  if (s3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.Azure.s3)
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::release_s3() {
  auto temp = unsafe_arena_release_s3();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.Azure.s3)
  
  ::flex::RemoteStorageTarget_S3* temp = s3_;
  s3_ = nullptr;
  return temp;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::_internal_mutable_s3() {
  
  if (s3_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::RemoteStorageTarget_S3>(GetArena());
    s3_ = p;
  }
  return s3_;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::mutable_s3() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.Azure.s3)
  return _internal_mutable_s3();
}
inline void RemoteStorageTarget_Azure::set_allocated_s3(::flex::RemoteStorageTarget_S3* s3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete s3_;
  }
  if (s3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(s3);
    if (message_arena != submessage_arena) {
      s3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s3, submessage_arena);
    }
    
  } else {
    
  }
  s3_ = s3;
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.Azure.s3)
}

// string account = 2;
inline void RemoteStorageTarget_Azure::clear_account() {
  account_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_Azure::account() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.Azure.account)
  return _internal_account();
}
inline void RemoteStorageTarget_Azure::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::mutable_account() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.Azure.account)
  return _internal_mutable_account();
}
inline const std::string& RemoteStorageTarget_Azure::_internal_account() const {
  return account_.Get();
}
inline void RemoteStorageTarget_Azure::_internal_set_account(const std::string& value) {
  
  account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_Azure::set_account(std::string&& value) {
  
  account_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.Azure.account)
}
inline void RemoteStorageTarget_Azure::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.Azure.account)
}
inline void RemoteStorageTarget_Azure::set_account(const char* value,
    size_t size) {
  
  account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::_internal_mutable_account() {
  
  return account_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_Azure::release_account() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.Azure.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_Azure::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.Azure.account)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return account_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_Azure::unsafe_arena_set_allocated_account(
    std::string* account) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (account != nullptr) {
    
  } else {
    
  }
  account_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      account, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.Azure.account)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_POSIX

// string path = 1;
inline void RemoteStorageTarget_POSIX::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget_POSIX::path() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.POSIX.path)
  return _internal_path();
}
inline void RemoteStorageTarget_POSIX::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::mutable_path() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.POSIX.path)
  return _internal_mutable_path();
}
inline const std::string& RemoteStorageTarget_POSIX::_internal_path() const {
  return path_.Get();
}
inline void RemoteStorageTarget_POSIX::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget_POSIX::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.POSIX.path)
}
inline void RemoteStorageTarget_POSIX::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.POSIX.path)
}
inline void RemoteStorageTarget_POSIX::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget_POSIX::release_path() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.POSIX.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget_POSIX::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.POSIX.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget_POSIX::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.POSIX.path)
}

// -------------------------------------------------------------------

// RemoteStorageTarget

// string id = 1;
inline void RemoteStorageTarget::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget::id() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.id)
  return _internal_id();
}
inline void RemoteStorageTarget::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.id)
}
inline std::string* RemoteStorageTarget::mutable_id() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.id)
  return _internal_mutable_id();
}
inline const std::string& RemoteStorageTarget::_internal_id() const {
  return id_.Get();
}
inline void RemoteStorageTarget::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.id)
}
inline void RemoteStorageTarget::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.id)
}
inline void RemoteStorageTarget::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.id)
}
inline std::string* RemoteStorageTarget::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget::release_id() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.id)
}
inline std::string* RemoteStorageTarget::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.id)
}

// string name = 2;
inline void RemoteStorageTarget::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteStorageTarget::name() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.name)
  return _internal_name();
}
inline void RemoteStorageTarget::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::mutable_name() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.name)
  return _internal_mutable_name();
}
inline const std::string& RemoteStorageTarget::_internal_name() const {
  return name_.Get();
}
inline void RemoteStorageTarget::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.name)
}
inline void RemoteStorageTarget::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.name)
}
inline void RemoteStorageTarget::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget::release_name() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteStorageTarget::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.name)
}

// .flex.RemoteStorageTarget.Policies policies = 3;
inline bool RemoteStorageTarget::_internal_has_policies() const {
  return this != internal_default_instance() && policies_ != nullptr;
}
inline bool RemoteStorageTarget::has_policies() const {
  return _internal_has_policies();
}
inline void RemoteStorageTarget::clear_policies() {
  if (GetArena() == nullptr && policies_ != nullptr) {
    delete policies_;
  }
  policies_ = nullptr;
}
inline const ::flex::RemoteStorageTarget_Policies& RemoteStorageTarget::_internal_policies() const {
  const ::flex::RemoteStorageTarget_Policies* p = policies_;
  return p != nullptr ? *p : *reinterpret_cast<const ::flex::RemoteStorageTarget_Policies*>(
      &::flex::_RemoteStorageTarget_Policies_default_instance_);
}
inline const ::flex::RemoteStorageTarget_Policies& RemoteStorageTarget::policies() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.policies)
  return _internal_policies();
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_policies(
    ::flex::RemoteStorageTarget_Policies* policies) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(policies_);
  }
  policies_ = policies;
  if (policies) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.policies)
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::release_policies() {
  auto temp = unsafe_arena_release_policies();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::unsafe_arena_release_policies() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.policies)
  
  ::flex::RemoteStorageTarget_Policies* temp = policies_;
  policies_ = nullptr;
  return temp;
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::_internal_mutable_policies() {
  
  if (policies_ == nullptr) {
    auto* p = CreateMaybeMessage<::flex::RemoteStorageTarget_Policies>(GetArena());
    policies_ = p;
  }
  return policies_;
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::mutable_policies() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.policies)
  return _internal_mutable_policies();
}
inline void RemoteStorageTarget::set_allocated_policies(::flex::RemoteStorageTarget_Policies* policies) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete policies_;
  }
  if (policies) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(policies);
    if (message_arena != submessage_arena) {
      policies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policies, submessage_arena);
    }
    
  } else {
    
  }
  policies_ = policies;
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.policies)
}

// .flex.RemoteStorageTarget.S3 s3 = 4;
inline bool RemoteStorageTarget::_internal_has_s3() const {
  return type_case() == kS3;
}
inline bool RemoteStorageTarget::has_s3() const {
  return _internal_has_s3();
}
inline void RemoteStorageTarget::set_has_s3() {
  _oneof_case_[0] = kS3;
}
inline void RemoteStorageTarget::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArena() == nullptr) {
      delete type_.s3_;
    }
    clear_has_type();
  }
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::release_s3() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.s3)
  if (_internal_has_s3()) {
    clear_has_type();
      ::flex::RemoteStorageTarget_S3* temp = type_.s3_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget::_internal_s3() const {
  return _internal_has_s3()
      ? *type_.s3_
      : *reinterpret_cast< ::flex::RemoteStorageTarget_S3*>(&::flex::_RemoteStorageTarget_S3_default_instance_);
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget::s3() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.s3)
  return _internal_s3();
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.s3)
  if (_internal_has_s3()) {
    clear_has_type();
    ::flex::RemoteStorageTarget_S3* temp = type_.s3_;
    type_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_s3(::flex::RemoteStorageTarget_S3* s3) {
  clear_type();
  if (s3) {
    set_has_s3();
    type_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.s3)
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_type();
    set_has_s3();
    type_.s3_ = CreateMaybeMessage< ::flex::RemoteStorageTarget_S3 >(GetArena());
  }
  return type_.s3_;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::mutable_s3() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.s3)
  return _internal_mutable_s3();
}

// .flex.RemoteStorageTarget.POSIX posix = 5;
inline bool RemoteStorageTarget::_internal_has_posix() const {
  return type_case() == kPosix;
}
inline bool RemoteStorageTarget::has_posix() const {
  return _internal_has_posix();
}
inline void RemoteStorageTarget::set_has_posix() {
  _oneof_case_[0] = kPosix;
}
inline void RemoteStorageTarget::clear_posix() {
  if (_internal_has_posix()) {
    if (GetArena() == nullptr) {
      delete type_.posix_;
    }
    clear_has_type();
  }
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::release_posix() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.posix)
  if (_internal_has_posix()) {
    clear_has_type();
      ::flex::RemoteStorageTarget_POSIX* temp = type_.posix_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.posix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::RemoteStorageTarget_POSIX& RemoteStorageTarget::_internal_posix() const {
  return _internal_has_posix()
      ? *type_.posix_
      : *reinterpret_cast< ::flex::RemoteStorageTarget_POSIX*>(&::flex::_RemoteStorageTarget_POSIX_default_instance_);
}
inline const ::flex::RemoteStorageTarget_POSIX& RemoteStorageTarget::posix() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.posix)
  return _internal_posix();
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::unsafe_arena_release_posix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.posix)
  if (_internal_has_posix()) {
    clear_has_type();
    ::flex::RemoteStorageTarget_POSIX* temp = type_.posix_;
    type_.posix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_posix(::flex::RemoteStorageTarget_POSIX* posix) {
  clear_type();
  if (posix) {
    set_has_posix();
    type_.posix_ = posix;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.posix)
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::_internal_mutable_posix() {
  if (!_internal_has_posix()) {
    clear_type();
    set_has_posix();
    type_.posix_ = CreateMaybeMessage< ::flex::RemoteStorageTarget_POSIX >(GetArena());
  }
  return type_.posix_;
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::mutable_posix() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.posix)
  return _internal_mutable_posix();
}

// .flex.RemoteStorageTarget.Azure azure = 6;
inline bool RemoteStorageTarget::_internal_has_azure() const {
  return type_case() == kAzure;
}
inline bool RemoteStorageTarget::has_azure() const {
  return _internal_has_azure();
}
inline void RemoteStorageTarget::set_has_azure() {
  _oneof_case_[0] = kAzure;
}
inline void RemoteStorageTarget::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArena() == nullptr) {
      delete type_.azure_;
    }
    clear_has_type();
  }
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::release_azure() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.azure)
  if (_internal_has_azure()) {
    clear_has_type();
      ::flex::RemoteStorageTarget_Azure* temp = type_.azure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::RemoteStorageTarget_Azure& RemoteStorageTarget::_internal_azure() const {
  return _internal_has_azure()
      ? *type_.azure_
      : *reinterpret_cast< ::flex::RemoteStorageTarget_Azure*>(&::flex::_RemoteStorageTarget_Azure_default_instance_);
}
inline const ::flex::RemoteStorageTarget_Azure& RemoteStorageTarget::azure() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.azure)
  return _internal_azure();
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.azure)
  if (_internal_has_azure()) {
    clear_has_type();
    ::flex::RemoteStorageTarget_Azure* temp = type_.azure_;
    type_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_azure(::flex::RemoteStorageTarget_Azure* azure) {
  clear_type();
  if (azure) {
    set_has_azure();
    type_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.azure)
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_type();
    set_has_azure();
    type_.azure_ = CreateMaybeMessage< ::flex::RemoteStorageTarget_Azure >(GetArena());
  }
  return type_.azure_;
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::mutable_azure() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.azure)
  return _internal_mutable_azure();
}

// string mock = 7;
inline bool RemoteStorageTarget::_internal_has_mock() const {
  return type_case() == kMock;
}
inline void RemoteStorageTarget::set_has_mock() {
  _oneof_case_[0] = kMock;
}
inline void RemoteStorageTarget::clear_mock() {
  if (_internal_has_mock()) {
    type_.mock_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_type();
  }
}
inline const std::string& RemoteStorageTarget::mock() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.mock)
  return _internal_mock();
}
inline void RemoteStorageTarget::set_mock(const std::string& value) {
  _internal_set_mock(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.mock)
}
inline std::string* RemoteStorageTarget::mutable_mock() {
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.mock)
  return _internal_mutable_mock();
}
inline const std::string& RemoteStorageTarget::_internal_mock() const {
  if (_internal_has_mock()) {
    return type_.mock_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RemoteStorageTarget::_internal_set_mock(const std::string& value) {
  if (!_internal_has_mock()) {
    clear_type();
    set_has_mock();
    type_.mock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.mock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteStorageTarget::set_mock(std::string&& value) {
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.mock)
  if (!_internal_has_mock()) {
    clear_type();
    set_has_mock();
    type_.mock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.mock_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:flex.RemoteStorageTarget.mock)
}
inline void RemoteStorageTarget::set_mock(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_mock()) {
    clear_type();
    set_has_mock();
    type_.mock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.mock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:flex.RemoteStorageTarget.mock)
}
inline void RemoteStorageTarget::set_mock(const char* value,
                             size_t size) {
  if (!_internal_has_mock()) {
    clear_type();
    set_has_mock();
    type_.mock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.mock_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:flex.RemoteStorageTarget.mock)
}
inline std::string* RemoteStorageTarget::_internal_mutable_mock() {
  if (!_internal_has_mock()) {
    clear_type();
    set_has_mock();
    type_.mock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return type_.mock_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteStorageTarget::release_mock() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.mock)
  if (_internal_has_mock()) {
    clear_has_type();
    return type_.mock_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::set_allocated_mock(std::string* mock) {
  if (has_type()) {
    clear_type();
  }
  if (mock != nullptr) {
    set_has_mock();
    type_.mock_.UnsafeSetDefault(mock);
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.mock)
}
inline std::string* RemoteStorageTarget::unsafe_arena_release_mock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.mock)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_mock()) {
    clear_has_type();
    return type_.mock_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_mock(std::string* mock) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_mock()) {
    type_.mock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_type();
  if (mock) {
    set_has_mock();
    type_.mock_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mock, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.mock)
}

inline bool RemoteStorageTarget::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RemoteStorageTarget::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline RemoteStorageTarget::TypeCase RemoteStorageTarget::type_case() const {
  return RemoteStorageTarget::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flex

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flex::UpdateWorkRequest_NewState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flex::UpdateWorkRequest_NewState>() {
  return ::flex::UpdateWorkRequest_NewState_descriptor();
}
template <> struct is_proto_enum< ::flex::BulkUpdateWorkRequest_NewState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flex::BulkUpdateWorkRequest_NewState>() {
  return ::flex::BulkUpdateWorkRequest_NewState_descriptor();
}
template <> struct is_proto_enum< ::flex::SyncJob_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flex::SyncJob_Operation>() {
  return ::flex::SyncJob_Operation_descriptor();
}
template <> struct is_proto_enum< ::flex::Work_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flex::Work_State>() {
  return ::flex::Work_State_descriptor();
}
template <> struct is_proto_enum< ::flex::UpdateConfigResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flex::UpdateConfigResponse_Result>() {
  return ::flex::UpdateConfigResponse_Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flex_2eproto
