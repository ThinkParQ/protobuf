// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: agent.proto
// Protobuf C++ Version: 5.29.2

#ifndef agent_2eproto_2epb_2eh
#define agent_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "beegfs.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_agent_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_agent_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_agent_2eproto;
namespace agent {
class Agent;
struct AgentDefaultTypeInternal;
extern AgentDefaultTypeInternal _Agent_default_instance_;
class Auth;
struct AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class CancelReconciliationRequest;
struct CancelReconciliationRequestDefaultTypeInternal;
extern CancelReconciliationRequestDefaultTypeInternal _CancelReconciliationRequest_default_instance_;
class CancelReconciliationResponse;
struct CancelReconciliationResponseDefaultTypeInternal;
extern CancelReconciliationResponseDefaultTypeInternal _CancelReconciliationResponse_default_instance_;
class Filesystem;
struct FilesystemDefaultTypeInternal;
extern FilesystemDefaultTypeInternal _Filesystem_default_instance_;
class Filesystem_AgentEntry_DoNotUse;
struct Filesystem_AgentEntry_DoNotUseDefaultTypeInternal;
extern Filesystem_AgentEntry_DoNotUseDefaultTypeInternal _Filesystem_AgentEntry_DoNotUse_default_instance_;
class Filesystem_Common;
struct Filesystem_CommonDefaultTypeInternal;
extern Filesystem_CommonDefaultTypeInternal _Filesystem_Common_default_instance_;
class InstallSource;
struct InstallSourceDefaultTypeInternal;
extern InstallSourceDefaultTypeInternal _InstallSource_default_instance_;
class Nic;
struct NicDefaultTypeInternal;
extern NicDefaultTypeInternal _Nic_default_instance_;
class ReconciliationStatusRequest;
struct ReconciliationStatusRequestDefaultTypeInternal;
extern ReconciliationStatusRequestDefaultTypeInternal _ReconciliationStatusRequest_default_instance_;
class ReconciliationStatusResponse;
struct ReconciliationStatusResponseDefaultTypeInternal;
extern ReconciliationStatusResponseDefaultTypeInternal _ReconciliationStatusResponse_default_instance_;
class Service;
struct ServiceDefaultTypeInternal;
extern ServiceDefaultTypeInternal _Service_default_instance_;
class ServiceConfig;
struct ServiceConfigDefaultTypeInternal;
extern ServiceConfigDefaultTypeInternal _ServiceConfig_default_instance_;
class ServiceConfig_StringMapEntry_DoNotUse;
struct ServiceConfig_StringMapEntry_DoNotUseDefaultTypeInternal;
extern ServiceConfig_StringMapEntry_DoNotUseDefaultTypeInternal _ServiceConfig_StringMapEntry_DoNotUse_default_instance_;
class Service_ConfigEntry_DoNotUse;
struct Service_ConfigEntry_DoNotUseDefaultTypeInternal;
extern Service_ConfigEntry_DoNotUseDefaultTypeInternal _Service_ConfigEntry_DoNotUse_default_instance_;
class SourceRef;
struct SourceRefDefaultTypeInternal;
extern SourceRefDefaultTypeInternal _SourceRef_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class TLS;
struct TLSDefaultTypeInternal;
extern TLSDefaultTypeInternal _TLS_default_instance_;
class Target;
struct TargetDefaultTypeInternal;
extern TargetDefaultTypeInternal _Target_default_instance_;
class Target_UnderlyingFSOpts;
struct Target_UnderlyingFSOptsDefaultTypeInternal;
extern Target_UnderlyingFSOptsDefaultTypeInternal _Target_UnderlyingFSOpts_default_instance_;
class UpdateManifestRequest;
struct UpdateManifestRequestDefaultTypeInternal;
extern UpdateManifestRequestDefaultTypeInternal _UpdateManifestRequest_default_instance_;
class UpdateManifestRequest_ConfigEntry_DoNotUse;
struct UpdateManifestRequest_ConfigEntry_DoNotUseDefaultTypeInternal;
extern UpdateManifestRequest_ConfigEntry_DoNotUseDefaultTypeInternal _UpdateManifestRequest_ConfigEntry_DoNotUse_default_instance_;
class UpdateManifestResponse;
struct UpdateManifestResponseDefaultTypeInternal;
extern UpdateManifestResponseDefaultTypeInternal _UpdateManifestResponse_default_instance_;
}  // namespace agent
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace agent {
enum Status_State : int {
  Status_State_UNSPECIFIED = 0,
  Status_State_IDLE = 1,
  Status_State_APPLYING = 2,
  Status_State_SUCCESS = 3,
  Status_State_FAILED = 4,
  Status_State_CANCELLED = 5,
  Status_State_Status_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Status_State_Status_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Status_State_IsValid(int value);
extern const uint32_t Status_State_internal_data_[];
constexpr Status_State Status_State_State_MIN = static_cast<Status_State>(0);
constexpr Status_State Status_State_State_MAX = static_cast<Status_State>(5);
constexpr int Status_State_State_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Status_State_descriptor();
template <typename T>
const std::string& Status_State_Name(T value) {
  static_assert(std::is_same<T, Status_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return Status_State_Name(static_cast<Status_State>(value));
}
template <>
inline const std::string& Status_State_Name(Status_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Status_State_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Status_State_Parse(absl::string_view name, Status_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_State>(
      Status_State_descriptor(), name, value);
}
enum Target_UnderlyingFSOpts_FsType : int {
  Target_UnderlyingFSOpts_FsType_UNSPECIFIED = 0,
  Target_UnderlyingFSOpts_FsType_EXT4 = 1,
  Target_UnderlyingFSOpts_FsType_Target_UnderlyingFSOpts_FsType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Target_UnderlyingFSOpts_FsType_Target_UnderlyingFSOpts_FsType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Target_UnderlyingFSOpts_FsType_IsValid(int value);
extern const uint32_t Target_UnderlyingFSOpts_FsType_internal_data_[];
constexpr Target_UnderlyingFSOpts_FsType Target_UnderlyingFSOpts_FsType_FsType_MIN = static_cast<Target_UnderlyingFSOpts_FsType>(0);
constexpr Target_UnderlyingFSOpts_FsType Target_UnderlyingFSOpts_FsType_FsType_MAX = static_cast<Target_UnderlyingFSOpts_FsType>(1);
constexpr int Target_UnderlyingFSOpts_FsType_FsType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Target_UnderlyingFSOpts_FsType_descriptor();
template <typename T>
const std::string& Target_UnderlyingFSOpts_FsType_Name(T value) {
  static_assert(std::is_same<T, Target_UnderlyingFSOpts_FsType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FsType_Name().");
  return Target_UnderlyingFSOpts_FsType_Name(static_cast<Target_UnderlyingFSOpts_FsType>(value));
}
template <>
inline const std::string& Target_UnderlyingFSOpts_FsType_Name(Target_UnderlyingFSOpts_FsType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Target_UnderlyingFSOpts_FsType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Target_UnderlyingFSOpts_FsType_Parse(absl::string_view name, Target_UnderlyingFSOpts_FsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Target_UnderlyingFSOpts_FsType>(
      Target_UnderlyingFSOpts_FsType_descriptor(), name, value);
}
enum InstallType : int {
  UNKNOWN = 0,
  LOCAL = 1,
  PACKAGE = 2,
  InstallType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InstallType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InstallType_IsValid(int value);
extern const uint32_t InstallType_internal_data_[];
constexpr InstallType InstallType_MIN = static_cast<InstallType>(0);
constexpr InstallType InstallType_MAX = static_cast<InstallType>(2);
constexpr int InstallType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
InstallType_descriptor();
template <typename T>
const std::string& InstallType_Name(T value) {
  static_assert(std::is_same<T, InstallType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InstallType_Name().");
  return InstallType_Name(static_cast<InstallType>(value));
}
template <>
inline const std::string& InstallType_Name(InstallType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InstallType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool InstallType_Parse(absl::string_view name, InstallType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstallType>(
      InstallType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateManifestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.UpdateManifestResponse) */ {
 public:
  inline UpdateManifestResponse() : UpdateManifestResponse(nullptr) {}
  ~UpdateManifestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateManifestResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateManifestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateManifestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateManifestResponse(const UpdateManifestResponse& from) : UpdateManifestResponse(nullptr, from) {}
  inline UpdateManifestResponse(UpdateManifestResponse&& from) noexcept
      : UpdateManifestResponse(nullptr, std::move(from)) {}
  inline UpdateManifestResponse& operator=(const UpdateManifestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateManifestResponse& operator=(UpdateManifestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateManifestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateManifestResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateManifestResponse*>(
        &_UpdateManifestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(UpdateManifestResponse& a, UpdateManifestResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateManifestResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateManifestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateManifestResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateManifestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateManifestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateManifestResponse& from) { UpdateManifestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateManifestResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.UpdateManifestResponse"; }

 protected:
  explicit UpdateManifestResponse(::google::protobuf::Arena* arena);
  UpdateManifestResponse(::google::protobuf::Arena* arena, const UpdateManifestResponse& from);
  UpdateManifestResponse(::google::protobuf::Arena* arena, UpdateManifestResponse&& from) noexcept
      : UpdateManifestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdFieldNumber = 1,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // @@protoc_insertion_point(class_scope:agent.UpdateManifestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateManifestResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Target_UnderlyingFSOpts final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Target.UnderlyingFSOpts) */ {
 public:
  inline Target_UnderlyingFSOpts() : Target_UnderlyingFSOpts(nullptr) {}
  ~Target_UnderlyingFSOpts() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Target_UnderlyingFSOpts* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Target_UnderlyingFSOpts));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Target_UnderlyingFSOpts(
      ::google::protobuf::internal::ConstantInitialized);

  inline Target_UnderlyingFSOpts(const Target_UnderlyingFSOpts& from) : Target_UnderlyingFSOpts(nullptr, from) {}
  inline Target_UnderlyingFSOpts(Target_UnderlyingFSOpts&& from) noexcept
      : Target_UnderlyingFSOpts(nullptr, std::move(from)) {}
  inline Target_UnderlyingFSOpts& operator=(const Target_UnderlyingFSOpts& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target_UnderlyingFSOpts& operator=(Target_UnderlyingFSOpts&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target_UnderlyingFSOpts& default_instance() {
    return *internal_default_instance();
  }
  static inline const Target_UnderlyingFSOpts* internal_default_instance() {
    return reinterpret_cast<const Target_UnderlyingFSOpts*>(
        &_Target_UnderlyingFSOpts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(Target_UnderlyingFSOpts& a, Target_UnderlyingFSOpts& b) { a.Swap(&b); }
  inline void Swap(Target_UnderlyingFSOpts* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target_UnderlyingFSOpts* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target_UnderlyingFSOpts* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Target_UnderlyingFSOpts>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Target_UnderlyingFSOpts& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Target_UnderlyingFSOpts& from) { Target_UnderlyingFSOpts::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Target_UnderlyingFSOpts* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Target.UnderlyingFSOpts"; }

 protected:
  explicit Target_UnderlyingFSOpts(::google::protobuf::Arena* arena);
  Target_UnderlyingFSOpts(::google::protobuf::Arena* arena, const Target_UnderlyingFSOpts& from);
  Target_UnderlyingFSOpts(::google::protobuf::Arena* arena, Target_UnderlyingFSOpts&& from) noexcept
      : Target_UnderlyingFSOpts(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using FsType = Target_UnderlyingFSOpts_FsType;
  static constexpr FsType UNSPECIFIED = Target_UnderlyingFSOpts_FsType_UNSPECIFIED;
  static constexpr FsType EXT4 = Target_UnderlyingFSOpts_FsType_EXT4;
  static inline bool FsType_IsValid(int value) {
    return Target_UnderlyingFSOpts_FsType_IsValid(value);
  }
  static constexpr FsType FsType_MIN = Target_UnderlyingFSOpts_FsType_FsType_MIN;
  static constexpr FsType FsType_MAX = Target_UnderlyingFSOpts_FsType_FsType_MAX;
  static constexpr int FsType_ARRAYSIZE = Target_UnderlyingFSOpts_FsType_FsType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FsType_descriptor() {
    return Target_UnderlyingFSOpts_FsType_descriptor();
  }
  template <typename T>
  static inline const std::string& FsType_Name(T value) {
    return Target_UnderlyingFSOpts_FsType_Name(value);
  }
  static inline bool FsType_Parse(absl::string_view name, FsType* value) {
    return Target_UnderlyingFSOpts_FsType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
    kFormatFlagsFieldNumber = 3,
    kMountFlagsFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string format_flags = 3;
  void clear_format_flags() ;
  const std::string& format_flags() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_format_flags(Arg_&& arg, Args_... args);
  std::string* mutable_format_flags();
  PROTOBUF_NODISCARD std::string* release_format_flags();
  void set_allocated_format_flags(std::string* value);

  private:
  const std::string& _internal_format_flags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format_flags(
      const std::string& value);
  std::string* _internal_mutable_format_flags();

  public:
  // string mount_flags = 4;
  void clear_mount_flags() ;
  const std::string& mount_flags() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mount_flags(Arg_&& arg, Args_... args);
  std::string* mutable_mount_flags();
  PROTOBUF_NODISCARD std::string* release_mount_flags();
  void set_allocated_mount_flags(std::string* value);

  private:
  const std::string& _internal_mount_flags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mount_flags(
      const std::string& value);
  std::string* _internal_mutable_mount_flags();

  public:
  // .agent.Target.UnderlyingFSOpts.FsType type = 2;
  void clear_type() ;
  ::agent::Target_UnderlyingFSOpts_FsType type() const;
  void set_type(::agent::Target_UnderlyingFSOpts_FsType value);

  private:
  ::agent::Target_UnderlyingFSOpts_FsType _internal_type() const;
  void _internal_set_type(::agent::Target_UnderlyingFSOpts_FsType value);

  public:
  // @@protoc_insertion_point(class_scope:agent.Target.UnderlyingFSOpts)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Target_UnderlyingFSOpts& from_msg);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr format_flags_;
    ::google::protobuf::internal::ArenaStringPtr mount_flags_;
    int type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class TLS final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.TLS) */ {
 public:
  inline TLS() : TLS(nullptr) {}
  ~TLS() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TLS* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TLS));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TLS(
      ::google::protobuf::internal::ConstantInitialized);

  inline TLS(const TLS& from) : TLS(nullptr, from) {}
  inline TLS(TLS&& from) noexcept
      : TLS(nullptr, std::move(from)) {}
  inline TLS& operator=(const TLS& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLS& operator=(TLS&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TLS& default_instance() {
    return *internal_default_instance();
  }
  static inline const TLS* internal_default_instance() {
    return reinterpret_cast<const TLS*>(
        &_TLS_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(TLS& a, TLS& b) { a.Swap(&b); }
  inline void Swap(TLS* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TLS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TLS* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TLS>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TLS& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TLS& from) { TLS::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TLS* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.TLS"; }

 protected:
  explicit TLS(::google::protobuf::Arena* arena);
  TLS(::google::protobuf::Arena* arena, const TLS& from);
  TLS(::google::protobuf::Arena* arena, TLS&& from) noexcept
      : TLS(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kCertFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string cert = 2;
  void clear_cert() ;
  const std::string& cert() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cert(Arg_&& arg, Args_... args);
  std::string* mutable_cert();
  PROTOBUF_NODISCARD std::string* release_cert();
  void set_allocated_cert(std::string* value);

  private:
  const std::string& _internal_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cert(
      const std::string& value);
  std::string* _internal_mutable_cert();

  public:
  // @@protoc_insertion_point(class_scope:agent.TLS)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      25, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TLS& from_msg);
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr cert_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class SourceRef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.SourceRef) */ {
 public:
  inline SourceRef() : SourceRef(nullptr) {}
  ~SourceRef() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SourceRef* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SourceRef));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SourceRef(
      ::google::protobuf::internal::ConstantInitialized);

  inline SourceRef(const SourceRef& from) : SourceRef(nullptr, from) {}
  inline SourceRef(SourceRef&& from) noexcept
      : SourceRef(nullptr, std::move(from)) {}
  inline SourceRef& operator=(const SourceRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceRef& operator=(SourceRef&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceRef* internal_default_instance() {
    return reinterpret_cast<const SourceRef*>(
        &_SourceRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SourceRef& a, SourceRef& b) { a.Swap(&b); }
  inline void Swap(SourceRef* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceRef* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SourceRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SourceRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SourceRef& from) { SourceRef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SourceRef* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.SourceRef"; }

 protected:
  explicit SourceRef(::google::protobuf::Arena* arena);
  SourceRef(::google::protobuf::Arena* arena, const SourceRef& from);
  SourceRef(::google::protobuf::Arena* arena, SourceRef&& from) noexcept
      : SourceRef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRefFieldNumber = 2,
    kServiceTypeFieldNumber = 1,
  };
  // string ref = 2;
  void clear_ref() ;
  const std::string& ref() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ref(Arg_&& arg, Args_... args);
  std::string* mutable_ref();
  PROTOBUF_NODISCARD std::string* release_ref();
  void set_allocated_ref(std::string* value);

  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(
      const std::string& value);
  std::string* _internal_mutable_ref();

  public:
  // .beegfs.NodeType service_type = 1;
  void clear_service_type() ;
  ::beegfs::NodeType service_type() const;
  void set_service_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_service_type() const;
  void _internal_set_service_type(::beegfs::NodeType value);

  public:
  // @@protoc_insertion_point(class_scope:agent.SourceRef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      27, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SourceRef& from_msg);
    ::google::protobuf::internal::ArenaStringPtr ref_;
    int service_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class ServiceConfig_StringMapEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ServiceConfig_StringMapEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceConfig_StringMapEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ServiceConfig_StringMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ServiceConfig_StringMapEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ServiceConfig_StringMapEntry_DoNotUse*>(
        &_ServiceConfig_StringMapEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_agent_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Service_ConfigEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Service_ConfigEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Service_ConfigEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Service_ConfigEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Service_ConfigEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Service_ConfigEntry_DoNotUse*>(
        &_Service_ConfigEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_agent_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReconciliationStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.ReconciliationStatusRequest) */ {
 public:
  inline ReconciliationStatusRequest() : ReconciliationStatusRequest(nullptr) {}
  ~ReconciliationStatusRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReconciliationStatusRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReconciliationStatusRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReconciliationStatusRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReconciliationStatusRequest(const ReconciliationStatusRequest& from) : ReconciliationStatusRequest(nullptr, from) {}
  inline ReconciliationStatusRequest(ReconciliationStatusRequest&& from) noexcept
      : ReconciliationStatusRequest(nullptr, std::move(from)) {}
  inline ReconciliationStatusRequest& operator=(const ReconciliationStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconciliationStatusRequest& operator=(ReconciliationStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconciliationStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconciliationStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ReconciliationStatusRequest*>(
        &_ReconciliationStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ReconciliationStatusRequest& a, ReconciliationStatusRequest& b) { a.Swap(&b); }
  inline void Swap(ReconciliationStatusRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconciliationStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconciliationStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReconciliationStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReconciliationStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReconciliationStatusRequest& from) { ReconciliationStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReconciliationStatusRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.ReconciliationStatusRequest"; }

 protected:
  explicit ReconciliationStatusRequest(::google::protobuf::Arena* arena);
  ReconciliationStatusRequest(::google::protobuf::Arena* arena, const ReconciliationStatusRequest& from);
  ReconciliationStatusRequest(::google::protobuf::Arena* arena, ReconciliationStatusRequest&& from) noexcept
      : ReconciliationStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdFieldNumber = 1,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // @@protoc_insertion_point(class_scope:agent.ReconciliationStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReconciliationStatusRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Nic final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Nic) */ {
 public:
  inline Nic() : Nic(nullptr) {}
  ~Nic() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Nic* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Nic));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Nic(
      ::google::protobuf::internal::ConstantInitialized);

  inline Nic(const Nic& from) : Nic(nullptr, from) {}
  inline Nic(Nic&& from) noexcept
      : Nic(nullptr, std::move(from)) {}
  inline Nic& operator=(const Nic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nic& operator=(Nic&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Nic& default_instance() {
    return *internal_default_instance();
  }
  static inline const Nic* internal_default_instance() {
    return reinterpret_cast<const Nic*>(
        &_Nic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(Nic& a, Nic& b) { a.Swap(&b); }
  inline void Swap(Nic* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Nic* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Nic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Nic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Nic& from) { Nic::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Nic* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Nic"; }

 protected:
  explicit Nic(::google::protobuf::Arena* arena);
  Nic(::google::protobuf::Arena* arena, const Nic& from);
  Nic(::google::protobuf::Arena* arena, Nic&& from) noexcept
      : Nic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kAddrFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string addr = 2;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // @@protoc_insertion_point(class_scope:agent.Nic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Nic& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class CancelReconciliationRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.CancelReconciliationRequest) */ {
 public:
  inline CancelReconciliationRequest() : CancelReconciliationRequest(nullptr) {}
  ~CancelReconciliationRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelReconciliationRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelReconciliationRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelReconciliationRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelReconciliationRequest(const CancelReconciliationRequest& from) : CancelReconciliationRequest(nullptr, from) {}
  inline CancelReconciliationRequest(CancelReconciliationRequest&& from) noexcept
      : CancelReconciliationRequest(nullptr, std::move(from)) {}
  inline CancelReconciliationRequest& operator=(const CancelReconciliationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelReconciliationRequest& operator=(CancelReconciliationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelReconciliationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelReconciliationRequest* internal_default_instance() {
    return reinterpret_cast<const CancelReconciliationRequest*>(
        &_CancelReconciliationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CancelReconciliationRequest& a, CancelReconciliationRequest& b) { a.Swap(&b); }
  inline void Swap(CancelReconciliationRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelReconciliationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelReconciliationRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CancelReconciliationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelReconciliationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelReconciliationRequest& from) { CancelReconciliationRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelReconciliationRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.CancelReconciliationRequest"; }

 protected:
  explicit CancelReconciliationRequest(::google::protobuf::Arena* arena);
  CancelReconciliationRequest(::google::protobuf::Arena* arena, const CancelReconciliationRequest& from);
  CancelReconciliationRequest(::google::protobuf::Arena* arena, CancelReconciliationRequest&& from) noexcept
      : CancelReconciliationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // string reason = 2;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // @@protoc_insertion_point(class_scope:agent.CancelReconciliationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelReconciliationRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Auth final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Auth) */ {
 public:
  inline Auth() : Auth(nullptr) {}
  ~Auth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Auth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Auth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Auth(
      ::google::protobuf::internal::ConstantInitialized);

  inline Auth(const Auth& from) : Auth(nullptr, from) {}
  inline Auth(Auth&& from) noexcept
      : Auth(nullptr, std::move(from)) {}
  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Auth& operator=(Auth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Auth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
        &_Auth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Auth& a, Auth& b) { a.Swap(&b); }
  inline void Swap(Auth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Auth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Auth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Auth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Auth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Auth& from) { Auth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Auth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Auth"; }

 protected:
  explicit Auth(::google::protobuf::Arena* arena);
  Auth(::google::protobuf::Arena* arena, const Auth& from);
  Auth(::google::protobuf::Arena* arena, Auth&& from) noexcept
      : Auth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSecretFieldNumber = 1,
  };
  // string secret = 1;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // @@protoc_insertion_point(class_scope:agent.Auth)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      25, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Auth& from_msg);
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Target final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Target) */ {
 public:
  inline Target() : Target(nullptr) {}
  ~Target() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Target* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Target));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Target(
      ::google::protobuf::internal::ConstantInitialized);

  inline Target(const Target& from) : Target(nullptr, from) {}
  inline Target(Target&& from) noexcept
      : Target(nullptr, std::move(from)) {}
  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target& operator=(Target&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target& default_instance() {
    return *internal_default_instance();
  }
  static inline const Target* internal_default_instance() {
    return reinterpret_cast<const Target*>(
        &_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(Target& a, Target& b) { a.Swap(&b); }
  inline void Swap(Target* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Target>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Target& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Target& from) { Target::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Target* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Target"; }

 protected:
  explicit Target(::google::protobuf::Arena* arena);
  Target(::google::protobuf::Arena* arena, const Target& from);
  Target(::google::protobuf::Arena* arena, Target&& from) noexcept
      : Target(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using UnderlyingFSOpts = Target_UnderlyingFSOpts;

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 2,
    kUlfsFieldNumber = 3,
    kNumIdFieldNumber = 1,
  };
  // string path = 2;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional .agent.Target.UnderlyingFSOpts ulfs = 3;
  bool has_ulfs() const;
  void clear_ulfs() ;
  const ::agent::Target_UnderlyingFSOpts& ulfs() const;
  PROTOBUF_NODISCARD ::agent::Target_UnderlyingFSOpts* release_ulfs();
  ::agent::Target_UnderlyingFSOpts* mutable_ulfs();
  void set_allocated_ulfs(::agent::Target_UnderlyingFSOpts* value);
  void unsafe_arena_set_allocated_ulfs(::agent::Target_UnderlyingFSOpts* value);
  ::agent::Target_UnderlyingFSOpts* unsafe_arena_release_ulfs();

  private:
  const ::agent::Target_UnderlyingFSOpts& _internal_ulfs() const;
  ::agent::Target_UnderlyingFSOpts* _internal_mutable_ulfs();

  public:
  // uint32 num_id = 1;
  void clear_num_id() ;
  ::uint32_t num_id() const;
  void set_num_id(::uint32_t value);

  private:
  ::uint32_t _internal_num_id() const;
  void _internal_set_num_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:agent.Target)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      25, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Target& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::agent::Target_UnderlyingFSOpts* ulfs_;
    ::uint32_t num_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Status final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Status* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Status));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Status(
      ::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from) : Status(nullptr, from) {}
  inline Status(Status&& from) noexcept
      : Status(nullptr, std::move(from)) {}
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
        &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Status& a, Status& b) { a.Swap(&b); }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Status& from) { Status::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Status* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Status"; }

 protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  Status(::google::protobuf::Arena* arena, Status&& from) noexcept
      : Status(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using State = Status_State;
  static constexpr State UNSPECIFIED = Status_State_UNSPECIFIED;
  static constexpr State IDLE = Status_State_IDLE;
  static constexpr State APPLYING = Status_State_APPLYING;
  static constexpr State SUCCESS = Status_State_SUCCESS;
  static constexpr State FAILED = Status_State_FAILED;
  static constexpr State CANCELLED = Status_State_CANCELLED;
  static inline bool State_IsValid(int value) {
    return Status_State_IsValid(value);
  }
  static constexpr State State_MIN = Status_State_State_MIN;
  static constexpr State State_MAX = Status_State_State_MAX;
  static constexpr int State_ARRAYSIZE = Status_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return Status_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return Status_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return Status_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessagesFieldNumber = 2,
    kUpdatedFieldNumber = 3,
    kStateFieldNumber = 1,
  };
  // repeated string messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;

  public:
  void clear_messages() ;
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messages(int index, Arg_&& value, Args_... args);
  std::string* add_messages();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_messages(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& messages() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_messages();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_messages() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_messages();

  public:
  // .google.protobuf.Timestamp updated = 3;
  bool has_updated() const;
  void clear_updated() ;
  const ::google::protobuf::Timestamp& updated() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated();
  ::google::protobuf::Timestamp* mutable_updated();
  void set_allocated_updated(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated();

  private:
  const ::google::protobuf::Timestamp& _internal_updated() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated();

  public:
  // .agent.Status.State state = 1;
  void clear_state() ;
  ::agent::Status_State state() const;
  void set_state(::agent::Status_State value);

  private:
  ::agent::Status_State _internal_state() const;
  void _internal_set_state(::agent::Status_State value);

  public:
  // @@protoc_insertion_point(class_scope:agent.Status)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      29, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Status& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> messages_;
    ::google::protobuf::Timestamp* updated_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class ServiceConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.ServiceConfig) */ {
 public:
  inline ServiceConfig() : ServiceConfig(nullptr) {}
  ~ServiceConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServiceConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServiceConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServiceConfig(const ServiceConfig& from) : ServiceConfig(nullptr, from) {}
  inline ServiceConfig(ServiceConfig&& from) noexcept
      : ServiceConfig(nullptr, std::move(from)) {}
  inline ServiceConfig& operator=(const ServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceConfig& operator=(ServiceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceConfig* internal_default_instance() {
    return reinterpret_cast<const ServiceConfig*>(
        &_ServiceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ServiceConfig& a, ServiceConfig& b) { a.Swap(&b); }
  inline void Swap(ServiceConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServiceConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServiceConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServiceConfig& from) { ServiceConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServiceConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.ServiceConfig"; }

 protected:
  explicit ServiceConfig(::google::protobuf::Arena* arena);
  ServiceConfig(::google::protobuf::Arena* arena, const ServiceConfig& from);
  ServiceConfig(::google::protobuf::Arena* arena, ServiceConfig&& from) noexcept
      : ServiceConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStringMapFieldNumber = 2,
    kServiceTypeFieldNumber = 1,
  };
  // map<string, string> string_map = 2;
  int string_map_size() const;
  private:
  int _internal_string_map_size() const;

  public:
  void clear_string_map() ;
  const ::google::protobuf::Map<std::string, std::string>& string_map() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_string_map();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_string_map() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_string_map();

  public:
  // .beegfs.NodeType service_type = 1;
  void clear_service_type() ;
  ::beegfs::NodeType service_type() const;
  void set_service_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_service_type() const;
  void _internal_set_service_type(::beegfs::NodeType value);

  public:
  // @@protoc_insertion_point(class_scope:agent.ServiceConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      38, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServiceConfig& from_msg);
    ::google::protobuf::internal::MapField<ServiceConfig_StringMapEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        string_map_;
    int service_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class InstallSource final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.InstallSource) */ {
 public:
  inline InstallSource() : InstallSource(nullptr) {}
  ~InstallSource() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstallSource* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstallSource));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstallSource(
      ::google::protobuf::internal::ConstantInitialized);

  inline InstallSource(const InstallSource& from) : InstallSource(nullptr, from) {}
  inline InstallSource(InstallSource&& from) noexcept
      : InstallSource(nullptr, std::move(from)) {}
  inline InstallSource& operator=(const InstallSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSource& operator=(InstallSource&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSource* internal_default_instance() {
    return reinterpret_cast<const InstallSource*>(
        &_InstallSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(InstallSource& a, InstallSource& b) { a.Swap(&b); }
  inline void Swap(InstallSource* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSource* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstallSource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstallSource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstallSource& from) { InstallSource::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstallSource* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.InstallSource"; }

 protected:
  explicit InstallSource(::google::protobuf::Arena* arena);
  InstallSource(::google::protobuf::Arena* arena, const InstallSource& from);
  InstallSource(::google::protobuf::Arena* arena, InstallSource&& from) noexcept
      : InstallSource(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRefsFieldNumber = 3,
    kRepoFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .agent.SourceRef refs = 3;
  int refs_size() const;
  private:
  int _internal_refs_size() const;

  public:
  void clear_refs() ;
  ::agent::SourceRef* mutable_refs(int index);
  ::google::protobuf::RepeatedPtrField<::agent::SourceRef>* mutable_refs();

  private:
  const ::google::protobuf::RepeatedPtrField<::agent::SourceRef>& _internal_refs() const;
  ::google::protobuf::RepeatedPtrField<::agent::SourceRef>* _internal_mutable_refs();
  public:
  const ::agent::SourceRef& refs(int index) const;
  ::agent::SourceRef* add_refs();
  const ::google::protobuf::RepeatedPtrField<::agent::SourceRef>& refs() const;
  // string repo = 2;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // .agent.InstallType type = 1;
  void clear_type() ;
  ::agent::InstallType type() const;
  void set_type(::agent::InstallType value);

  private:
  ::agent::InstallType _internal_type() const;
  void _internal_set_type(::agent::InstallType value);

  public:
  // @@protoc_insertion_point(class_scope:agent.InstallSource)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InstallSource& from_msg);
    ::google::protobuf::RepeatedPtrField< ::agent::SourceRef > refs_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    int type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Service final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Service) */ {
 public:
  inline Service() : Service(nullptr) {}
  ~Service() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Service* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Service));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Service(
      ::google::protobuf::internal::ConstantInitialized);

  inline Service(const Service& from) : Service(nullptr, from) {}
  inline Service(Service&& from) noexcept
      : Service(nullptr, std::move(from)) {}
  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service& operator=(Service&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service* internal_default_instance() {
    return reinterpret_cast<const Service*>(
        &_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(Service& a, Service& b) { a.Swap(&b); }
  inline void Swap(Service* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Service>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Service& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Service& from) { Service::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Service* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Service"; }

 protected:
  explicit Service(::google::protobuf::Arena* arena);
  Service(::google::protobuf::Arena* arena, const Service& from);
  Service(::google::protobuf::Arena* arena, Service&& from) noexcept
      : Service(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConfigFieldNumber = 3,
    kInterfacesFieldNumber = 4,
    kTargetsFieldNumber = 5,
    kExecutableFieldNumber = 6,
    kNumIdFieldNumber = 1,
    kServiceTypeFieldNumber = 2,
  };
  // map<string, string> config = 3;
  int config_size() const;
  private:
  int _internal_config_size() const;

  public:
  void clear_config() ;
  const ::google::protobuf::Map<std::string, std::string>& config() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_config();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_config() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_config();

  public:
  // repeated .agent.Nic interfaces = 4;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;

  public:
  void clear_interfaces() ;
  ::agent::Nic* mutable_interfaces(int index);
  ::google::protobuf::RepeatedPtrField<::agent::Nic>* mutable_interfaces();

  private:
  const ::google::protobuf::RepeatedPtrField<::agent::Nic>& _internal_interfaces() const;
  ::google::protobuf::RepeatedPtrField<::agent::Nic>* _internal_mutable_interfaces();
  public:
  const ::agent::Nic& interfaces(int index) const;
  ::agent::Nic* add_interfaces();
  const ::google::protobuf::RepeatedPtrField<::agent::Nic>& interfaces() const;
  // repeated .agent.Target targets = 5;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::agent::Target* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::agent::Target>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::agent::Target>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::agent::Target>* _internal_mutable_targets();
  public:
  const ::agent::Target& targets(int index) const;
  ::agent::Target* add_targets();
  const ::google::protobuf::RepeatedPtrField<::agent::Target>& targets() const;
  // string executable = 6;
  void clear_executable() ;
  const std::string& executable() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_executable(Arg_&& arg, Args_... args);
  std::string* mutable_executable();
  PROTOBUF_NODISCARD std::string* release_executable();
  void set_allocated_executable(std::string* value);

  private:
  const std::string& _internal_executable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_executable(
      const std::string& value);
  std::string* _internal_mutable_executable();

  public:
  // uint32 num_id = 1;
  void clear_num_id() ;
  ::uint32_t num_id() const;
  void set_num_id(::uint32_t value);

  private:
  ::uint32_t _internal_num_id() const;
  void _internal_set_num_id(::uint32_t value);

  public:
  // .beegfs.NodeType service_type = 2;
  void clear_service_type() ;
  ::beegfs::NodeType service_type() const;
  void set_service_type(::beegfs::NodeType value);

  private:
  ::beegfs::NodeType _internal_service_type() const;
  void _internal_set_service_type(::beegfs::NodeType value);

  public:
  // @@protoc_insertion_point(class_scope:agent.Service)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      38, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Service& from_msg);
    ::google::protobuf::internal::MapField<Service_ConfigEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        config_;
    ::google::protobuf::RepeatedPtrField< ::agent::Nic > interfaces_;
    ::google::protobuf::RepeatedPtrField< ::agent::Target > targets_;
    ::google::protobuf::internal::ArenaStringPtr executable_;
    ::uint32_t num_id_;
    int service_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class ReconciliationStatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.ReconciliationStatusResponse) */ {
 public:
  inline ReconciliationStatusResponse() : ReconciliationStatusResponse(nullptr) {}
  ~ReconciliationStatusResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReconciliationStatusResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReconciliationStatusResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReconciliationStatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReconciliationStatusResponse(const ReconciliationStatusResponse& from) : ReconciliationStatusResponse(nullptr, from) {}
  inline ReconciliationStatusResponse(ReconciliationStatusResponse&& from) noexcept
      : ReconciliationStatusResponse(nullptr, std::move(from)) {}
  inline ReconciliationStatusResponse& operator=(const ReconciliationStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconciliationStatusResponse& operator=(ReconciliationStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconciliationStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconciliationStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ReconciliationStatusResponse*>(
        &_ReconciliationStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ReconciliationStatusResponse& a, ReconciliationStatusResponse& b) { a.Swap(&b); }
  inline void Swap(ReconciliationStatusResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconciliationStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconciliationStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReconciliationStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReconciliationStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReconciliationStatusResponse& from) { ReconciliationStatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReconciliationStatusResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.ReconciliationStatusResponse"; }

 protected:
  explicit ReconciliationStatusResponse(::google::protobuf::Arena* arena);
  ReconciliationStatusResponse(::google::protobuf::Arena* arena, const ReconciliationStatusResponse& from);
  ReconciliationStatusResponse(::google::protobuf::Arena* arena, ReconciliationStatusResponse&& from) noexcept
      : ReconciliationStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // .agent.Status status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::agent::Status& status() const;
  PROTOBUF_NODISCARD ::agent::Status* release_status();
  ::agent::Status* mutable_status();
  void set_allocated_status(::agent::Status* value);
  void unsafe_arena_set_allocated_status(::agent::Status* value);
  ::agent::Status* unsafe_arena_release_status();

  private:
  const ::agent::Status& _internal_status() const;
  ::agent::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:agent.ReconciliationStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReconciliationStatusResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::agent::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Filesystem_Common final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Filesystem.Common) */ {
 public:
  inline Filesystem_Common() : Filesystem_Common(nullptr) {}
  ~Filesystem_Common() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Filesystem_Common* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Filesystem_Common));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Filesystem_Common(
      ::google::protobuf::internal::ConstantInitialized);

  inline Filesystem_Common(const Filesystem_Common& from) : Filesystem_Common(nullptr, from) {}
  inline Filesystem_Common(Filesystem_Common&& from) noexcept
      : Filesystem_Common(nullptr, std::move(from)) {}
  inline Filesystem_Common& operator=(const Filesystem_Common& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filesystem_Common& operator=(Filesystem_Common&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filesystem_Common& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filesystem_Common* internal_default_instance() {
    return reinterpret_cast<const Filesystem_Common*>(
        &_Filesystem_Common_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Filesystem_Common& a, Filesystem_Common& b) { a.Swap(&b); }
  inline void Swap(Filesystem_Common* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filesystem_Common* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filesystem_Common* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Filesystem_Common>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Filesystem_Common& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Filesystem_Common& from) { Filesystem_Common::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Filesystem_Common* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Filesystem.Common"; }

 protected:
  explicit Filesystem_Common(::google::protobuf::Arena* arena);
  Filesystem_Common(::google::protobuf::Arena* arena, const Filesystem_Common& from);
  Filesystem_Common(::google::protobuf::Arena* arena, Filesystem_Common&& from) noexcept
      : Filesystem_Common(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGlobalConfigFieldNumber = 4,
    kAuthFieldNumber = 1,
    kTlsFieldNumber = 2,
    kInstallSourceFieldNumber = 3,
  };
  // repeated .agent.ServiceConfig global_config = 4;
  int global_config_size() const;
  private:
  int _internal_global_config_size() const;

  public:
  void clear_global_config() ;
  ::agent::ServiceConfig* mutable_global_config(int index);
  ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>* mutable_global_config();

  private:
  const ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>& _internal_global_config() const;
  ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>* _internal_mutable_global_config();
  public:
  const ::agent::ServiceConfig& global_config(int index) const;
  ::agent::ServiceConfig* add_global_config();
  const ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>& global_config() const;
  // optional .agent.Auth auth = 1;
  bool has_auth() const;
  void clear_auth() ;
  const ::agent::Auth& auth() const;
  PROTOBUF_NODISCARD ::agent::Auth* release_auth();
  ::agent::Auth* mutable_auth();
  void set_allocated_auth(::agent::Auth* value);
  void unsafe_arena_set_allocated_auth(::agent::Auth* value);
  ::agent::Auth* unsafe_arena_release_auth();

  private:
  const ::agent::Auth& _internal_auth() const;
  ::agent::Auth* _internal_mutable_auth();

  public:
  // optional .agent.TLS tls = 2;
  bool has_tls() const;
  void clear_tls() ;
  const ::agent::TLS& tls() const;
  PROTOBUF_NODISCARD ::agent::TLS* release_tls();
  ::agent::TLS* mutable_tls();
  void set_allocated_tls(::agent::TLS* value);
  void unsafe_arena_set_allocated_tls(::agent::TLS* value);
  ::agent::TLS* unsafe_arena_release_tls();

  private:
  const ::agent::TLS& _internal_tls() const;
  ::agent::TLS* _internal_mutable_tls();

  public:
  // .agent.InstallSource install_source = 3;
  bool has_install_source() const;
  void clear_install_source() ;
  const ::agent::InstallSource& install_source() const;
  PROTOBUF_NODISCARD ::agent::InstallSource* release_install_source();
  ::agent::InstallSource* mutable_install_source();
  void set_allocated_install_source(::agent::InstallSource* value);
  void unsafe_arena_set_allocated_install_source(::agent::InstallSource* value);
  ::agent::InstallSource* unsafe_arena_release_install_source();

  private:
  const ::agent::InstallSource& _internal_install_source() const;
  ::agent::InstallSource* _internal_mutable_install_source();

  public:
  // @@protoc_insertion_point(class_scope:agent.Filesystem.Common)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Filesystem_Common& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::agent::ServiceConfig > global_config_;
    ::agent::Auth* auth_;
    ::agent::TLS* tls_;
    ::agent::InstallSource* install_source_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class CancelReconciliationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.CancelReconciliationResponse) */ {
 public:
  inline CancelReconciliationResponse() : CancelReconciliationResponse(nullptr) {}
  ~CancelReconciliationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelReconciliationResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelReconciliationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelReconciliationResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelReconciliationResponse(const CancelReconciliationResponse& from) : CancelReconciliationResponse(nullptr, from) {}
  inline CancelReconciliationResponse(CancelReconciliationResponse&& from) noexcept
      : CancelReconciliationResponse(nullptr, std::move(from)) {}
  inline CancelReconciliationResponse& operator=(const CancelReconciliationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelReconciliationResponse& operator=(CancelReconciliationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelReconciliationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelReconciliationResponse* internal_default_instance() {
    return reinterpret_cast<const CancelReconciliationResponse*>(
        &_CancelReconciliationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CancelReconciliationResponse& a, CancelReconciliationResponse& b) { a.Swap(&b); }
  inline void Swap(CancelReconciliationResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelReconciliationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelReconciliationResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CancelReconciliationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelReconciliationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelReconciliationResponse& from) { CancelReconciliationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelReconciliationResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.CancelReconciliationResponse"; }

 protected:
  explicit CancelReconciliationResponse(::google::protobuf::Arena* arena);
  CancelReconciliationResponse(::google::protobuf::Arena* arena, const CancelReconciliationResponse& from);
  CancelReconciliationResponse(::google::protobuf::Arena* arena, CancelReconciliationResponse&& from) noexcept
      : CancelReconciliationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // .agent.Status status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::agent::Status& status() const;
  PROTOBUF_NODISCARD ::agent::Status* release_status();
  ::agent::Status* mutable_status();
  void set_allocated_status(::agent::Status* value);
  void unsafe_arena_set_allocated_status(::agent::Status* value);
  ::agent::Status* unsafe_arena_release_status();

  private:
  const ::agent::Status& _internal_status() const;
  ::agent::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:agent.CancelReconciliationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelReconciliationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::agent::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Agent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Agent) */ {
 public:
  inline Agent() : Agent(nullptr) {}
  ~Agent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Agent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Agent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Agent(
      ::google::protobuf::internal::ConstantInitialized);

  inline Agent(const Agent& from) : Agent(nullptr, from) {}
  inline Agent(Agent&& from) noexcept
      : Agent(nullptr, std::move(from)) {}
  inline Agent& operator=(const Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agent& operator=(Agent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const Agent* internal_default_instance() {
    return reinterpret_cast<const Agent*>(
        &_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Agent& a, Agent& b) { a.Swap(&b); }
  inline void Swap(Agent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Agent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Agent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Agent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Agent& from) { Agent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Agent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Agent"; }

 protected:
  explicit Agent(::google::protobuf::Arena* arena);
  Agent(::google::protobuf::Arena* arena, const Agent& from);
  Agent(::google::protobuf::Arena* arena, Agent&& from) noexcept
      : Agent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServicesFieldNumber = 1,
    kInterfacesFieldNumber = 2,
  };
  // repeated .agent.Service services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::agent::Service* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField<::agent::Service>* mutable_services();

  private:
  const ::google::protobuf::RepeatedPtrField<::agent::Service>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::agent::Service>* _internal_mutable_services();
  public:
  const ::agent::Service& services(int index) const;
  ::agent::Service* add_services();
  const ::google::protobuf::RepeatedPtrField<::agent::Service>& services() const;
  // repeated .agent.Nic interfaces = 2;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;

  public:
  void clear_interfaces() ;
  ::agent::Nic* mutable_interfaces(int index);
  ::google::protobuf::RepeatedPtrField<::agent::Nic>* mutable_interfaces();

  private:
  const ::google::protobuf::RepeatedPtrField<::agent::Nic>& _internal_interfaces() const;
  ::google::protobuf::RepeatedPtrField<::agent::Nic>* _internal_mutable_interfaces();
  public:
  const ::agent::Nic& interfaces(int index) const;
  ::agent::Nic* add_interfaces();
  const ::google::protobuf::RepeatedPtrField<::agent::Nic>& interfaces() const;
  // @@protoc_insertion_point(class_scope:agent.Agent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Agent& from_msg);
    ::google::protobuf::RepeatedPtrField< ::agent::Service > services_;
    ::google::protobuf::RepeatedPtrField< ::agent::Nic > interfaces_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class Filesystem_AgentEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Filesystem_AgentEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Filesystem_AgentEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Filesystem_AgentEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Filesystem_AgentEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Filesystem_AgentEntry_DoNotUse*>(
        &_Filesystem_AgentEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_agent_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      39, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Filesystem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.Filesystem) */ {
 public:
  inline Filesystem() : Filesystem(nullptr) {}
  ~Filesystem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Filesystem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Filesystem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Filesystem(
      ::google::protobuf::internal::ConstantInitialized);

  inline Filesystem(const Filesystem& from) : Filesystem(nullptr, from) {}
  inline Filesystem(Filesystem&& from) noexcept
      : Filesystem(nullptr, std::move(from)) {}
  inline Filesystem& operator=(const Filesystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filesystem& operator=(Filesystem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filesystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filesystem* internal_default_instance() {
    return reinterpret_cast<const Filesystem*>(
        &_Filesystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Filesystem& a, Filesystem& b) { a.Swap(&b); }
  inline void Swap(Filesystem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filesystem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filesystem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Filesystem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Filesystem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Filesystem& from) { Filesystem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Filesystem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.Filesystem"; }

 protected:
  explicit Filesystem(::google::protobuf::Arena* arena);
  Filesystem(::google::protobuf::Arena* arena, const Filesystem& from);
  Filesystem(::google::protobuf::Arena* arena, Filesystem&& from) noexcept
      : Filesystem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Common = Filesystem_Common;

  // accessors -------------------------------------------------------
  enum : int {
    kAgentFieldNumber = 1,
    kCommonFieldNumber = 2,
  };
  // map<string, .agent.Agent> agent = 1;
  int agent_size() const;
  private:
  int _internal_agent_size() const;

  public:
  void clear_agent() ;
  const ::google::protobuf::Map<std::string, ::agent::Agent>& agent() const;
  ::google::protobuf::Map<std::string, ::agent::Agent>* mutable_agent();

  private:
  const ::google::protobuf::Map<std::string, ::agent::Agent>& _internal_agent() const;
  ::google::protobuf::Map<std::string, ::agent::Agent>* _internal_mutable_agent();

  public:
  // .agent.Filesystem.Common common = 2;
  bool has_common() const;
  void clear_common() ;
  const ::agent::Filesystem_Common& common() const;
  PROTOBUF_NODISCARD ::agent::Filesystem_Common* release_common();
  ::agent::Filesystem_Common* mutable_common();
  void set_allocated_common(::agent::Filesystem_Common* value);
  void unsafe_arena_set_allocated_common(::agent::Filesystem_Common* value);
  ::agent::Filesystem_Common* unsafe_arena_release_common();

  private:
  const ::agent::Filesystem_Common& _internal_common() const;
  ::agent::Filesystem_Common* _internal_mutable_common();

  public:
  // @@protoc_insertion_point(class_scope:agent.Filesystem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 3,
      30, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Filesystem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<Filesystem_AgentEntry_DoNotUse, std::string, ::agent::Agent,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        agent_;
    ::agent::Filesystem_Common* common_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class UpdateManifestRequest_ConfigEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  UpdateManifestRequest_ConfigEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateManifestRequest_ConfigEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit UpdateManifestRequest_ConfigEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const UpdateManifestRequest_ConfigEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const UpdateManifestRequest_ConfigEntry_DoNotUse*>(
        &_UpdateManifestRequest_ConfigEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_agent_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      51, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class UpdateManifestRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:agent.UpdateManifestRequest) */ {
 public:
  inline UpdateManifestRequest() : UpdateManifestRequest(nullptr) {}
  ~UpdateManifestRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateManifestRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateManifestRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateManifestRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateManifestRequest(const UpdateManifestRequest& from) : UpdateManifestRequest(nullptr, from) {}
  inline UpdateManifestRequest(UpdateManifestRequest&& from) noexcept
      : UpdateManifestRequest(nullptr, std::move(from)) {}
  inline UpdateManifestRequest& operator=(const UpdateManifestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateManifestRequest& operator=(UpdateManifestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateManifestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateManifestRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateManifestRequest*>(
        &_UpdateManifestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(UpdateManifestRequest& a, UpdateManifestRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateManifestRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateManifestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateManifestRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateManifestRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateManifestRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateManifestRequest& from) { UpdateManifestRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateManifestRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "agent.UpdateManifestRequest"; }

 protected:
  explicit UpdateManifestRequest(::google::protobuf::Arena* arena);
  UpdateManifestRequest(::google::protobuf::Arena* arena, const UpdateManifestRequest& from);
  UpdateManifestRequest(::google::protobuf::Arena* arena, UpdateManifestRequest&& from) noexcept
      : UpdateManifestRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConfigFieldNumber = 1,
  };
  // map<string, .agent.Filesystem> config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;

  public:
  void clear_config() ;
  const ::google::protobuf::Map<std::string, ::agent::Filesystem>& config() const;
  ::google::protobuf::Map<std::string, ::agent::Filesystem>* mutable_config();

  private:
  const ::google::protobuf::Map<std::string, ::agent::Filesystem>& _internal_config() const;
  ::google::protobuf::Map<std::string, ::agent::Filesystem>* _internal_mutable_config();

  public:
  // @@protoc_insertion_point(class_scope:agent.UpdateManifestRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateManifestRequest& from_msg);
    ::google::protobuf::internal::MapField<UpdateManifestRequest_ConfigEntry_DoNotUse, std::string, ::agent::Filesystem,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        config_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateManifestRequest

// map<string, .agent.Filesystem> config = 1;
inline int UpdateManifestRequest::_internal_config_size() const {
  return _internal_config().size();
}
inline int UpdateManifestRequest::config_size() const {
  return _internal_config_size();
}
inline void UpdateManifestRequest::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::agent::Filesystem>& UpdateManifestRequest::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::agent::Filesystem>& UpdateManifestRequest::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:agent.UpdateManifestRequest.config)
  return _internal_config();
}
inline ::google::protobuf::Map<std::string, ::agent::Filesystem>* UpdateManifestRequest::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::agent::Filesystem>* UpdateManifestRequest::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:agent.UpdateManifestRequest.config)
  return _internal_mutable_config();
}

// -------------------------------------------------------------------

// UpdateManifestResponse

// string agent_id = 1;
inline void UpdateManifestResponse::clear_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& UpdateManifestResponse::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.UpdateManifestResponse.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateManifestResponse::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.UpdateManifestResponse.agent_id)
}
inline std::string* UpdateManifestResponse::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:agent.UpdateManifestResponse.agent_id)
  return _s;
}
inline const std::string& UpdateManifestResponse::_internal_agent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_.Get();
}
inline void UpdateManifestResponse::_internal_set_agent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* UpdateManifestResponse::_internal_mutable_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* UpdateManifestResponse::release_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.UpdateManifestResponse.agent_id)
  return _impl_.agent_id_.Release();
}
inline void UpdateManifestResponse::set_allocated_agent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.UpdateManifestResponse.agent_id)
}

// -------------------------------------------------------------------

// ReconciliationStatusRequest

// string agent_id = 1;
inline void ReconciliationStatusRequest::clear_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& ReconciliationStatusRequest::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.ReconciliationStatusRequest.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReconciliationStatusRequest::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.ReconciliationStatusRequest.agent_id)
}
inline std::string* ReconciliationStatusRequest::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:agent.ReconciliationStatusRequest.agent_id)
  return _s;
}
inline const std::string& ReconciliationStatusRequest::_internal_agent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_.Get();
}
inline void ReconciliationStatusRequest::_internal_set_agent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* ReconciliationStatusRequest::_internal_mutable_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* ReconciliationStatusRequest::release_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.ReconciliationStatusRequest.agent_id)
  return _impl_.agent_id_.Release();
}
inline void ReconciliationStatusRequest::set_allocated_agent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.ReconciliationStatusRequest.agent_id)
}

// -------------------------------------------------------------------

// ReconciliationStatusResponse

// string agent_id = 1;
inline void ReconciliationStatusResponse::clear_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& ReconciliationStatusResponse::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.ReconciliationStatusResponse.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReconciliationStatusResponse::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.ReconciliationStatusResponse.agent_id)
}
inline std::string* ReconciliationStatusResponse::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:agent.ReconciliationStatusResponse.agent_id)
  return _s;
}
inline const std::string& ReconciliationStatusResponse::_internal_agent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_.Get();
}
inline void ReconciliationStatusResponse::_internal_set_agent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* ReconciliationStatusResponse::_internal_mutable_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* ReconciliationStatusResponse::release_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.ReconciliationStatusResponse.agent_id)
  return _impl_.agent_id_.Release();
}
inline void ReconciliationStatusResponse::set_allocated_agent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.ReconciliationStatusResponse.agent_id)
}

// .agent.Status status = 2;
inline bool ReconciliationStatusResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ReconciliationStatusResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::agent::Status& ReconciliationStatusResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::Status&>(::agent::_Status_default_instance_);
}
inline const ::agent::Status& ReconciliationStatusResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.ReconciliationStatusResponse.status)
  return _internal_status();
}
inline void ReconciliationStatusResponse::unsafe_arena_set_allocated_status(::agent::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::agent::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.ReconciliationStatusResponse.status)
}
inline ::agent::Status* ReconciliationStatusResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::Status* ReconciliationStatusResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.ReconciliationStatusResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::agent::Status* ReconciliationStatusResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::agent::Status*>(p);
  }
  return _impl_.status_;
}
inline ::agent::Status* ReconciliationStatusResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::agent::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:agent.ReconciliationStatusResponse.status)
  return _msg;
}
inline void ReconciliationStatusResponse::set_allocated_status(::agent::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::agent::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.ReconciliationStatusResponse.status)
}

// -------------------------------------------------------------------

// CancelReconciliationRequest

// string agent_id = 1;
inline void CancelReconciliationRequest::clear_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& CancelReconciliationRequest::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.CancelReconciliationRequest.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelReconciliationRequest::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.CancelReconciliationRequest.agent_id)
}
inline std::string* CancelReconciliationRequest::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:agent.CancelReconciliationRequest.agent_id)
  return _s;
}
inline const std::string& CancelReconciliationRequest::_internal_agent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_.Get();
}
inline void CancelReconciliationRequest::_internal_set_agent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* CancelReconciliationRequest::_internal_mutable_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* CancelReconciliationRequest::release_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.CancelReconciliationRequest.agent_id)
  return _impl_.agent_id_.Release();
}
inline void CancelReconciliationRequest::set_allocated_agent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.CancelReconciliationRequest.agent_id)
}

// string reason = 2;
inline void CancelReconciliationRequest::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& CancelReconciliationRequest::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.CancelReconciliationRequest.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelReconciliationRequest::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.CancelReconciliationRequest.reason)
}
inline std::string* CancelReconciliationRequest::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:agent.CancelReconciliationRequest.reason)
  return _s;
}
inline const std::string& CancelReconciliationRequest::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void CancelReconciliationRequest::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* CancelReconciliationRequest::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* CancelReconciliationRequest::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.CancelReconciliationRequest.reason)
  return _impl_.reason_.Release();
}
inline void CancelReconciliationRequest::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.CancelReconciliationRequest.reason)
}

// -------------------------------------------------------------------

// CancelReconciliationResponse

// string agent_id = 1;
inline void CancelReconciliationResponse::clear_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& CancelReconciliationResponse::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.CancelReconciliationResponse.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelReconciliationResponse::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.CancelReconciliationResponse.agent_id)
}
inline std::string* CancelReconciliationResponse::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:agent.CancelReconciliationResponse.agent_id)
  return _s;
}
inline const std::string& CancelReconciliationResponse::_internal_agent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_.Get();
}
inline void CancelReconciliationResponse::_internal_set_agent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* CancelReconciliationResponse::_internal_mutable_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* CancelReconciliationResponse::release_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.CancelReconciliationResponse.agent_id)
  return _impl_.agent_id_.Release();
}
inline void CancelReconciliationResponse::set_allocated_agent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.CancelReconciliationResponse.agent_id)
}

// .agent.Status status = 2;
inline bool CancelReconciliationResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void CancelReconciliationResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::agent::Status& CancelReconciliationResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::Status&>(::agent::_Status_default_instance_);
}
inline const ::agent::Status& CancelReconciliationResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.CancelReconciliationResponse.status)
  return _internal_status();
}
inline void CancelReconciliationResponse::unsafe_arena_set_allocated_status(::agent::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::agent::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.CancelReconciliationResponse.status)
}
inline ::agent::Status* CancelReconciliationResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::Status* CancelReconciliationResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.CancelReconciliationResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::agent::Status* CancelReconciliationResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::agent::Status*>(p);
  }
  return _impl_.status_;
}
inline ::agent::Status* CancelReconciliationResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::agent::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:agent.CancelReconciliationResponse.status)
  return _msg;
}
inline void CancelReconciliationResponse::set_allocated_status(::agent::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::agent::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.CancelReconciliationResponse.status)
}

// -------------------------------------------------------------------

// Status

// .agent.Status.State state = 1;
inline void Status::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::agent::Status_State Status::state() const {
  // @@protoc_insertion_point(field_get:agent.Status.state)
  return _internal_state();
}
inline void Status::set_state(::agent::Status_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:agent.Status.state)
}
inline ::agent::Status_State Status::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::agent::Status_State>(_impl_.state_);
}
inline void Status::_internal_set_state(::agent::Status_State value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// repeated string messages = 2;
inline int Status::_internal_messages_size() const {
  return _internal_messages().size();
}
inline int Status::messages_size() const {
  return _internal_messages_size();
}
inline void Status::clear_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messages_.Clear();
}
inline std::string* Status::add_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_messages()->Add();
  // @@protoc_insertion_point(field_add_mutable:agent.Status.messages)
  return _s;
}
inline const std::string& Status::messages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Status.messages)
  return _internal_messages().Get(index);
}
inline std::string* Status::mutable_messages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.Status.messages)
  return _internal_mutable_messages()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Status::set_messages(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_messages()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:agent.Status.messages)
}
template <typename Arg_, typename... Args_>
inline void Status::add_messages(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_messages(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:agent.Status.messages)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Status::messages() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.Status.messages)
  return _internal_messages();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Status::mutable_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.Status.messages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_messages();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Status::_internal_messages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.messages_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Status::_internal_mutable_messages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.messages_;
}

// .google.protobuf.Timestamp updated = 3;
inline bool Status::has_updated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Status::_internal_updated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Status::updated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Status.updated)
  return _internal_updated();
}
inline void Status::unsafe_arena_set_allocated_updated(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_);
  }
  _impl_.updated_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.Status.updated)
}
inline ::google::protobuf::Timestamp* Status::release_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.updated_;
  _impl_.updated_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Status::unsafe_arena_release_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Status.updated)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_;
  _impl_.updated_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Status::_internal_mutable_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.updated_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_;
}
inline ::google::protobuf::Timestamp* Status::mutable_updated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated();
  // @@protoc_insertion_point(field_mutable:agent.Status.updated)
  return _msg;
}
inline void Status::set_allocated_updated(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.updated_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.Status.updated)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Filesystem_Common

// optional .agent.Auth auth = 1;
inline bool Filesystem_Common::has_auth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auth_ != nullptr);
  return value;
}
inline void Filesystem_Common::clear_auth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.auth_ != nullptr) _impl_.auth_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::agent::Auth& Filesystem_Common::_internal_auth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::Auth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::Auth&>(::agent::_Auth_default_instance_);
}
inline const ::agent::Auth& Filesystem_Common::auth() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Filesystem.Common.auth)
  return _internal_auth();
}
inline void Filesystem_Common::unsafe_arena_set_allocated_auth(::agent::Auth* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = reinterpret_cast<::agent::Auth*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.Filesystem.Common.auth)
}
inline ::agent::Auth* Filesystem_Common::release_auth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Auth* released = _impl_.auth_;
  _impl_.auth_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::Auth* Filesystem_Common::unsafe_arena_release_auth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Filesystem.Common.auth)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Auth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::agent::Auth* Filesystem_Common::_internal_mutable_auth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.auth_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::Auth>(GetArena());
    _impl_.auth_ = reinterpret_cast<::agent::Auth*>(p);
  }
  return _impl_.auth_;
}
inline ::agent::Auth* Filesystem_Common::mutable_auth() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::agent::Auth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:agent.Filesystem.Common.auth)
  return _msg;
}
inline void Filesystem_Common::set_allocated_auth(::agent::Auth* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.auth_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.auth_ = reinterpret_cast<::agent::Auth*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.Filesystem.Common.auth)
}

// optional .agent.TLS tls = 2;
inline bool Filesystem_Common::has_tls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tls_ != nullptr);
  return value;
}
inline void Filesystem_Common::clear_tls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tls_ != nullptr) _impl_.tls_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::agent::TLS& Filesystem_Common::_internal_tls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::TLS* p = _impl_.tls_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::TLS&>(::agent::_TLS_default_instance_);
}
inline const ::agent::TLS& Filesystem_Common::tls() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Filesystem.Common.tls)
  return _internal_tls();
}
inline void Filesystem_Common::unsafe_arena_set_allocated_tls(::agent::TLS* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tls_);
  }
  _impl_.tls_ = reinterpret_cast<::agent::TLS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.Filesystem.Common.tls)
}
inline ::agent::TLS* Filesystem_Common::release_tls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::agent::TLS* released = _impl_.tls_;
  _impl_.tls_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::TLS* Filesystem_Common::unsafe_arena_release_tls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Filesystem.Common.tls)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::agent::TLS* temp = _impl_.tls_;
  _impl_.tls_ = nullptr;
  return temp;
}
inline ::agent::TLS* Filesystem_Common::_internal_mutable_tls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tls_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::TLS>(GetArena());
    _impl_.tls_ = reinterpret_cast<::agent::TLS*>(p);
  }
  return _impl_.tls_;
}
inline ::agent::TLS* Filesystem_Common::mutable_tls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::agent::TLS* _msg = _internal_mutable_tls();
  // @@protoc_insertion_point(field_mutable:agent.Filesystem.Common.tls)
  return _msg;
}
inline void Filesystem_Common::set_allocated_tls(::agent::TLS* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tls_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.tls_ = reinterpret_cast<::agent::TLS*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.Filesystem.Common.tls)
}

// .agent.InstallSource install_source = 3;
inline bool Filesystem_Common::has_install_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.install_source_ != nullptr);
  return value;
}
inline void Filesystem_Common::clear_install_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.install_source_ != nullptr) _impl_.install_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::agent::InstallSource& Filesystem_Common::_internal_install_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::InstallSource* p = _impl_.install_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::InstallSource&>(::agent::_InstallSource_default_instance_);
}
inline const ::agent::InstallSource& Filesystem_Common::install_source() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Filesystem.Common.install_source)
  return _internal_install_source();
}
inline void Filesystem_Common::unsafe_arena_set_allocated_install_source(::agent::InstallSource* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.install_source_);
  }
  _impl_.install_source_ = reinterpret_cast<::agent::InstallSource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.Filesystem.Common.install_source)
}
inline ::agent::InstallSource* Filesystem_Common::release_install_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::agent::InstallSource* released = _impl_.install_source_;
  _impl_.install_source_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::InstallSource* Filesystem_Common::unsafe_arena_release_install_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Filesystem.Common.install_source)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::agent::InstallSource* temp = _impl_.install_source_;
  _impl_.install_source_ = nullptr;
  return temp;
}
inline ::agent::InstallSource* Filesystem_Common::_internal_mutable_install_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.install_source_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::InstallSource>(GetArena());
    _impl_.install_source_ = reinterpret_cast<::agent::InstallSource*>(p);
  }
  return _impl_.install_source_;
}
inline ::agent::InstallSource* Filesystem_Common::mutable_install_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::agent::InstallSource* _msg = _internal_mutable_install_source();
  // @@protoc_insertion_point(field_mutable:agent.Filesystem.Common.install_source)
  return _msg;
}
inline void Filesystem_Common::set_allocated_install_source(::agent::InstallSource* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.install_source_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.install_source_ = reinterpret_cast<::agent::InstallSource*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.Filesystem.Common.install_source)
}

// repeated .agent.ServiceConfig global_config = 4;
inline int Filesystem_Common::_internal_global_config_size() const {
  return _internal_global_config().size();
}
inline int Filesystem_Common::global_config_size() const {
  return _internal_global_config_size();
}
inline void Filesystem_Common::clear_global_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_config_.Clear();
}
inline ::agent::ServiceConfig* Filesystem_Common::mutable_global_config(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.Filesystem.Common.global_config)
  return _internal_mutable_global_config()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>* Filesystem_Common::mutable_global_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.Filesystem.Common.global_config)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_global_config();
}
inline const ::agent::ServiceConfig& Filesystem_Common::global_config(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Filesystem.Common.global_config)
  return _internal_global_config().Get(index);
}
inline ::agent::ServiceConfig* Filesystem_Common::add_global_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::agent::ServiceConfig* _add = _internal_mutable_global_config()->Add();
  // @@protoc_insertion_point(field_add:agent.Filesystem.Common.global_config)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>& Filesystem_Common::global_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.Filesystem.Common.global_config)
  return _internal_global_config();
}
inline const ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>&
Filesystem_Common::_internal_global_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.global_config_;
}
inline ::google::protobuf::RepeatedPtrField<::agent::ServiceConfig>*
Filesystem_Common::_internal_mutable_global_config() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.global_config_;
}

// -------------------------------------------------------------------

// Filesystem

// map<string, .agent.Agent> agent = 1;
inline int Filesystem::_internal_agent_size() const {
  return _internal_agent().size();
}
inline int Filesystem::agent_size() const {
  return _internal_agent_size();
}
inline void Filesystem::clear_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::agent::Agent>& Filesystem::_internal_agent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::agent::Agent>& Filesystem::agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:agent.Filesystem.agent)
  return _internal_agent();
}
inline ::google::protobuf::Map<std::string, ::agent::Agent>* Filesystem::_internal_mutable_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::agent::Agent>* Filesystem::mutable_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:agent.Filesystem.agent)
  return _internal_mutable_agent();
}

// .agent.Filesystem.Common common = 2;
inline bool Filesystem::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Filesystem::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::agent::Filesystem_Common& Filesystem::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::Filesystem_Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::Filesystem_Common&>(::agent::_Filesystem_Common_default_instance_);
}
inline const ::agent::Filesystem_Common& Filesystem::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Filesystem.common)
  return _internal_common();
}
inline void Filesystem::unsafe_arena_set_allocated_common(::agent::Filesystem_Common* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::agent::Filesystem_Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.Filesystem.common)
}
inline ::agent::Filesystem_Common* Filesystem::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Filesystem_Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::Filesystem_Common* Filesystem::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Filesystem.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Filesystem_Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::agent::Filesystem_Common* Filesystem::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::Filesystem_Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::agent::Filesystem_Common*>(p);
  }
  return _impl_.common_;
}
inline ::agent::Filesystem_Common* Filesystem::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::agent::Filesystem_Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:agent.Filesystem.common)
  return _msg;
}
inline void Filesystem::set_allocated_common(::agent::Filesystem_Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::agent::Filesystem_Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.Filesystem.common)
}

// -------------------------------------------------------------------

// Auth

// string secret = 1;
inline void Auth::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& Auth::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Auth.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Auth::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Auth.secret)
}
inline std::string* Auth::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:agent.Auth.secret)
  return _s;
}
inline const std::string& Auth::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void Auth::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* Auth::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* Auth::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Auth.secret)
  return _impl_.secret_.Release();
}
inline void Auth::set_allocated_secret(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Auth.secret)
}

// -------------------------------------------------------------------

// TLS

// string key = 1;
inline void TLS::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& TLS::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.TLS.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TLS::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.TLS.key)
}
inline std::string* TLS::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:agent.TLS.key)
  return _s;
}
inline const std::string& TLS::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void TLS::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* TLS::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* TLS::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.TLS.key)
  return _impl_.key_.Release();
}
inline void TLS::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.TLS.key)
}

// string cert = 2;
inline void TLS::clear_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cert_.ClearToEmpty();
}
inline const std::string& TLS::cert() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.TLS.cert)
  return _internal_cert();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TLS::set_cert(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cert_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.TLS.cert)
}
inline std::string* TLS::mutable_cert() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cert();
  // @@protoc_insertion_point(field_mutable:agent.TLS.cert)
  return _s;
}
inline const std::string& TLS::_internal_cert() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cert_.Get();
}
inline void TLS::_internal_set_cert(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cert_.Set(value, GetArena());
}
inline std::string* TLS::_internal_mutable_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cert_.Mutable( GetArena());
}
inline std::string* TLS::release_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.TLS.cert)
  return _impl_.cert_.Release();
}
inline void TLS::set_allocated_cert(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cert_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cert_.IsDefault()) {
    _impl_.cert_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.TLS.cert)
}

// -------------------------------------------------------------------

// InstallSource

// .agent.InstallType type = 1;
inline void InstallSource::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::agent::InstallType InstallSource::type() const {
  // @@protoc_insertion_point(field_get:agent.InstallSource.type)
  return _internal_type();
}
inline void InstallSource::set_type(::agent::InstallType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:agent.InstallSource.type)
}
inline ::agent::InstallType InstallSource::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::agent::InstallType>(_impl_.type_);
}
inline void InstallSource::_internal_set_type(::agent::InstallType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string repo = 2;
inline void InstallSource::clear_repo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repo_.ClearToEmpty();
}
inline const std::string& InstallSource::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.InstallSource.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSource::set_repo(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.InstallSource.repo)
}
inline std::string* InstallSource::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:agent.InstallSource.repo)
  return _s;
}
inline const std::string& InstallSource::_internal_repo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.repo_.Get();
}
inline void InstallSource::_internal_set_repo(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* InstallSource::_internal_mutable_repo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* InstallSource::release_repo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.InstallSource.repo)
  return _impl_.repo_.Release();
}
inline void InstallSource::set_allocated_repo(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repo_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.repo_.IsDefault()) {
    _impl_.repo_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.InstallSource.repo)
}

// repeated .agent.SourceRef refs = 3;
inline int InstallSource::_internal_refs_size() const {
  return _internal_refs().size();
}
inline int InstallSource::refs_size() const {
  return _internal_refs_size();
}
inline void InstallSource::clear_refs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.refs_.Clear();
}
inline ::agent::SourceRef* InstallSource::mutable_refs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.InstallSource.refs)
  return _internal_mutable_refs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::agent::SourceRef>* InstallSource::mutable_refs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.InstallSource.refs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_refs();
}
inline const ::agent::SourceRef& InstallSource::refs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.InstallSource.refs)
  return _internal_refs().Get(index);
}
inline ::agent::SourceRef* InstallSource::add_refs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::agent::SourceRef* _add = _internal_mutable_refs()->Add();
  // @@protoc_insertion_point(field_add:agent.InstallSource.refs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::agent::SourceRef>& InstallSource::refs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.InstallSource.refs)
  return _internal_refs();
}
inline const ::google::protobuf::RepeatedPtrField<::agent::SourceRef>&
InstallSource::_internal_refs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.refs_;
}
inline ::google::protobuf::RepeatedPtrField<::agent::SourceRef>*
InstallSource::_internal_mutable_refs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.refs_;
}

// -------------------------------------------------------------------

// SourceRef

// .beegfs.NodeType service_type = 1;
inline void SourceRef::clear_service_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_type_ = 0;
}
inline ::beegfs::NodeType SourceRef::service_type() const {
  // @@protoc_insertion_point(field_get:agent.SourceRef.service_type)
  return _internal_service_type();
}
inline void SourceRef::set_service_type(::beegfs::NodeType value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:agent.SourceRef.service_type)
}
inline ::beegfs::NodeType SourceRef::_internal_service_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.service_type_);
}
inline void SourceRef::_internal_set_service_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_type_ = value;
}

// string ref = 2;
inline void SourceRef::clear_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ref_.ClearToEmpty();
}
inline const std::string& SourceRef::ref() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.SourceRef.ref)
  return _internal_ref();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SourceRef::set_ref(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ref_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.SourceRef.ref)
}
inline std::string* SourceRef::mutable_ref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:agent.SourceRef.ref)
  return _s;
}
inline const std::string& SourceRef::_internal_ref() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ref_.Get();
}
inline void SourceRef::_internal_set_ref(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ref_.Set(value, GetArena());
}
inline std::string* SourceRef::_internal_mutable_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ref_.Mutable( GetArena());
}
inline std::string* SourceRef::release_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.SourceRef.ref)
  return _impl_.ref_.Release();
}
inline void SourceRef::set_allocated_ref(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ref_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ref_.IsDefault()) {
    _impl_.ref_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.SourceRef.ref)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServiceConfig

// .beegfs.NodeType service_type = 1;
inline void ServiceConfig::clear_service_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_type_ = 0;
}
inline ::beegfs::NodeType ServiceConfig::service_type() const {
  // @@protoc_insertion_point(field_get:agent.ServiceConfig.service_type)
  return _internal_service_type();
}
inline void ServiceConfig::set_service_type(::beegfs::NodeType value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:agent.ServiceConfig.service_type)
}
inline ::beegfs::NodeType ServiceConfig::_internal_service_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.service_type_);
}
inline void ServiceConfig::_internal_set_service_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_type_ = value;
}

// map<string, string> string_map = 2;
inline int ServiceConfig::_internal_string_map_size() const {
  return _internal_string_map().size();
}
inline int ServiceConfig::string_map_size() const {
  return _internal_string_map_size();
}
inline void ServiceConfig::clear_string_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.string_map_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ServiceConfig::_internal_string_map() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.string_map_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ServiceConfig::string_map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:agent.ServiceConfig.string_map)
  return _internal_string_map();
}
inline ::google::protobuf::Map<std::string, std::string>* ServiceConfig::_internal_mutable_string_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.string_map_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ServiceConfig::mutable_string_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:agent.ServiceConfig.string_map)
  return _internal_mutable_string_map();
}

// -------------------------------------------------------------------

// Agent

// repeated .agent.Service services = 1;
inline int Agent::_internal_services_size() const {
  return _internal_services().size();
}
inline int Agent::services_size() const {
  return _internal_services_size();
}
inline void Agent::clear_services() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.services_.Clear();
}
inline ::agent::Service* Agent::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.Agent.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::agent::Service>* Agent::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.Agent.services)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_services();
}
inline const ::agent::Service& Agent::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Agent.services)
  return _internal_services().Get(index);
}
inline ::agent::Service* Agent::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::agent::Service* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:agent.Agent.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Service>& Agent::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.Agent.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Service>&
Agent::_internal_services() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::agent::Service>*
Agent::_internal_mutable_services() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.services_;
}

// repeated .agent.Nic interfaces = 2;
inline int Agent::_internal_interfaces_size() const {
  return _internal_interfaces().size();
}
inline int Agent::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void Agent::clear_interfaces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interfaces_.Clear();
}
inline ::agent::Nic* Agent::mutable_interfaces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.Agent.interfaces)
  return _internal_mutable_interfaces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::agent::Nic>* Agent::mutable_interfaces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.Agent.interfaces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_interfaces();
}
inline const ::agent::Nic& Agent::interfaces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Agent.interfaces)
  return _internal_interfaces().Get(index);
}
inline ::agent::Nic* Agent::add_interfaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::agent::Nic* _add = _internal_mutable_interfaces()->Add();
  // @@protoc_insertion_point(field_add:agent.Agent.interfaces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Nic>& Agent::interfaces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.Agent.interfaces)
  return _internal_interfaces();
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Nic>&
Agent::_internal_interfaces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.interfaces_;
}
inline ::google::protobuf::RepeatedPtrField<::agent::Nic>*
Agent::_internal_mutable_interfaces() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.interfaces_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Service

// uint32 num_id = 1;
inline void Service::clear_num_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = 0u;
}
inline ::uint32_t Service::num_id() const {
  // @@protoc_insertion_point(field_get:agent.Service.num_id)
  return _internal_num_id();
}
inline void Service::set_num_id(::uint32_t value) {
  _internal_set_num_id(value);
  // @@protoc_insertion_point(field_set:agent.Service.num_id)
}
inline ::uint32_t Service::_internal_num_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_id_;
}
inline void Service::_internal_set_num_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = value;
}

// .beegfs.NodeType service_type = 2;
inline void Service::clear_service_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_type_ = 0;
}
inline ::beegfs::NodeType Service::service_type() const {
  // @@protoc_insertion_point(field_get:agent.Service.service_type)
  return _internal_service_type();
}
inline void Service::set_service_type(::beegfs::NodeType value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:agent.Service.service_type)
}
inline ::beegfs::NodeType Service::_internal_service_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::beegfs::NodeType>(_impl_.service_type_);
}
inline void Service::_internal_set_service_type(::beegfs::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_type_ = value;
}

// map<string, string> config = 3;
inline int Service::_internal_config_size() const {
  return _internal_config().size();
}
inline int Service::config_size() const {
  return _internal_config_size();
}
inline void Service::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Service::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Service::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:agent.Service.config)
  return _internal_config();
}
inline ::google::protobuf::Map<std::string, std::string>* Service::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Service::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:agent.Service.config)
  return _internal_mutable_config();
}

// repeated .agent.Nic interfaces = 4;
inline int Service::_internal_interfaces_size() const {
  return _internal_interfaces().size();
}
inline int Service::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void Service::clear_interfaces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interfaces_.Clear();
}
inline ::agent::Nic* Service::mutable_interfaces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.Service.interfaces)
  return _internal_mutable_interfaces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::agent::Nic>* Service::mutable_interfaces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.Service.interfaces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_interfaces();
}
inline const ::agent::Nic& Service::interfaces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Service.interfaces)
  return _internal_interfaces().Get(index);
}
inline ::agent::Nic* Service::add_interfaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::agent::Nic* _add = _internal_mutable_interfaces()->Add();
  // @@protoc_insertion_point(field_add:agent.Service.interfaces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Nic>& Service::interfaces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.Service.interfaces)
  return _internal_interfaces();
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Nic>&
Service::_internal_interfaces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.interfaces_;
}
inline ::google::protobuf::RepeatedPtrField<::agent::Nic>*
Service::_internal_mutable_interfaces() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.interfaces_;
}

// repeated .agent.Target targets = 5;
inline int Service::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int Service::targets_size() const {
  return _internal_targets_size();
}
inline void Service::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline ::agent::Target* Service::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:agent.Service.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::agent::Target>* Service::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:agent.Service.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::agent::Target& Service::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Service.targets)
  return _internal_targets().Get(index);
}
inline ::agent::Target* Service::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::agent::Target* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:agent.Service.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Target>& Service::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:agent.Service.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::agent::Target>&
Service::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::agent::Target>*
Service::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// string executable = 6;
inline void Service::clear_executable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executable_.ClearToEmpty();
}
inline const std::string& Service::executable() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Service.executable)
  return _internal_executable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Service::set_executable(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executable_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Service.executable)
}
inline std::string* Service::mutable_executable() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_executable();
  // @@protoc_insertion_point(field_mutable:agent.Service.executable)
  return _s;
}
inline const std::string& Service::_internal_executable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executable_.Get();
}
inline void Service::_internal_set_executable(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executable_.Set(value, GetArena());
}
inline std::string* Service::_internal_mutable_executable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.executable_.Mutable( GetArena());
}
inline std::string* Service::release_executable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Service.executable)
  return _impl_.executable_.Release();
}
inline void Service::set_allocated_executable(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executable_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.executable_.IsDefault()) {
    _impl_.executable_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Service.executable)
}

// -------------------------------------------------------------------

// Nic

// string name = 1;
inline void Nic::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Nic::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Nic.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Nic::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Nic.name)
}
inline std::string* Nic::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:agent.Nic.name)
  return _s;
}
inline const std::string& Nic::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Nic::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Nic::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Nic::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Nic.name)
  return _impl_.name_.Release();
}
inline void Nic::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Nic.name)
}

// string addr = 2;
inline void Nic::clear_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Nic::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Nic.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Nic::set_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Nic.addr)
}
inline std::string* Nic::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:agent.Nic.addr)
  return _s;
}
inline const std::string& Nic::_internal_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.addr_.Get();
}
inline void Nic::_internal_set_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* Nic::_internal_mutable_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* Nic::release_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Nic.addr)
  return _impl_.addr_.Release();
}
inline void Nic::set_allocated_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Nic.addr)
}

// -------------------------------------------------------------------

// Target_UnderlyingFSOpts

// string device = 1;
inline void Target_UnderlyingFSOpts::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Target_UnderlyingFSOpts::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Target.UnderlyingFSOpts.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Target_UnderlyingFSOpts::set_device(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Target.UnderlyingFSOpts.device)
}
inline std::string* Target_UnderlyingFSOpts::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:agent.Target.UnderlyingFSOpts.device)
  return _s;
}
inline const std::string& Target_UnderlyingFSOpts::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_.Get();
}
inline void Target_UnderlyingFSOpts::_internal_set_device(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Target_UnderlyingFSOpts::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Target_UnderlyingFSOpts::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Target.UnderlyingFSOpts.device)
  return _impl_.device_.Release();
}
inline void Target_UnderlyingFSOpts::set_allocated_device(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Target.UnderlyingFSOpts.device)
}

// .agent.Target.UnderlyingFSOpts.FsType type = 2;
inline void Target_UnderlyingFSOpts::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::agent::Target_UnderlyingFSOpts_FsType Target_UnderlyingFSOpts::type() const {
  // @@protoc_insertion_point(field_get:agent.Target.UnderlyingFSOpts.type)
  return _internal_type();
}
inline void Target_UnderlyingFSOpts::set_type(::agent::Target_UnderlyingFSOpts_FsType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:agent.Target.UnderlyingFSOpts.type)
}
inline ::agent::Target_UnderlyingFSOpts_FsType Target_UnderlyingFSOpts::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::agent::Target_UnderlyingFSOpts_FsType>(_impl_.type_);
}
inline void Target_UnderlyingFSOpts::_internal_set_type(::agent::Target_UnderlyingFSOpts_FsType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string format_flags = 3;
inline void Target_UnderlyingFSOpts::clear_format_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_flags_.ClearToEmpty();
}
inline const std::string& Target_UnderlyingFSOpts::format_flags() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Target.UnderlyingFSOpts.format_flags)
  return _internal_format_flags();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Target_UnderlyingFSOpts::set_format_flags(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_flags_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Target.UnderlyingFSOpts.format_flags)
}
inline std::string* Target_UnderlyingFSOpts::mutable_format_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_format_flags();
  // @@protoc_insertion_point(field_mutable:agent.Target.UnderlyingFSOpts.format_flags)
  return _s;
}
inline const std::string& Target_UnderlyingFSOpts::_internal_format_flags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.format_flags_.Get();
}
inline void Target_UnderlyingFSOpts::_internal_set_format_flags(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_flags_.Set(value, GetArena());
}
inline std::string* Target_UnderlyingFSOpts::_internal_mutable_format_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.format_flags_.Mutable( GetArena());
}
inline std::string* Target_UnderlyingFSOpts::release_format_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Target.UnderlyingFSOpts.format_flags)
  return _impl_.format_flags_.Release();
}
inline void Target_UnderlyingFSOpts::set_allocated_format_flags(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_flags_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.format_flags_.IsDefault()) {
    _impl_.format_flags_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Target.UnderlyingFSOpts.format_flags)
}

// string mount_flags = 4;
inline void Target_UnderlyingFSOpts::clear_mount_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mount_flags_.ClearToEmpty();
}
inline const std::string& Target_UnderlyingFSOpts::mount_flags() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Target.UnderlyingFSOpts.mount_flags)
  return _internal_mount_flags();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Target_UnderlyingFSOpts::set_mount_flags(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mount_flags_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Target.UnderlyingFSOpts.mount_flags)
}
inline std::string* Target_UnderlyingFSOpts::mutable_mount_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mount_flags();
  // @@protoc_insertion_point(field_mutable:agent.Target.UnderlyingFSOpts.mount_flags)
  return _s;
}
inline const std::string& Target_UnderlyingFSOpts::_internal_mount_flags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mount_flags_.Get();
}
inline void Target_UnderlyingFSOpts::_internal_set_mount_flags(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mount_flags_.Set(value, GetArena());
}
inline std::string* Target_UnderlyingFSOpts::_internal_mutable_mount_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mount_flags_.Mutable( GetArena());
}
inline std::string* Target_UnderlyingFSOpts::release_mount_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Target.UnderlyingFSOpts.mount_flags)
  return _impl_.mount_flags_.Release();
}
inline void Target_UnderlyingFSOpts::set_allocated_mount_flags(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mount_flags_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mount_flags_.IsDefault()) {
    _impl_.mount_flags_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Target.UnderlyingFSOpts.mount_flags)
}

// -------------------------------------------------------------------

// Target

// uint32 num_id = 1;
inline void Target::clear_num_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = 0u;
}
inline ::uint32_t Target::num_id() const {
  // @@protoc_insertion_point(field_get:agent.Target.num_id)
  return _internal_num_id();
}
inline void Target::set_num_id(::uint32_t value) {
  _internal_set_num_id(value);
  // @@protoc_insertion_point(field_set:agent.Target.num_id)
}
inline ::uint32_t Target::_internal_num_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_id_;
}
inline void Target::_internal_set_num_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_id_ = value;
}

// string path = 2;
inline void Target::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Target::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Target.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Target::set_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:agent.Target.path)
}
inline std::string* Target::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:agent.Target.path)
  return _s;
}
inline const std::string& Target::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void Target::_internal_set_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(value, GetArena());
}
inline std::string* Target::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* Target::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Target.path)
  return _impl_.path_.Release();
}
inline void Target::set_allocated_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.Target.path)
}

// optional .agent.Target.UnderlyingFSOpts ulfs = 3;
inline bool Target::has_ulfs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ulfs_ != nullptr);
  return value;
}
inline void Target::clear_ulfs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ulfs_ != nullptr) _impl_.ulfs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::agent::Target_UnderlyingFSOpts& Target::_internal_ulfs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::agent::Target_UnderlyingFSOpts* p = _impl_.ulfs_;
  return p != nullptr ? *p : reinterpret_cast<const ::agent::Target_UnderlyingFSOpts&>(::agent::_Target_UnderlyingFSOpts_default_instance_);
}
inline const ::agent::Target_UnderlyingFSOpts& Target::ulfs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:agent.Target.ulfs)
  return _internal_ulfs();
}
inline void Target::unsafe_arena_set_allocated_ulfs(::agent::Target_UnderlyingFSOpts* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ulfs_);
  }
  _impl_.ulfs_ = reinterpret_cast<::agent::Target_UnderlyingFSOpts*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:agent.Target.ulfs)
}
inline ::agent::Target_UnderlyingFSOpts* Target::release_ulfs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Target_UnderlyingFSOpts* released = _impl_.ulfs_;
  _impl_.ulfs_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::agent::Target_UnderlyingFSOpts* Target::unsafe_arena_release_ulfs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:agent.Target.ulfs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::agent::Target_UnderlyingFSOpts* temp = _impl_.ulfs_;
  _impl_.ulfs_ = nullptr;
  return temp;
}
inline ::agent::Target_UnderlyingFSOpts* Target::_internal_mutable_ulfs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ulfs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::agent::Target_UnderlyingFSOpts>(GetArena());
    _impl_.ulfs_ = reinterpret_cast<::agent::Target_UnderlyingFSOpts*>(p);
  }
  return _impl_.ulfs_;
}
inline ::agent::Target_UnderlyingFSOpts* Target::mutable_ulfs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::agent::Target_UnderlyingFSOpts* _msg = _internal_mutable_ulfs();
  // @@protoc_insertion_point(field_mutable:agent.Target.ulfs)
  return _msg;
}
inline void Target::set_allocated_ulfs(::agent::Target_UnderlyingFSOpts* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ulfs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ulfs_ = reinterpret_cast<::agent::Target_UnderlyingFSOpts*>(value);
  // @@protoc_insertion_point(field_set_allocated:agent.Target.ulfs)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace agent


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::agent::Status_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::agent::Status_State>() {
  return ::agent::Status_State_descriptor();
}
template <>
struct is_proto_enum<::agent::Target_UnderlyingFSOpts_FsType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::agent::Target_UnderlyingFSOpts_FsType>() {
  return ::agent::Target_UnderlyingFSOpts_FsType_descriptor();
}
template <>
struct is_proto_enum<::agent::InstallType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::agent::InstallType>() {
  return ::agent::InstallType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // agent_2eproto_2epb_2eh
