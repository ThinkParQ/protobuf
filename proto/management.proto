syntax = "proto3";
package management;
option go_package = "github.com/thinkparq/protobuf/go/management";

import "beegfs.proto";
import "license.proto";

service Management {
  rpc SetAlias(SetAliasRequest) returns (SetAliasResponse);

  // Nodes
  rpc GetNodes(GetNodesRequest) returns (GetNodesResponse);
  rpc DeleteNode(DeleteNodeRequest) returns (DeleteNodeResponse);

  // Targets
  rpc GetTargets(GetTargetsRequest) returns (GetTargetsResponse);
  rpc DeleteTarget(DeleteTargetRequest) returns (DeleteTargetResponse);
  // Manually set a target consistency state 
  rpc SetTargetState(SetTargetStateRequest) returns (SetTargetStateResponse);
  
  // (Storage) pools
  rpc GetPools(GetPoolsRequest) returns (GetPoolsResponse);
  rpc CreatePool(CreatePoolRequest) returns (CreatePoolResponse);
  rpc AssignPool(AssignPoolRequest) returns (AssignPoolResponse);
  rpc DeletePool(DeletePoolRequest) returns (DeletePoolResponse);

  // Buddy groups
  rpc GetBuddyGroups(GetBuddyGroupsRequest) returns (GetBuddyGroupsResponse);
  rpc CreateBuddyGroup(CreateBuddyGroupRequest) returns (CreateBuddyGroupResponse);
  rpc DeleteBuddyGroup(DeleteBuddyGroupRequest) returns (DeleteBuddyGroupResponse);
  rpc MirrorRootInode(MirrorRootInodeRequest) returns (MirrorRootInodeResponse);
  rpc StartResync(StartResyncRequest) returns (StartResyncResponse);

  // Quota
  rpc SetDefaultQuotaLimits(SetDefaultQuotaLimitsRequest) returns (SetDefaultQuotaLimitsResponse);
  rpc SetQuotaLimits(SetQuotaLimitsRequest) returns (SetQuotaLimitsResponse);
  rpc GetQuotaLimits(GetQuotaLimitsRequest) returns (stream GetQuotaLimitsResponse);
  rpc GetQuotaUsage(GetQuotaUsageRequest) returns (stream GetQuotaUsageResponse);

  // Licensing
  rpc GetLicense(GetLicenseRequest) returns (GetLicenseResponse);
}

// Sets an entity alias
message SetAliasRequest {
  // The identifier to set the alias for
  beegfs.EntityIdSet entity_id = 1;
  // The entity type to set the alias for
  beegfs.EntityType entity_type = 2;
  // The new alias
  string new_alias = 3;
}
message SetAliasResponse {}

// Nodes

// Gets the full list of nodes
message GetNodesRequest {
  // Query the nic list for each node and include it in the response
  bool include_nics = 1;
}
message GetNodesResponse {
  // BeeGFS node related data
  message Node {
    // BeeGFS nic related data
    message Nic {
      // The nics IPv4 address in the form aaa.bbb.ccc.ddd:port
      string addr = 1;
      // The nics name (note that this is NOT an alias as a Nic is not considered an entity)
      string name = 2;
      // The nics type
      beegfs.NicType nic_type = 3;
    }
    // The node identifiers
    beegfs.EntityIdSet id = 1;
    // The node type
    beegfs.NodeType node_type = 2;
    // The nodes TCP and UDP port.
    uint32 port = 3;
    // The nodes Nics
    repeated Nic nics = 4;
  }

  // The list of nodes
  repeated Node nodes = 1;
  // The node containing the root inode. Will be missing on a fresh system without any meta
  // targets/nodes.
  optional beegfs.EntityIdSet meta_root_node = 2;
  // The file system UUID for this BeeGFS
  optional string fs_uuid = 3;
}

// Deletes a node from the system
message DeleteNodeRequest {
  // The node to delete
  optional beegfs.EntityIdSet node = 1;
  // If set to false, check if delete is possible but don't execute it
  optional bool execute = 2;
}
message DeleteNodeResponse {
  // The ids of the deleted node
  optional beegfs.EntityIdSet node = 1;
}

// Targets

// Gets the full list of targets
message GetTargetsRequest {}
message GetTargetsResponse {
  // A BeeGFS target
  message Target {
    // The targets identifiers
    beegfs.EntityIdSet id = 1;
    // Node type the target is on
    beegfs.NodeType node_type = 2;
    // The targets reachability state as reported by management
    beegfs.ReachabilityState reachability_state = 3;
    // The targets reachability state as reported by management
    beegfs.ConsistencyState consistency_state = 4;
    // Duration since last contact to the target. Currently slightly inaccurate as it updates
    // not on each received message.
    optional uint64 last_contact_s = 5;
    // Total space on the target as reported by management
    optional uint64 total_space_bytes = 6;
    // Free space on the target as reported by management
    optional uint64 free_space_bytes = 7;
    // Total inodes on the target as reported by management
    optional uint64 total_inodes = 8;
    // Free inodes on the target as reported by management
    optional uint64 free_inodes = 9;
    // The targets capacity pool as reported by the management
    beegfs.CapacityPool cap_pool = 10;
    // The targets owner node identifiers
    beegfs.EntityIdSet node = 11;
    // The targets storage pool identifiers. Explicitly optional since meta targets don't have a storage pool.
    optional beegfs.EntityIdSet storage_pool = 12;
  }

  // The list of targets
  repeated Target targets = 1;
}

// Deletes a target from the system
message DeleteTargetRequest {
  // The target to delete
  optional beegfs.EntityIdSet target = 1;
  // If set to false, check if delete is possible but don't execute it
  optional bool execute = 2;
}
message DeleteTargetResponse {
  // The ids of the deleted target
  optional beegfs.EntityIdSet target = 1;
}

message SetTargetStateRequest{
    // Identifier of the target whose state is to be changed
    optional beegfs.EntityIdSet target = 1;
    // Consistency state to set for the target
    optional beegfs.ConsistencyState consistency_state = 2;
}
message SetTargetStateResponse{}


// (Storage) pools

// Gets the full list of pools
message GetPoolsRequest {
  // Include quota limits in the response
  bool with_quota_limits = 1;
}
message GetPoolsResponse {
  message StoragePool {
    // The storage pools identifiers
    beegfs.EntityIdSet id = 1;
    // The storage pools assigned targets identifiers
    repeated beegfs.EntityIdSet targets = 2;
    // The storage pools assigned buddy groups identifiers
    repeated beegfs.EntityIdSet buddy_groups = 3;
    // -1 means unlimited. May be unset.
    optional int64 user_space_limit = 4;
    // -1 means unlimited. May be unset.
    optional int64 user_inode_limit = 5;
    // -1 means unlimited. May be unset.
    optional int64 group_space_limit = 6;
    // -1 means unlimited. May be unset.
    optional int64 group_inode_limit = 7;
  }

  // The list of storage pools
  repeated StoragePool pools = 1;
}

// Creates a new pool
message CreatePoolRequest {
  // The node type of the new pool (currently, only storage is allowed)
  optional beegfs.NodeType node_type = 1;
  // The numeric id of the new pool. Chosen automatically if omitted.
  optional uint32 num_id = 2;
  // The alias of the new pool
  optional string alias = 3;
  // Targets assigned to the new pool
  repeated beegfs.EntityIdSet targets = 4;
  // Buddy groups assigned to the new pool
  repeated beegfs.EntityIdSet buddy_groups = 5;
}
message CreatePoolResponse {
  // The ids of the new pool
  optional beegfs.EntityIdSet pool = 1;
}

// Assigns targets and buddy groups to a pool
message AssignPoolRequest {
  // The pool to assign to
  optional beegfs.EntityIdSet pool = 1;
  // Targets to assign
  repeated beegfs.EntityIdSet targets = 2;
  // Buddy groups to assign
  repeated beegfs.EntityIdSet buddy_groups = 3;
}
message AssignPoolResponse {
  // The ids of the pool assigned to
  optional beegfs.EntityIdSet pool = 1;
}

  // Deletes a pool from the system
message DeletePoolRequest {
  // The pool to delete
  optional beegfs.EntityIdSet pool = 1;
  // If set to false, check if delete is possible but don't execute it
  optional bool execute = 2;
}
message DeletePoolResponse {
  // The ids of the deleted pool
  optional beegfs.EntityIdSet pool = 1;
}

// Buddy groups

// Gets the full list of buddy groups
message GetBuddyGroupsRequest {}
message GetBuddyGroupsResponse {
  message BuddyGroup {
    // The buddy groups identifiers
    beegfs.EntityIdSet id = 1;
    // Node type the buddy group belongs to
    beegfs.NodeType node_type = 2;
    // The buddy groups current primary target identifiers
    beegfs.EntityIdSet primary_target = 3;
    // The buddy groups current secondary target identifiers
    beegfs.EntityIdSet secondary_target = 4;
    // The buddy groups primary target consistency state
    beegfs.ConsistencyState primary_consistency_state = 5;
    // The buddy groups secondary target consistency state
    beegfs.ConsistencyState secondary_consistency_state = 6;
    // The buddy groups storage pool. Explicitly optional since meta pools dont' have a storage
    // pool.
    optional beegfs.EntityIdSet storage_pool = 7;
  }

  // The list of buddy groups
  repeated BuddyGroup buddy_groups = 1;
}

// Creates a new buddy group
message CreateBuddyGroupRequest {
  // The node type of the new buddy group
  optional beegfs.NodeType node_type = 1;
  // The numeric id of the new buddy group. Chosen automatically if omitted.
  optional uint32 num_id = 2;
  // The alias of the new buddy group
  optional string alias = 3;
  // The primary target of the new buddy group
  optional beegfs.EntityIdSet primary_target = 4;
  // The secondary target of the new buddy group
  optional beegfs.EntityIdSet secondary_target = 5;
}
message CreateBuddyGroupResponse {
  // The ids of the new buddy group
  optional beegfs.EntityIdSet group = 1;
}

// Deletes a buddy group from the system
message DeleteBuddyGroupRequest {
  // The buddy group to delete
  optional beegfs.EntityIdSet group = 1;
  // If set to false, check if delete is possible but don't execute it
  optional bool execute = 2;
}
message DeleteBuddyGroupResponse {
  // The ids of the deleted buddy group
  optional beegfs.EntityIdSet group = 1;
}

// Enable metadata mirroring for the root directory
message MirrorRootInodeRequest{}
message MirrorRootInodeResponse{}

// Manually start a resync by setting the secondary target's consistency state to needs_resync
message StartResyncRequest {
  // The buddy group whose secondary target will be resynced from its primary target
  optional beegfs.EntityIdSet buddy_group = 1;
  // For storage targets: resyncs all data after the given epoch timestamp. 
  // If set to -1, performs a complete resync. 
  // For meta targets, this must be -1 as they can only perform complete resyncs.
  optional int64 timestamp = 2;
  // For storage targets only: if true, aborts an ongoing resync and restarts. 
  // Not applicable to meta targets as meta resync cannot be aborted.
  optional bool restart = 3;
}
message StartResyncResponse{}

// Quota

// Contains info belonging to a quota_id + id_type + pool entry (e.g. user 1000 on storage pool 1).
// Depending on the message, some fields are unused.
message QuotaInfo {
  // The system user/group id the info belongs to
  optional uint32 quota_id = 1;
  // The id type (user or group)
  beegfs.QuotaIdType id_type = 2;
  // The storage pool the info belongs to
  optional beegfs.EntityIdSet pool = 3;
  // -1 means unlimited
  optional int64 space_limit = 4;
  // -1 means unlimited
  optional int64 inode_limit = 5;
  // -1 means unlimited
  optional int64 space_used = 6;
  // -1 means unlimited
  optional int64 inode_used = 7;
}

// Sets the default quota limits for a pool. -1 means unlimited.
message SetDefaultQuotaLimitsRequest {
  // The pool to set the limits for
  optional beegfs.EntityIdSet pool = 1;
  // -1 means unlimited
  optional int64 user_space_limit = 2;
  // -1 means unlimited
  optional int64 user_inode_limit = 3;
  // -1 means unlimited
  optional int64 group_space_limit = 4;
  // -1 means unlimited
  optional int64 group_inode_limit = 5;
}
message SetDefaultQuotaLimitsResponse {}

// Sets the individually set per-id-and-pool quota limits
message SetQuotaLimitsRequest {
  // The explicit quota limit entries to set on the management. The _used fields are ignored.
  repeated QuotaInfo limits = 1;
}
message SetQuotaLimitsResponse {}

// Gets the individually set per-id-and-pool quota limits. Retrieves all explicitly set entries.
message GetQuotaLimitsRequest {
  // The minimum id to return. Only applies when set.
  optional uint32 quota_id_min = 1;
  // The maximum id to return. Only applies when set.
  optional uint32 quota_id_max = 2;
  // Return only user or group ids. Only applies when set.
  beegfs.QuotaIdType id_type = 3;
  // Return only a specific pool. Only applies when set.
  optional beegfs.EntityIdSet pool = 4;
}
message GetQuotaLimitsResponse {
  // The explicit quota limit entries known by the management.
  // The _used fields are unused in this response.
  optional QuotaInfo limits = 1;
}

// Gets the quota usage info for all the ids the management knows about. In addition, contains
// the effective limits for each entry.
message GetQuotaUsageRequest {
  // The minimum id to return. Only applies when set.
  optional uint32 quota_id_min = 1;
  // The maximum id to return. Only applies when set.
  optional uint32 quota_id_max = 2;
  // Return only user or group ids. Only applies when set.
  beegfs.QuotaIdType id_type = 3;
  // Return only a specific pool. Only applies when set.
  optional beegfs.EntityIdSet pool = 4;
  // Return only exceeded or not exceeded entries. Only applies when set.
  optional bool exceeded = 5;
}
message GetQuotaUsageResponse {
  // The quota usage entry
  optional QuotaInfo entry = 1;
  // The refresh period of the quota usage info in seconds. Since this is not related to a quota
  // usage entry, it is supposed to be only set on the first message.
  optional uint64 refresh_period_s = 2;
}

// Licensing

// Gets license information
message GetLicenseRequest {
  // Whether to reload and re-verify the license on the server
  optional bool reload = 1;
}
message GetLicenseResponse {
  // A CertData structure as defined in beecert.proto
  optional license.GetCertDataResult cert_data = 1;
}

